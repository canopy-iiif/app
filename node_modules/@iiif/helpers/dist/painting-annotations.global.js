"use strict";
var IIIFHelpers = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/painting-annotations.ts
  var painting_annotations_exports = {};
  __export(painting_annotations_exports, {
    createPaintingAnnotationsHelper: () => createPaintingAnnotationsHelper,
    parseSpecificResource: () => parseSpecificResource
  });

  // src/painting-annotations/parse-specific-resource.ts
  function parseSpecificResource(resource) {
    if (resource.type === "SpecificResource") {
      return [resource.source, { selector: resource.selector }];
    }
    return [resource, { selector: null }];
  }

  // src/compat.ts
  var metaState = {};
  var compatVault = {
    get(nonRef) {
      return nonRef;
    },
    setMetaValue([id, meta, key], value) {
      const oldValue = compatVault.getResourceMeta(id, meta);
      const oldValueItem = oldValue ? oldValue[key] : void 0;
      const newValue = typeof value === "function" ? value(oldValueItem) : value;
      metaState[id] = {
        ...metaState[id] || {},
        [meta]: {
          ...(metaState[id] || {})[meta] || {},
          [key]: newValue
        }
      };
    },
    getResourceMeta: (resource, metaKey) => {
      const resourceMeta = metaState[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    },
    async load(id) {
      const idToLoad = typeof id === "string" ? id : id.id;
      return fetch(idToLoad).then((response) => response.json());
    },
    requestStatus(id) {
      return void 0;
    }
  };

  // src/painting-annotations/helper.ts
  function createPaintingAnnotationsHelper(vault = compatVault) {
    function getAllPaintingAnnotations(canvasOrId) {
      const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
      if (!canvas) {
        return [];
      }
      const annotationPages = vault.get(canvas.items, { parent: canvas });
      const flatAnnotations = [];
      for (const page of annotationPages) {
        flatAnnotations.push(...vault.get(page.items, { parent: page }));
      }
      return flatAnnotations;
    }
    function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
      const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
      const types = [];
      let choices = {
        items: [],
        type: "complex-choice"
      };
      const items = [];
      for (const annotation of paintingAnnotations) {
        if (annotation.type !== "Annotation") {
          throw new Error(`getPaintables() accept either a canvas or list of annotations`);
        }
        const references = Array.from(Array.isArray(annotation.body) ? annotation.body : [annotation.body]);
        for (const reference of references) {
          const [ref, { selector }] = parseSpecificResource(reference);
          const body = vault.get(ref);
          const type = (body.type || "unknown").toLowerCase();
          if (type === "choice") {
            const nestedBodies = vault.get(body.items, { parent: body.id });
            const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b) => b.id === cid)).filter(Boolean) : [nestedBodies[0]];
            if (selected.length === 0) {
              selected.push(nestedBodies[0]);
            }
            choices.items.push({
              type: "single-choice",
              items: nestedBodies.map((b) => ({
                id: b.id,
                label: b.label,
                selected: selected.indexOf(b) !== -1
              })),
              label: ref.label
            });
            references.push(...selected);
            continue;
          }
          if (types.indexOf(type) === -1) {
            types.push(type);
          }
          items.push({
            type,
            annotationId: annotation.id,
            annotation,
            resource: body,
            target: annotation.target,
            selector
          });
        }
      }
      return {
        types,
        items,
        choice: choices.items.length < 2 ? choices.items[0] || null : choices,
        allChoices: choices.items.length ? choices : null
      };
    }
    function extractChoices(paintingAnnotationsOrCanvas) {
      const { choice } = getPaintables(paintingAnnotationsOrCanvas);
      return choice;
    }
    return {
      getAllPaintingAnnotations,
      getPaintables,
      extractChoices
    };
  }
  return __toCommonJS(painting_annotations_exports);
})();
