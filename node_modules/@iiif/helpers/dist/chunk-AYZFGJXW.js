import {
  expandTarget
} from "./chunk-MGQKBQDS.js";

// src/content-state.ts
function validateContentState(annotation, strict = false) {
  if (typeof annotation === "string") {
    if (annotation.startsWith("{")) {
      try {
        const parsed = JSON.parse(annotation);
        return validateContentState(parsed);
      } catch (err) {
        return [false, { reason: "Invalid JSON" }];
      }
    }
    return [true];
  }
  if (Array.isArray(annotation)) {
    for (const anno of annotation) {
      const [valid, reason] = validateContentState(anno);
      if (!valid && reason) {
        return [valid, reason];
      }
    }
    return [true];
  }
  if (annotation.type === "Annotation") {
    return [true];
  }
  if (strict && annotation.type === "Canvas" && !annotation.partOf) {
    return [false, { reason: "Canvas without partOf cannot be loaded" }];
  }
  return [true];
}
function serialiseContentState(annotation) {
  return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
}
function parseContentState(state, asyncOrFetcher) {
  state = state.trim();
  if (state[0] === "{") {
    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
  }
  if (state.startsWith("http")) {
    if (!asyncOrFetcher) {
      throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
    }
    return fetch(state).then((r) => r.json());
  }
  return parseContentState(decodeContentState(state), asyncOrFetcher);
}
function encodeContentState(state) {
  const uriEncoded = encodeURIComponent(state);
  const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
  const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
  return base64url.replace(/=/g, "");
}
function decodeContentState(encodedContentState) {
  const base64url = restorePadding(encodedContentState);
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
  return decodeURIComponent(base64Decoded).trim();
}
function restorePadding(s) {
  const pad = s.length % 4;
  if (pad === 1) {
    throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
  }
  return s + (pad ? "====".slice(0, 4 - pad) : "");
}
function normaliseContentState(state) {
  if (!state) {
    throw new Error("Content state is empty");
  }
  if (!Array.isArray(state)) {
    state = [state];
  }
  let annoId = "vault://virtual-annotation/" + (/* @__PURE__ */ new Date()).getTime();
  const motivation = ["contentState"];
  const targets = [];
  for (const source of state) {
    if (typeof source === "string") {
      throw new Error("Content state is a [String] type and cannot be inferred");
    }
    if (source.type === "Annotation") {
      annoId = source.id;
      if (Array.isArray(source.motivation)) {
        for (const singleMotivation of source.motivation) {
          if (motivation.indexOf(singleMotivation) === -1) {
            motivation.push(singleMotivation);
          }
        }
      }
      if (Array.isArray(source.target)) {
        for (const target2 of source.target) {
          const expanded = expandTarget(target2);
          targets.push(expanded);
        }
      } else {
        const expanded = expandTarget(source.target);
        targets.push(expanded);
      }
      continue;
    }
    const target = expandTarget(source);
    targets.push(target);
  }
  return {
    id: annoId,
    type: "Annotation",
    motivation: ["contentState", ...state.motivation || []],
    target: targets,
    extensions: {}
  };
}

export {
  validateContentState,
  serialiseContentState,
  parseContentState,
  encodeContentState,
  decodeContentState,
  normaliseContentState
};
