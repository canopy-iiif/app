import {
  RESOURCE_ERROR,
  RESOURCE_LOADING,
  RESOURCE_READY,
  addMapping,
  addMappings,
  batchActions,
  importEntities,
  requestComplete,
  requestError,
  requestMismatch,
  requestResource
} from "./chunk-F2Q2OM3J.js";

// src/vault/utility/action-list-from-resource.ts
import { normalize } from "@iiif/parser";
var actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = normalize(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

// src/vault/utility/are-inputs-equal.ts
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

// src/vault/utility/resolve-if-exists.ts
import { frameResource, HAS_PART, PART_OF } from "@iiif/parser";
function resolveIfExists(state, url, parent) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  const fullEntity = state.iiif.entities[resourceType][request.resourceUri];
  if (fullEntity && fullEntity[HAS_PART]) {
    const framing = fullEntity[HAS_PART].find((t) => {
      return parent ? t[PART_OF] === parent.id : t[PART_OF] === fullEntity.id;
    });
    return frameResource(fullEntity, framing);
  }
  return fullEntity;
}

// src/vault/utility/is-promise.ts
function isPromise(value) {
  return value && typeof value.then === "function";
}

// src/vault/utility/create-fetch-helper.ts
function createFetchHelper(vault, fetcher, { waitTimeout = 30 } = {}) {
  return (url, options, mapper) => {
    const store = vault.getStore();
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      if (request.loadingState === RESOURCE_READY) {
        const resolvedEntity = resolveIfExists(state, url);
        if (resolvedEntity) {
          return resolvedEntity;
        }
      }
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          return (async () => {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise(
                  (resolve, reject) => setTimeout(
                    () => {
                      didContinue = true;
                      reject();
                    },
                    waitTimeout * 60 * 1e3
                  )
                )
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
            }
          })();
        }
      }
    }
    vault.dispatch(requestResource({ id: url }));
    const importResource = (resource) => {
      if (!resource) {
        return void 0;
      }
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      vault.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    };
    try {
      const resourceOrPromise = fetcher(url, options);
      if (isPromise(resourceOrPromise)) {
        return (async () => {
          try {
            let data = await resourceOrPromise;
            if (mapper) {
              data = mapper(data);
            }
            return importResource(data);
          } catch (err) {
            vault.dispatch(requestError({ id: url, message: err.toString() }));
            throw err;
          }
        })();
      }
      return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);
    } catch (err) {
      vault.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

export {
  actionListFromResource,
  areInputsEqual,
  resolveIfExists,
  createFetchHelper
};
