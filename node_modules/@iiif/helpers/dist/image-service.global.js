"use strict";
var IIIFHelpers = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/image-service.ts
  var image_service_exports = {};
  __export(image_service_exports, {
    ImageServiceLoader: () => ImageServiceLoader,
    createImageServiceStore: () => createImageServiceStore,
    getCustomSizeFromService: () => getCustomSizeFromService,
    getFixedSizeFromImage: () => getFixedSizeFromImage,
    getFixedSizesFromService: () => getFixedSizesFromService,
    getImageCandidates: () => getImageCandidates,
    getImageCandidatesFromService: () => getImageCandidatesFromService,
    getImageFromTileSource: () => getImageFromTileSource,
    getImageServerFromId: () => getImageServerFromId,
    getSmallestScaleFactorAsSingleImage: () => getSmallestScaleFactorAsSingleImage,
    imageServices: () => imageServices,
    imageSizesMatch: () => imageSizesMatch,
    inferImageSizeFromUrl: () => inferImageSizeFromUrl,
    isBestMatch: () => isBestMatch,
    isImage3: () => isImage3,
    pickBestFromCandidates: () => pickBestFromCandidates,
    sampledTilesToTiles: () => sampledTilesToTiles
  });

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-J657UVVW.js
  var e = "http://library.stanford.edu/iiif/image-api/compliance.html#level0";
  var i = "http://library.stanford.edu/iiif/image-api/compliance.html#level1";
  var t = "http://library.stanford.edu/iiif/image-api/compliance.html#level2";
  var o = "http://library.stanford.edu/iiif/image-api/conformance.html#level0";
  var r = "http://library.stanford.edu/iiif/image-api/conformance.html#level1";
  var a = "http://library.stanford.edu/iiif/image-api/conformance.html#level2";
  var _ = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0";
  var I = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1";
  var l = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2";
  var p = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0";
  var s = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1";
  var n = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2";
  var E = "http://iiif.io/api/image/1/level0.json";
  var c = "http://iiif.io/api/image/1/profiles/level0.json";
  var F = "http://iiif.io/api/image/1/level1.json";
  var m = "http://iiif.io/api/image/1/profiles/level1.json";
  var f = "http://iiif.io/api/image/1/level2.json";
  var x = "http://iiif.io/api/image/1/profiles/level2.json";
  var A = "http://iiif.io/api/image/2/level0.json";
  var L = "http://iiif.io/api/image/2/profiles/level0.json";
  var h = "http://iiif.io/api/image/2/level1.json";
  var y = "http://iiif.io/api/image/2/profiles/level1.json";
  var d = "http://iiif.io/api/image/2/level2.json";
  var g = "http://iiif.io/api/image/2/profiles/level2.json";
  var M = "level0";
  var O = "level1";
  var v = "level2";
  var u = "http://iiif.io/api/image/2/level0";
  var N = "http://iiif.io/api/image/2/level1";
  var G = "http://iiif.io/api/image/2/level2";
  var R = [G, t, a, l, n, f, x, d, g, v];
  var C = [...R, N, i, r, I, s, F, m, h, y, O];
  var B = [u, N, G, e, i, t, o, r, a, _, I, l, p, s, n, E, c, F, m, f, x, A, L, h, y, d, g, M, O, v];
  var S = [u, e, o, _, p, E, c, A, L, M];
  var z = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["sizeByWhListed"] };
  var b = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPx", "regionSquare", "sizeByWhListed", "sizeByH", "sizeByW", "sizeByWh"] };
  var j = { extraFormats: ["jpg", "png"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPct", "regionByPx", "regionSquare", "rotationBy90s", "sizeByWhListed", "sizeByConfinedWh", "sizeByH", "sizeByPct", "sizeByW", "sizeByWh"] };

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/image-3.js
  function A2(i2) {
    try {
      if (i2 === "full")
        return { full: true };
      if (i2 === "square")
        return { square: true };
      let e2 = i2.startsWith("pct:"), o2 = i2.substr(e2 ? 4 : 0).split(",").map((r2) => parseFloat(r2));
      return { x: o2[0], y: o2[1], w: o2[2], h: o2[3], percent: e2 };
    } catch {
      throw new Error("Expected 'full', 'square' or 'x,y,w,h'. Found " + i2);
    }
  }
  function P2(i2) {
    let e2 = { upscaled: false, max: false, confined: false };
    if (i2[0] === "^" && (e2.upscaled = true, i2 = i2.slice(1)), i2 === "max" || i2 === "full")
      return e2.max = true, e2.serialiseAsFull = i2 === "full", e2;
    if (i2[0] === "!" && (e2.confined = true, i2 = i2.slice(1)), i2[0] === "p")
      return e2.percentScale = parseFloat(i2.slice(4)), e2;
    let t2 = i2.split(",").map((o2) => o2.trim());
    return t2.length && (t2[0] !== "" && (e2.width = parseInt(t2[0], 10)), t2[1] !== "" && (e2.height = parseInt(t2[1], 10))), e2;
  }
  function $(i2) {
    let e2 = { angle: 0 };
    if (i2[0] === "!" && (e2.mirror = true, i2 = i2.substr(1)), e2.angle = parseFloat(i2) % 360, Number.isNaN(e2.angle))
      throw new Error(`Invalid rotation ${i2}`);
    return e2;
  }
  function R2(i2, e2 = "") {
    let t2 = i2.match(/^(([a-zA-Z]+):\/\/([^/]+))?((.*)+)/);
    if (!t2)
      throw new Error(`Invalid or unknown input ${i2}`);
    let o2 = t2[2], r2 = t2[3], a2 = t2[4];
    if (a2[0] === "/" && (a2 = a2.substring(1)), e2.length > 0) {
      if (e2[0] === "/" && (e2 = e2.substring(1)), e2 !== a2.substring(0, e2.length))
        throw new Error(`Path does not start with prefix (path: ${a2}, prefix: ${e2})`);
      a2 = a2.substring(e2.length);
    }
    return { scheme: o2, server: r2, path: a2, prefix: e2 };
  }
  function O2(i2, e2 = "") {
    let { path: t2, scheme: o2, server: r2, prefix: a2 } = R2(i2, e2), n2 = t2.split("/").reverse(), [s2, f2, p2, l2, ...y2] = n2, x2 = y2.reverse().filter(Boolean).join("/");
    if (n2.length === 1 || s2 === "")
      return { type: "base", scheme: o2, server: r2, prefix: a2, identifier: x2 };
    if (s2 === "info.json") {
      let [, ...E2] = n2;
      return { type: "info", scheme: o2, server: r2, prefix: a2, identifier: E2.reverse().filter(Boolean).join("/") };
    }
    if (typeof o2 > "u" || typeof r2 > "u" || typeof t2 > "u" || typeof l2 > "u" || typeof p2 > "u" || typeof f2 > "u" || typeof s2 > "u")
      throw new Error("Invalid image service URL");
    let [M2 = "", T = ""] = s2.split(".");
    return { type: "image", scheme: o2, server: r2, prefix: a2, identifier: x2, originalPath: t2, region: A2(l2), size: P2(p2), rotation: $(f2), quality: M2, format: T };
  }
  function b2(i2) {
    return R.indexOf(i2) !== -1 ? j : C.indexOf(i2) !== -1 ? b : z;
  }
  function h2(i2) {
    let e2 = i2 ? Array.isArray(i2.profile) ? i2.profile : [i2.profile] : [], t2 = { extraQualities: [], extraFormats: [], extraFeatures: [] };
    for (let o2 of e2)
      if (typeof o2 == "string" && (o2 = b2(o2)), !!o2) {
        if (o2.formats)
          for (let r2 of o2.formats)
            t2.extraFormats.indexOf(r2) === -1 && t2.extraFormats.push(r2);
        if (o2.qualities)
          for (let r2 of o2.qualities)
            t2.extraQualities.indexOf(r2) === -1 && t2.extraQualities.push(r2);
        if (o2.supports)
          for (let r2 of o2.supports)
            t2.extraFeatures.indexOf(r2) === -1 && t2.extraFeatures.push(r2);
        if (o2.maxHeight && (t2.maxHeight = o2.maxHeight), o2.maxWidth && (t2.maxWidth = o2.maxWidth), o2.maxArea && (t2.maxArea = o2.maxArea), o2.extraFormats)
          for (let r2 of o2.extraFormats)
            t2.extraFormats.indexOf(r2) === -1 && t2.extraFormats.push(r2);
        if (o2.extraQualities)
          for (let r2 of o2.extraQualities)
            t2.extraQualities.indexOf(r2) === -1 && t2.extraQualities.push(r2);
        if (o2.extraFeatures)
          for (let r2 of o2.extraFeatures)
            t2.extraFeatures.indexOf(r2) === -1 && t2.extraFeatures.push(r2);
        o2.maxHeight && (t2.maxHeight = o2.maxHeight), o2.maxWidth && (t2.maxWidth = o2.maxWidth), o2.maxArea && (t2.maxArea = o2.maxArea);
      }
    if (i2.extraFormats)
      for (let o2 of i2.extraFormats)
        t2.extraFormats.indexOf(o2) === -1 && t2.extraFormats.push(o2);
    if (i2.extraFeatures)
      for (let o2 of i2.extraFeatures)
        t2.extraFeatures.indexOf(o2) === -1 && t2.extraFeatures.push(o2);
    if (i2.extraQualities)
      for (let o2 of i2.extraQualities)
        t2.extraQualities.indexOf(o2) === -1 && t2.extraQualities.push(o2);
    return t2;
  }
  function Qe(i2) {
    let e2 = Array.isArray(i2.profile) ? i2.profile : [i2.profile];
    for (let t2 of e2)
      if (typeof t2 == "string" && S.indexOf(t2) !== -1)
        return true;
    return false;
  }
  function W(i2) {
    if (i2["@id"])
      return i2["@id"];
    if (i2.id)
      return i2.id;
  }
  function m2(i2) {
    if (!i2 || !i2.profile || !W(i2))
      return false;
    let e2 = Array.isArray(i2.profile) ? i2.profile : [i2.profile];
    for (let t2 of e2)
      if (typeof t2 == "string" && B.indexOf(t2) !== -1)
        return true;
    return false;
  }
  function Ke(i2) {
    if (!m2(i2))
      return false;
    let e2 = Array.isArray(i2.profile) ? i2.profile : [i2.profile];
    for (let t2 of e2)
      if (typeof t2 == "string") {
        if (C.indexOf(t2) !== -1)
          return true;
      } else {
        let o2 = [...t2.supports || [], ...t2.extraFeatures || []];
        if (o2.indexOf("regionByPx") !== -1 && (o2.indexOf("sizeByW") !== -1 || o2.indexOf("sizeByWh") !== -1))
          return true;
      }
    return false;
  }
  function B2({ x: i2 = 0, y: e2 = 0, w: t2, h: o2, full: r2, square: a2, percent: n2 }) {
    if (r2)
      return "full";
    if (a2)
      return "square";
    if (typeof t2 > "u" || typeof o2 > "u")
      throw new Error("RegionParameter: invalid region");
    let s2 = `${i2},${e2},${t2},${o2}`;
    return n2 ? `pct:${s2}` : s2;
  }
  function j2({ max: i2, percentScale: e2, upscaled: t2, confined: o2, width: r2, height: a2, serialiseAsFull: n2, version: s2 }) {
    let f2 = [];
    return t2 && f2.push("^"), i2 ? (f2.push(n2 ? "full" : "max"), f2.join("")) : (o2 && f2.push("!"), e2 && f2.push(`pct:${e2}`), r2 && f2.push(`${r2}`), f2.push(","), a2 && s2 === 3 && f2.push(`${a2}`), f2.join(""));
  }
  function Q(i2) {
    return `${i2.mirror ? "!" : ""}${(i2.angle || 0) % 360}`;
  }
  function H(i2, e2) {
    let t2 = i2.prefix.startsWith("/") ? i2.prefix.substring(1) : i2.prefix, o2 = `${i2.scheme}://${i2.server}/${t2 ? `${t2}/` : ""}${i2.identifier}`;
    if (i2.type === "base")
      return o2;
    if (i2.type === "info")
      return `${o2}/info.json`;
    let { size: r2 } = i2, { region: a2, rotation: n2, format: s2, quality: f2 } = i2;
    if (e2) {
      let p2 = e2["@context"] ? Array.isArray(e2["@context"]) ? e2["@context"] : [e2["@context"]] : [], l2 = p2.indexOf("http://iiif.io/api/image/2/context.json") !== -1, y2 = p2.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
      if ((r2.width === e2.width && !r2.height || r2.height === e2.height && !r2.width || r2.width === e2.width && r2.height === e2.height) && (r2 = { ...r2, max: true }), l2 && (r2.max && !r2.serialiseAsFull && (r2 = { ...r2, serialiseAsFull: true }), !r2.max && r2.width && r2.height && (r2 = { ...r2, height: void 0 }), r2 = { ...r2, version: 2 }), y2) {
        if (r2.max && r2.serialiseAsFull && (r2 = { ...r2, serialiseAsFull: false }), r2.width && !r2.height && e2.width && e2.height) {
          let x2 = e2.height / e2.width;
          r2 = { ...r2, height: Math.ceil(r2.width * x2) };
        }
        r2 = { ...r2, version: 3 };
      }
    }
    return [o2, B2(a2), j2(r2), Q(n2), `${f2}.${s2}`].filter(Boolean).join("/");
  }
  function L2(i2) {
    return i2.endsWith("info.json") ? i2 : i2.endsWith("/") ? `${i2}info.json` : `${i2}/info.json`;
  }
  function hi(i2) {
    let e2 = O2(L2(i2.id));
    if (e2.type !== "info")
      throw new Error("Invalid service URL");
    let t2 = h2(i2);
    return { identifier: e2.identifier, originalPath: "", server: e2.server, prefix: e2.prefix, scheme: e2.scheme, type: "image", quality: t2.extraQualities.indexOf("default") === -1 ? t2.extraQualities[0] : "default", region: { full: true }, size: { max: true, upscaled: false, confined: false }, format: "jpg", rotation: { angle: 0 } };
  }
  function Si(i2, e2, t2) {
    let o2 = t2.length, r2 = [];
    for (let a2 = 0; a2 < o2; a2++) {
      let n2 = t2[a2];
      if (!n2)
        continue;
      let s2 = n2.width;
      r2.push(i2 / s2);
    }
    return r2;
  }
  function zi(i2, e2, t2) {
    let o2 = t2.length, r2 = [];
    for (let a2 = 0; a2 < o2; a2++) {
      let n2 = t2[a2];
      n2 && r2.push({ width: Math.floor(i2 / n2), height: Math.floor(e2 / n2) });
    }
    return r2;
  }
  function S2(i2, e2) {
    if (e2 && e2.profile) {
      let t2 = e2.profile;
      if (t2) {
        let o2 = Array.isArray(t2) ? t2 : [t2];
        if (o2.includes(`level${i2}`) || o2.includes(`http://iiif.io/api/image/2/level${i2}.json`) || o2.includes(`http://iiif.io/api/image/1/level${i2}.json`) || o2.includes(`http://iiif.io/api/image/1/profiles/level${i2}.json`))
          return true;
        if (i2 === 2) {
          for (let r2 of o2)
            if (R.includes(r2))
              return true;
        }
        if (i2 === 1) {
          for (let r2 of o2)
            if (C.includes(r2))
              return true;
        }
        if (i2 === 0) {
          for (let r2 of o2)
            if (S.includes(r2))
              return true;
        }
      }
    }
    return false;
  }
  function Pi(i2) {
    return m2(i2) ? S2(0, i2) ? 0 : S2(1, i2) ? 1 : S2(2, i2) ? 2 : null : null;
  }
  function Oi(i2) {
    let e2 = i2.service ? Array.isArray(i2.service) ? i2.service : [i2.service] : [], t2 = e2.length, o2 = [];
    for (let r2 = 0; r2 < t2; r2++)
      m2(e2[r2]) && o2.push(e2[r2]);
    return o2;
  }
  function Wi(i2) {
    if (i2["@type"])
      return i2["@type"];
    if (i2.type)
      return i2.type;
  }

  // src/image-service/get-image-server-from-id.ts
  function getImageServerFromId(url) {
    const id = url.replace(/(https?:\/\/)?(www.)?/i, "");
    if (id.indexOf("/") !== -1) {
      return id.split("/")[0];
    }
    return id;
  }

  // src/image-service/sampled-tiles-to-tiles.ts
  function sampledTilesToTiles(width, height, sampledTiles) {
    const maxDim = width > height ? width : height;
    const len = sampledTiles.length;
    const newTiles = [];
    for (let i2 = 0; i2 < len; i2++) {
      const tile = sampledTiles[i2];
      if (!tile)
        continue;
      if (tile.scaleFactors.length === 0)
        continue;
      let lastSize = tile.scaleFactors[0];
      if (!lastSize)
        continue;
      let curWidth = maxDim / lastSize;
      const scaleFactors = [lastSize];
      while (curWidth >= tile.width) {
        lastSize = lastSize * 2;
        scaleFactors.push(lastSize);
        curWidth = curWidth / 2;
      }
      newTiles.push({
        ...tile,
        scaleFactors
      });
    }
    return newTiles;
  }

  // src/image-service/get-image-from-tile-source.ts
  function getImageFromTileSource(image, targetWidth, targetHeight) {
    const req = hi({
      "@context": image.version === 3 ? "http://iiif.io/api/image/3/context.json" : "http://iiif.io/api/image/2/context.json",
      id: L2(W(image)),
      profile: image.level === null || typeof image.level === "undefined" ? "level0" : `level${image.level}`,
      type: image.version === 3 ? "ImageService3" : "ImageService2"
    });
    if (req.type !== "image") {
      throw new Error("Invalid service");
    }
    req.size.max = false;
    req.size.width = targetWidth;
    req.size.height = targetHeight;
    const url = H(req);
    return {
      id: url,
      type: "fixed",
      width: targetWidth,
      height: targetHeight || image.height / (image.width || 1) * targetWidth,
      unsafe: image.width > targetWidth
    };
  }

  // src/image-service/is-best-match.ts
  function isBestMatch(request, current, candidate) {
    const width = !request.width ? request.maxWidth : request.width;
    return candidate.height <= request.maxHeight && candidate.width <= request.maxWidth && candidate.height >= request.minHeight && candidate.width >= request.minWidth && (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width));
  }

  // src/image-service/pick-best-from-candidates.ts
  function pickBestFromCandidates(inputRequest, candidates) {
    const log = [];
    const request = Object.assign(
      {
        unsafeImageService: false,
        atAnyCost: true,
        fallback: true,
        minHeight: 64,
        minWidth: 64,
        maxHeight: Infinity,
        maxWidth: Infinity,
        returnAllOptions: false,
        preferFixedSize: false,
        allowUnsafe: false,
        explain: false,
        height: 0,
        width: 0
      },
      inputRequest
    );
    const explain = (text, indent = 0) => request.explain ? log.push(
      new Array(indent).fill(0).map((e2) => "    ").join("") + text().trim()
    ) : void 0;
    const lastResorts = [];
    const fallback = [];
    let currentChoice = null;
    explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);
    const swapChoice = (candidate, current) => {
      explain(() => "Swapping choice", 3);
      if (isBestMatch(request, current, candidate)) {
        if (request.preferFixedSize && candidate.unsafe) {
          explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);
          fallback.push(candidate);
          return;
        }
        if (request.returnAllOptions && current) {
          fallback.push(current);
        }
        explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);
        currentChoice = candidate;
      } else if (request.returnAllOptions) {
        fallback.push(candidate);
      }
    };
    explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);
    const candidateGroups = candidates.length;
    for (let x2 = 0; x2 < candidateGroups; x2++) {
      const group = candidates[x2]();
      explain(() => `Candidate group ${x2}: ${JSON.stringify(group, null, 2)}`, 1);
      const candidatesLength = group.length;
      explain(
        () => `Checking candidate list number ${x2} and found ${candidatesLength} potential ways of creating image(s)`,
        1
      );
      for (let y2 = 0; y2 < candidatesLength; y2++) {
        const candidate = group[y2];
        explain(() => `-> Checking candidate ${y2}`, 1);
        if (candidate.type === "unknown" && request.atAnyCost) {
          explain(() => `We've found an unknown image type, adding this to the "last resort" list`, 2);
          lastResorts.push(candidate);
        }
        if (candidate.type === "fixed") {
          if (candidate.unsafe) {
            explain(() => `We've found an unsafe fixed image type, adding this to the "last resort" list`, 2);
            lastResorts.push(candidate);
          } else {
            explain(() => `We've found a fixed size image, checking if it matches the request`, 2);
            swapChoice(candidate, currentChoice);
          }
        }
        if (candidate.type === "fixed-service") {
          if (request.unsafeImageService) {
            explain(
              () => `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,
              2
            );
            const choice = getImageFromTileSource(candidate, request.width, request.height);
            swapChoice(choice, currentChoice);
          } else {
            explain(() => `Checking for an image from the tile source 3`, 2);
            const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);
            swapChoice(choice, currentChoice);
          }
        }
        if (candidate.type === "variable") {
          if (candidate.maxWidth) {
            const choice = getImageFromTileSource(
              {
                id: candidate.id,
                type: "fixed-service",
                width: candidate.maxWidth,
                height: candidate.maxWidth,
                level: candidate.level,
                version: candidate.version
              },
              candidate.maxWidth
            );
            swapChoice(choice, currentChoice);
          }
        }
      }
      if (currentChoice && !request.returnAllOptions) {
        if (currentChoice.unsafe || request.allowUnsafe) {
          continue;
        }
        explain(() => `We found a match in choice list number ${x2}, no searching any more`);
        break;
      }
    }
    if (request.atAnyCost && fallback.length === 0) {
      explain(
        () => currentChoice ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}` : `We found no images, but "atAnyCost" is set, so returning that`
      );
      return {
        best: currentChoice || lastResorts[0] || null,
        fallback: lastResorts.slice(1),
        log
      };
    }
    if (request.returnAllOptions) {
      explain(() => `Returning all options that we have found`);
      return {
        best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,
        fallback: [...fallback, ...lastResorts],
        log
      };
    }
    explain(() => `Returning the best image that we found, and a fallback`);
    return {
      best: currentChoice || fallback[0] || null,
      fallback: currentChoice ? fallback : fallback.slice(1),
      log
    };
  }

  // src/image-service/is-image-3.ts
  function isImage3(service) {
    const context = service["@context"] ? Array.isArray(service["@context"]) ? service["@context"] : [service["@context"]] : [];
    return context.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
  }

  // src/image-service/get-fixed-sizes-from-service.ts
  function getFixedSizesFromService(service) {
    if (!m2(service)) {
      return [];
    }
    return (service && service.sizes ? service.sizes : []).map((size) => {
      return {
        id: W(service),
        type: "fixed-service",
        height: size.height,
        width: size.width,
        level: Pi(service),
        version: isImage3(service) ? 3 : 2
      };
    });
  }

  // src/image-service/get-custom-size-from-service.ts
  function getCustomSizeFromService(service) {
    if (!Ke(service)) {
      return [];
    }
    const imagesSizes = [];
    const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];
    const pLen = profiles.length;
    for (let x2 = 0; x2 < pLen; x2++) {
      const profile = profiles[x2];
      if (profile && typeof profile !== "string") {
        if (profile.maxHeight || profile.maxWidth) {
          return [
            {
              id: W(service),
              type: "variable",
              minWidth: 0,
              minHeight: 0,
              maxHeight: profile.maxHeight || profile.maxWidth,
              maxWidth: profile.maxWidth || profile.maxHeight,
              level: Pi(service),
              version: service["@context"] === "http://iiif.io/api/image/3/context.json" ? 3 : 2
            }
          ];
        }
      }
    }
    if (service.tiles) {
      const len = service.tiles.length;
      for (let y2 = 0; y2 < len; y2++) {
        const tile = service.tiles[y2];
        if (tile && (tile.height || tile.width)) {
          imagesSizes.push({
            id: W(service),
            type: "variable",
            minHeight: 0,
            minWidth: 0,
            maxHeight: tile.height || tile.width,
            maxWidth: tile.width,
            level: Pi(service),
            version: isImage3(service) ? 3 : 2
          });
        }
      }
    }
    return imagesSizes;
  }

  // src/image-service/get-image-candidates-from-service.ts
  function getImageCandidatesFromService(service) {
    const candidates = [];
    const totalServices = service.length;
    for (let s2 = 0; s2 < totalServices; s2++) {
      const single = service[s2];
      if (!single)
        continue;
      const fixedSizes = getFixedSizesFromService(single);
      if (fixedSizes.length) {
        candidates.push(...fixedSizes);
      }
      const customSizes = getCustomSizeFromService(single);
      if (customSizes.length) {
        candidates.push(...customSizes);
      }
    }
    return candidates;
  }

  // src/image-service/infer-size-from-url.ts
  function inferImageSizeFromUrl(image) {
    const regex = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/;
    const match = image.match(regex);
    if (match && match[4] && match[5]) {
      const region = match[1];
      const width = parseInt(match[4], 10);
      const height = parseInt(match[5], 10);
      const format = match[7];
      if ((region === "max" || region === "full") && width && height && format) {
        return {
          type: "fixed",
          id: image,
          height,
          width
        };
      }
    }
    return { type: "unknown", id: image };
  }

  // src/image-service/get-fixed-size-from-image.ts
  function getFixedSizeFromImage(contentResource) {
    if (typeof contentResource === "string") {
      return inferImageSizeFromUrl(contentResource);
    }
    const type = Wi(contentResource);
    if (type !== "Image" && type !== "sc:Image") {
      return null;
    }
    const image = contentResource;
    const id = W(image);
    if (!id) {
      return null;
    }
    if (id && image.width && image.height) {
      return {
        id,
        type: "fixed",
        width: image.width,
        height: image.height,
        unsafe: true
      };
    }
    return inferImageSizeFromUrl(id);
  }

  // src/image-service/get-image-candidates.ts
  function getImageCandidates(unknownResource, dereference = true, loader) {
    const candidates = [];
    const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);
    if (fixedSizeFromImage === null) {
      return candidates;
    }
    const resource = unknownResource;
    candidates.push(fixedSizeFromImage);
    if (dereference && resource && resource.width && resource.height) {
      const refCandidates = [];
      const imageServices2 = Oi(resource);
      for (const service of imageServices2) {
        const request = {
          id: W(service),
          width: resource.width,
          height: resource.height
        };
        if (loader.canLoadSync(request)) {
          const externalService = loader.loadServiceSync(request);
          if (externalService) {
            if (!externalService.height) {
              externalService.height = resource.height;
            }
            if (!externalService.width) {
              externalService.width = resource.width;
            }
            refCandidates.push(...getImageCandidatesFromService([externalService]));
          }
        }
      }
      if (refCandidates.length) {
        candidates.push(...refCandidates);
        return candidates;
      }
    }
    if (resource.service) {
      candidates.push(...getImageCandidatesFromService(resource.service));
    }
    return candidates;
  }

  // src/image-service/image-sizes-match.ts
  function imageSizesMatch(sizesA, sizesB) {
    if (sizesA.length !== sizesB.length) {
      return false;
    }
    if (sizesA.length === 0 && sizesB.length === 0) {
      return true;
    }
    const len = sizesA.length;
    let matchOrder = true;
    for (let i2 = 0; i2 < len; i2++) {
      const a2 = sizesA[i2];
      const b3 = sizesB[i2];
      if (a2.width !== b3.width || a2.height !== b3.height) {
        matchOrder = false;
        break;
      }
    }
    if (matchOrder) {
      return true;
    }
    let matching = 0;
    for (let a2 = 0; a2 < len; a2++) {
      for (let b3 = 0; b3 < len; b3++) {
        if (sizesA[a2].width === sizesB[b3].width && sizesA[a2].height === sizesB[b3].height) {
          matching++;
          break;
        }
      }
    }
    return matching === len;
  }

  // src/image-service/image-service-loader.ts
  var ImageServiceLoader = class {
    constructor(options = {}) {
      __publicField(this, "config", {
        verificationsRequired: 1,
        approximateServices: false,
        enableFetching: true,
        disableThrottling: false
      });
      __publicField(this, "fetchingCount", 0);
      __publicField(this, "imageServices", {});
      __publicField(this, "knownImageServers", {});
      this.config = Object.assign(this.config, options);
    }
    /**
     * Preload image service
     *
     * This will preload an image service, fetching details and recording the image server that served
     * the request. Based on this it will make a template for predicting other image sources from this
     * server. You can optionally pass in other ids to verify that the prediction is accurate.
     *
     */
    // async preload(id: string, verify?: string[]): Promise<void> {}
    setConfig(config) {
      Object.assign(this.config, config);
    }
    /**
     * Sample pre-fetched service
     *
     * If you have already fetched an image service, or are creating a viewer that only talks to a single
     * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
     * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
     *
     * @param service
     * @param preLoaded Mark this as being pre-loaded (default: true)
     */
    sample(service, imageServiceRequest, preLoaded = true) {
      const server = getImageServerFromId(W(service));
      const serviceUrl = L2(W(service));
      const existing = this.knownImageServers[server];
      this.imageServices[serviceUrl] = Object.assign(service, { real: true });
      if (!existing && service.tiles && !Qe(service)) {
        this.knownImageServers[server] = {
          verifications: 0,
          malformed: false,
          root: server,
          preLoaded,
          sampledId: W(service),
          verified: false,
          server: null,
          result: {
            context: service["@context"] || [],
            sampledProfile: service.profile,
            resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,
            sampledSizes: service.sizes || [],
            sizeRatios: Si(service.width, service.height, service.sizes || []),
            sampledTiles: service.tiles || []
          }
        };
        return true;
      }
      return this.verify(service);
    }
    /**
     * Preload an image server
     *
     * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
     * allowing you to correct mistakes this implementation might have made.
     *
     * @param server
     * @param forceVerify
     */
    preLoad(server, forceVerify = true) {
      this.knownImageServers[server.root] = server;
      if (forceVerify) {
        this.knownImageServers[server.root].malformed = false;
        this.knownImageServers[server.root].verifications = this.config.verificationsRequired;
      }
    }
    /**
     * Predict
     *
     * Predicts what the image service will be for a content resource.
     *
     * @param resource
     * @param verify
     * @param force
     */
    predict(resource, verify = false, force = false) {
      const source = resource?.source;
      const serverId = getImageServerFromId(W(resource));
      const imageServer = this.knownImageServers[serverId];
      const serviceUrl = L2(W(resource));
      if (this.imageServices[serviceUrl]) {
        return this.imageServices[serviceUrl] || null;
      }
      if (!this.config.approximateServices) {
        return null;
      }
      if (!imageServer || !imageServer.result || !(source?.height || resource.height) || !(source?.width || resource.width) || !force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired) || resource.source && Qe(resource.source)) {
        return null;
      }
      if (!this.imageServices[serviceUrl]) {
        this.imageServices[serviceUrl] = {
          "@context": imageServer.result.context,
          "@id": W(resource),
          id: W(resource),
          protocol: "http://iiif.io/api/image",
          tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),
          sizes: source?.sizes || zi(
            Math.round(resource.width / imageServer.result.resourceServiceRatio),
            Math.round(resource.height / imageServer.result.resourceServiceRatio),
            imageServer.result.sizeRatios
          ),
          profile: source?.profile || imageServer.result.sampledProfile,
          height: source?.height || resource.height,
          width: source?.width || resource.width,
          real: false
        };
      }
      return this.imageServices[serviceUrl] || null;
    }
    async getThumbnailFromResource(unknownResource, request, dereference = true, otherCandidates = []) {
      const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];
      return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);
    }
    async getImageCandidates(unknownResource, dereference = true) {
      const resource = unknownResource;
      if (dereference && resource && resource.height && resource.width) {
        const imageServices2 = Oi(resource);
        for (const service of imageServices2) {
          const request = {
            id: W(service),
            width: service.width ? service.width : resource.width,
            height: service.height ? service.height : resource.height,
            source: service
          };
          await this.loadService(request);
        }
      }
      return getImageCandidates(unknownResource, dereference, this);
    }
    /**
     * Verify approximation
     *
     * Given an image service, it will dereference that image service and compare the result with what
     * would have been generated if we used internal guessing.
     *
     * @param resource
     * @return Promise<boolean>
     */
    async verify(resource) {
      const prediction = this.predict(resource, false, true);
      const imageService = await this.fetchService(W(resource));
      if (!prediction) {
        return false;
      }
      const isValid = prediction.height === imageService.height && prediction.width === imageService.width && prediction["@context"] === imageService["@context"] && imageSizesMatch(prediction.sizes || [], imageService.sizes || []);
      if (isValid) {
        const serverId = getImageServerFromId(W(resource));
        const server = this.knownImageServers[serverId];
        if (server) {
          server.verifications += 1;
          if (server.verifications >= this.config.verificationsRequired) {
            server.verified = true;
          }
        }
      }
      return isValid;
    }
    canLoadSync(service) {
      const serviceId = typeof service === "string" ? service : W(service);
      const canonical = L2(serviceId);
      if (this.imageServices[canonical]) {
        return true;
      }
      const server = this.knownImageServers[getImageServerFromId(serviceId)];
      return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);
    }
    /**
     * Mark image service as malformed
     *
     * If you run into issues requesting images, you can mark an image service as malformed, and it will
     * return you a new one. Future image services will also be requested fresh, and the system will have
     * failed. Report a bug if this happens.
     *
     * @param resource
     */
    async markAsMalformed(resource) {
      this.knownImageServers[getImageServerFromId(W(resource))].malformed = true;
      return this.loadService(resource, true);
    }
    /**
     * Fetch an image service (use loadService instead)
     *
     * @param serviceId
     * @param forceFresh
     */
    async fetchService(serviceId, forceFresh = false) {
      const serviceUrl = L2(serviceId);
      const service = this.imageServices[serviceUrl];
      if (service && (!forceFresh || service.real)) {
        return service;
      }
      if (!this.config.enableFetching) {
        throw new Error("Fetching is not enabled");
      }
      const json = await this.fetch(serviceUrl).then((service2) => service2.json());
      if (!json.id && json["@id"]) {
        json.id = json["@id"];
      }
      if (json.id !== serviceId) {
        json.id = serviceId;
        if (json["@id"]) {
          json["@id"] = serviceId;
        }
      }
      this.imageServices[serviceUrl] = Object.assign(json, { real: true });
      return this.imageServices[serviceUrl];
    }
    async fetch(input, init) {
      return fetch(input, init);
    }
    /**
     * Load an image service
     *
     * @param resource
     * @param forceFresh
     *
     * @todo make this batched, so only the maximum required can be done at once, to allow
     *       for the prediction engine to kick in.
     */
    async loadService(resource, forceFresh = false) {
      if (!this.config.disableThrottling) {
        let running = true;
        while (running) {
          if (this.fetchingCount >= this.config.verificationsRequired) {
            await new Promise((resolve) => setTimeout(resolve, 500));
          } else {
            running = false;
            break;
          }
        }
      }
      const imageServer = this.knownImageServers[getImageServerFromId(W(resource))];
      if (imageServer && !imageServer.malformed && !forceFresh) {
        await imageServer.result;
        const service = this.loadServiceSync(resource);
        if (service) {
          return service;
        }
      }
      this.fetchingCount++;
      const serviceJson = await this.fetchService(W(resource), forceFresh);
      this.fetchingCount--;
      if (serviceJson.real) {
        this.sample(serviceJson, resource);
      }
      return serviceJson;
    }
    /**
     * Load service synchronously
     *
     * If you know that the image service you are
     * @param resource
     */
    loadServiceSync(resource) {
      const serviceId = L2(W(resource));
      if (this.imageServices[serviceId]) {
        return this.imageServices[serviceId];
      }
      if (!this.config.approximateServices) {
        return null;
      }
      return this.predict(resource);
    }
  };

  // node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
  function mitt_default(n2) {
    return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 ? i2.push(e2) : n2.set(t2, [e2]);
    }, off: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));
    }, emit: function(t2, e2) {
      var i2 = n2.get(t2);
      i2 && i2.slice().map(function(n3) {
        n3(e2);
      }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
        n3(t2, e2);
      });
    } };
  }

  // src/image-service/image-service-store.ts
  function createImageServiceStore(options = {}) {
    const events = options.events || mitt_default();
    const loader = options.loader || new ImageServiceLoader();
    const store = createStore((set, get) => ({
      loaded: {},
      loadServiceSync: (service, detail, backgroundRequest) => {
        const id = service.id || service["@id"];
        const existing = get().loaded[id];
        if (existing && existing.status === "done") {
          return existing.service;
        }
        if (existing && existing.status === "loading") {
          return null;
        }
        if (existing && existing.status === "error") {
          throw new Error("Failed to load image service");
        }
        const request = {
          id: W(service),
          width: service.width || detail?.width || 0,
          height: service.height || detail?.height || 0,
          source: service
        };
        const loaded = loader.loadServiceSync(request);
        if (loaded) {
          set((state) => ({
            loaded: {
              ...state.loaded,
              [id]: {
                status: "done",
                service: loaded,
                real: true
              }
            }
          }));
          events.emit("image-service.loaded", { id, service: loaded });
        } else {
          if (backgroundRequest) {
            get().loadService(service, detail).then(() => {
            });
          }
        }
        return loaded;
      },
      loadService: async (service, detail) => {
        const id = service.id || service["@id"];
        const existing = get().loaded[id];
        if (existing && existing.status === "done") {
          return existing.service;
        }
        if (existing && existing.status === "loading") {
          return new Promise((resolve, reject) => {
            const handler = (e2) => {
              if (e2.id === id) {
                events.off("image-service.loaded", handler);
                resolve(e2.service || service);
              }
            };
            events.on("image-service.loaded", handler);
          });
        }
        if (existing && existing.status === "error" && !detail?.force) {
          throw new Error("Failed to load image service");
        }
        events.emit("image-service.loading", { id });
        try {
          const request = {
            id: W(service),
            width: service.width || 0,
            height: service.height || 0,
            source: service
          };
          const loaded = await loader.loadService(request, detail?.force);
          set((state) => ({
            loaded: {
              ...state.loaded,
              [id]: {
                status: "done",
                service: loaded,
                real: loaded.real
              }
            }
          }));
          events.emit("image-service.loaded", { id, service: loaded });
          return loaded;
        } catch (error) {
          events.emit("image-service.error", { id, error });
          throw error;
        }
      }
    }));
    return {
      store,
      events
    };
  }
  var imageServices = createImageServiceStore();

  // src/image-service/get-smallest-scale-factor-as-single-image.ts
  function getSmallestScaleFactorAsSingleImage(service) {
    if (!service.width || !service.height) {
      return null;
    }
    if (service.tiles) {
      const tiles = service.tiles.sort((a2, b3) => {
        return Math.max(...b3.scaleFactors) - Math.max(...a2.scaleFactors);
      });
      const len = tiles.length;
      for (let i2 = 0; i2 < len; i2++) {
        const tile = tiles[i2];
        if (!tile)
          continue;
        const targetSize = tile.width;
        if (!targetSize) {
          continue;
        }
        const sizeLen = tile.scaleFactors.length;
        const sortedScales = tile.scaleFactors.sort();
        for (let j3 = 0; j3 < sizeLen; j3++) {
          const size = sortedScales[j3];
          if (!size)
            continue;
          if (service.width / size <= targetSize && service.height / size <= targetSize) {
            return {
              id: W(service),
              type: "fixed-service",
              width: service.width / size | 0,
              height: service.height / size | 0,
              level: Pi(service),
              version: isImage3(service) ? 3 : 2
            };
          }
        }
      }
    }
    return null;
  }
  return __toCommonJS(image_service_exports);
})();
