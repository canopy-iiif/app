"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/vault-node.ts
var vault_node_exports = {};
__export(vault_node_exports, {
  Vault: () => Vault2,
  globalVault: () => globalVault
});
module.exports = __toCommonJS(vault_node_exports);

// src/vault/vault.ts
var import_parser3 = require("@iiif/parser");

// src/vault/utility/typesafe-actions-runtime.ts
var createAction = function createAction2(type) {
  return function() {
    const base = { type, getType: () => type, toString: () => type };
    return (payload2, meta) => ({
      ...base,
      ...payload2 !== void 0 && { payload: payload2 },
      ...meta !== void 0 && { meta }
    });
  };
};

// src/vault/actions/entity-actions.ts
var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
var UPDATE_REFERENCE = "@iiif/UPDATE_REFERENCE";
var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
var ADD_METADATA = "@iiif/ADD_METADATA";
var REMOVE_METADATA = "@iiif/REMOVE_METADATA";
var UPDATE_METADATA = "@iiif/UPDATE_METADATA";
var REORDER_METADATA = "@iiif/REORDER_METADATA";
var importEntities = createAction(IMPORT_ENTITIES)();
var modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
var reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
var addReference = createAction(ADD_REFERENCE)();
var removeReference = createAction(REMOVE_REFERENCE)();
var updateReference = createAction(UPDATE_REFERENCE)();
var addMetadata = createAction(ADD_METADATA)();
var updateMetadata = createAction(UPDATE_METADATA)();
var removeMetadata = createAction(REMOVE_METADATA)();
var reorderMetadata = createAction(REORDER_METADATA)();
var entityActions = {
  importEntities,
  modifyEntityField,
  reorderEntityField,
  addReference,
  removeReference,
  updateReference,
  addMetadata,
  removeMetadata,
  updateMetadata,
  reorderMetadata
};

// src/vault/actions/mapping-actions.ts
var ADD_MAPPING = "@iiif/ADD_MAPPING";
var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
var addMapping = createAction(ADD_MAPPING)();
var addMappings = createAction(ADD_MAPPINGS)();

// src/vault/actions/meta-actions.ts
var SET_META_VALUE = "@iiif/SET_META_VALUE";
var SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
var UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
var setMetaValue = createAction(SET_META_VALUE)();
var setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)();
var unsetMetaValue = createAction(UNSET_META_VALUE)();
var metaActions = {
  setMetaValue,
  setMetaValueDynamic,
  unsetMetaValue
};

// src/vault/actions/request-actions.ts
var RESOURCE_ERROR = "RESOURCE_ERROR";
var RESOURCE_LOADING = "RESOURCE_LOADING";
var RESOURCE_READY = "RESOURCE_READY";
var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
var requestResource = createAction(REQUEST_RESOURCE)();
var requestError = createAction(REQUEST_ERROR)();
var requestMismatch = createAction(REQUEST_MISMATCH)();
var requestComplete = createAction(REQUEST_COMPLETE)();
var requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)();

// src/vault/actions/batch-actions.ts
var BATCH_ACTIONS = "@iiif/BATCH";
var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
var batchActions = createAction(BATCH_ACTIONS)();
var batchImport = createAction(BATCH_IMPORT)();

// src/vault/utility/action-list-from-resource.ts
var import_parser = require("@iiif/parser");
var actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = (0, import_parser.normalize)(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

// src/vault/utility/are-inputs-equal.ts
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

// src/vault/utility/resolve-if-exists.ts
var import_parser2 = require("@iiif/parser");
function resolveIfExists(state, url, parent) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  const fullEntity = state.iiif.entities[resourceType][request.resourceUri];
  if (fullEntity && fullEntity[import_parser2.HAS_PART]) {
    const framing = fullEntity[import_parser2.HAS_PART].find((t) => {
      return parent ? t[import_parser2.PART_OF] === parent.id : t[import_parser2.PART_OF] === fullEntity.id;
    });
    return (0, import_parser2.frameResource)(fullEntity, framing);
  }
  return fullEntity;
}

// src/vault/utility/is-promise.ts
function isPromise(value) {
  return value && typeof value.then === "function";
}

// src/vault/utility/create-fetch-helper.ts
function createFetchHelper(vault, fetcher, { waitTimeout = 30 } = {}) {
  return (url, options, mapper) => {
    const store = vault.getStore();
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      if (request.loadingState === RESOURCE_READY) {
        const resolvedEntity = resolveIfExists(state, url);
        if (resolvedEntity) {
          return resolvedEntity;
        }
      }
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          return (async () => {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise(
                  (resolve, reject) => setTimeout(
                    () => {
                      didContinue = true;
                      reject();
                    },
                    waitTimeout * 60 * 1e3
                  )
                )
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
            }
          })();
        }
      }
    }
    vault.dispatch(requestResource({ id: url }));
    const importResource = (resource) => {
      if (!resource) {
        return void 0;
      }
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      vault.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    };
    try {
      const resourceOrPromise = fetcher(url, options);
      if (isPromise(resourceOrPromise)) {
        return (async () => {
          try {
            let data = await resourceOrPromise;
            if (mapper) {
              data = mapper(data);
            }
            return importResource(data);
          } catch (err) {
            vault.dispatch(requestError({ id: url, message: err.toString() }));
            throw err;
          }
        })();
      }
      return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);
    } catch (err) {
      vault.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

// src/vault/utility/get-default-entities.ts
function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs
var import_meta2 = {};
var reduxImpl = (reducer, initial) => (set, _get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action), false, action);
    return action;
  };
  api.dispatchFromDevtools = true;
  return { dispatch: (...a) => api.dispatch(...a), ...initial };
};
var redux = reduxImpl;
var trackedConnections = /* @__PURE__ */ new Map();
var getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api)
    return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
var extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
var devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording)
      return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState)
              return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
var devtools = devtoolsImpl;
var parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0)
    f(parsed);
};
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;

// src/vault/store/reducers/mapping-reducer.ts
var mappingReducer = (state = {}, action) => {
  switch (action.type) {
    case ADD_MAPPING:
      return {
        ...state,
        [action.payload.id]: action.payload.type
      };
    case ADD_MAPPINGS:
      return {
        ...state,
        ...action.payload.mapping
      };
    default:
      return state;
  }
};

// src/vault/utility/is-reference-list.ts
function isReferenceList(state, id, type, key) {
  return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
}

// src/vault/utility/quick-merge.ts
function quickMerge(a, b) {
  const newResource = {};
  const added = [];
  for (const [key, value] of Object.entries(a || {})) {
    added.push(key);
    const bValue = (b || {})[key];
    if (!bValue || bValue.length === 0) {
      newResource[key] = value;
      continue;
    }
    newResource[key] = bValue;
  }
  for (const [key, value] of Object.entries(b || {})) {
    if (added.indexOf(key) !== -1) {
      continue;
    }
    newResource[key] = value;
  }
  return newResource;
}

// src/vault/store/reducers/entities-reducer.ts
function payload(action) {
  return action.payload;
}
function numberOr(a, b) {
  return typeof a === "undefined" ? b : a;
}
var entitiesReducer = (state = getDefaultEntities(), action) => {
  const updateField = (entity, values) => {
    return {
      ...state,
      [payload(action).type]: {
        ...state[payload(action).type],
        [payload(action).id]: {
          ...entity,
          ...values
        }
      }
    };
  };
  switch (action.type) {
    case MODIFY_ENTITY_FIELD: {
      if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      return updateField(entity, { [payload(action).key]: payload(action).value });
    }
    case REORDER_ENTITY_FIELD: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      const result = Array.from(entity[payload(action).key]);
      const [removed] = result.splice(payload(action).startIndex, 1);
      result.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { [payload(action).key]: result });
    }
    case IMPORT_ENTITIES: {
      const keys = Object.keys(payload(action).entities);
      const toReturn = { ...state };
      for (const key of keys) {
        const entities = payload(action).entities[key];
        const newEntities = { ...state[key] || {} };
        let changed = false;
        const ids = Object.keys(entities || {}) || [];
        if (entities && ids) {
          for (const id of ids) {
            changed = true;
            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
          }
          if (changed) {
            toReturn[key] = newEntities;
          }
        }
      }
      return toReturn;
    }
    case ADD_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);
      return updateField(entity, { [payload(action).key]: result });
    }
    case UPDATE_REFERENCE:
    case REMOVE_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      const indexToRemove = numberOr(
        payload(action).index,
        result.findIndex((e) => e && e.id === payload(action).reference.id)
      );
      if (indexToRemove === -1 || result[indexToRemove]?.id !== payload(action).reference.id) {
        return state;
      }
      if (action.type === UPDATE_REFERENCE) {
        result.splice(indexToRemove, 1, payload(action).reference);
      } else {
        result.splice(indexToRemove, 1);
      }
      return updateField(entity, { [payload(action).key]: result });
    }
    case ADD_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (!entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const actionPayload = payload(action);
      metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {
        label: actionPayload.label,
        value: actionPayload.label
      });
      return updateField(entity, { metadata });
    }
    case REORDER_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string" || !entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const [removed] = metadata.splice(payload(action).startIndex, 1);
      metadata.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { metadata });
    }
    case UPDATE_METADATA:
    case REMOVE_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      const metadata = Array.from(entity.metadata || []);
      const indexToRemove = payload(action).atIndex;
      if (typeof indexToRemove === "undefined" || indexToRemove === -1 || !metadata[indexToRemove]) {
        return state;
      }
      if (action.type === UPDATE_METADATA) {
        metadata.splice(indexToRemove, 1, { label: payload(action).label, value: payload(action).value });
      } else {
        metadata.splice(indexToRemove, 1);
      }
      return updateField(entity, { metadata });
    }
    default:
      return state;
  }
};

// src/vault/store/reducers/request-reducer.ts
var requestReducer = (state = {}, action) => {
  switch (action.type) {
    case REQUEST_RESOURCE:
    case REQUEST_OFFLINE_RESOURCE:
      return {
        ...state,
        [action.payload.id]: {
          requestUri: action.payload.id,
          loadingState: RESOURCE_LOADING,
          uriMismatch: false,
          resourceUri: action.payload.id
        }
      };
    case REQUEST_MISMATCH:
      return {
        ...state,
        [action.payload.requestId]: {
          ...state[action.payload.requestId] || {},
          uriMismatch: true,
          resourceUri: action.payload.actualId
        },
        [action.payload.actualId]: {
          requestUri: action.payload.requestId,
          loadingState: state[action.payload.requestId].loadingState,
          uriMismatch: true,
          resourceUri: action.payload.actualId
        }
      };
    case REQUEST_ERROR:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_ERROR,
          error: action.payload.message
        }
      };
    case REQUEST_COMPLETE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_READY,
          error: void 0
        }
      };
  }
  return state;
};

// src/vault/store/reducers/meta-reducer.ts
var metaReducer = (state = {}, action) => {
  const { id, updateValue, value, meta, key } = action && action.payload || {};
  switch (action.type) {
    case SET_META_VALUE: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: value
          }
        }
      };
    }
    case SET_META_VALUE_DYNAMIC: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
          }
        }
      };
    }
    case UNSET_META_VALUE: {
      if (state[id] && state[id][meta] && state[id][meta][key]) {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: void 0
            }
          }
        };
      }
      return state;
    }
    default:
      return state;
  }
};

// src/vault/utility/combine-reducers.ts
function combineReducers(reducers2 = {}) {
  const reducerKeys = Object.keys(reducers2);
  return function combination(state = {}, action) {
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      nextState[key] = reducers2[key](state[key], action);
      hasChanged = hasChanged || nextState[key] !== state[key];
    }
    return hasChanged ? nextState : state;
  };
}

// src/vault/store/reducers/batch-reducer.ts
function createBatchReducer(rootReducer) {
  return (state, action) => {
    if (action && action.type === BATCH_ACTIONS) {
      return action.payload.actions.reduce(rootReducer, state);
    }
    if (action && action.type === BATCH_IMPORT) {
      return {
        ...state,
        iiif: {
          ...state.iiif,
          ...action.payload.state
        }
      };
    }
    return rootReducer(state, action);
  };
}

// src/vault/store/index.ts
var reducers = combineReducers({
  mapping: mappingReducer,
  entities: entitiesReducer,
  requests: requestReducer,
  meta: metaReducer
});
function getDefaultState() {
  return {
    iiif: {
      entities: getDefaultEntities(),
      meta: {},
      mapping: {},
      requests: {}
    }
  };
}
function createStore2(options = {}) {
  const {
    enableDevtools = false,
    iiifStoreName = "iiif",
    defaultState = getDefaultState(),
    customReducers = {}
  } = options;
  const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));
  const enabled = Boolean(typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__);
  const dv = !enabled || false ? (a, r) => a : devtools;
  return createStore(
    //
    subscribeWithSelector(
      //
      dv(
        //
        redux(rootReducer, defaultState),
        { enabled: enableDevtools }
      )
    )
  );
}

// node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// src/vault/utility/objects.ts
function defineProperty(name, prototype, vault, enumerable = true) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  const cache = /* @__PURE__ */ new Map();
  Object.defineProperty(prototype, name, {
    enumerable,
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      const object = vault.get(prototype[REFS][name], {
        parent: this.id ? { id: this.id, type: this.type } : void 0
      });
      if (!cache.has(object)) {
        cache.clear();
        cache.set(object, wrapObject(object, vault));
      }
      return cache.get(object);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        if (this[REACTIVE]) {
          vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));
        } else {
          this[REFS][name] = items;
        }
      }
    }
  });
}
var REFS = Symbol.for("_refs_");
var REACTIVE = Symbol.for("_reactive_");
var DEFINED = Symbol.for("_defined_");
var PARENT = Symbol.for("_parent_");
function createPrototype(vault, reactive = false, parent) {
  const prototype = {
    id: "",
    type: "unknown",
    [DEFINED]: [],
    [REFS]: {},
    [PARENT]: parent || null,
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      const parent2 = this[PARENT];
      return vault.get(this.id, { parent: parent2 ? { id: parent2, type: "unknown" } : void 0 });
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    valueOf() {
      return this.unwrap();
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault, false);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault, false);
  defineProperty("accompanyingCanvas", prototype, vault, false);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function isWrapped(object) {
  return !!object[DEFINED];
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false, parent) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}

// src/vault/utility/resolve-type.ts
function resolveType(type) {
  switch (type) {
    case "Image":
    case "Video":
    case "Sound":
    case "Dataset":
    case "Text":
    case "Composite":
    case "List":
    case "Independents":
    case "Audience":
      return "ContentResource";
    case "ImageService1":
    case "ImageService2":
    case "ImageService3":
      return "Service";
  }
  return type;
}

// src/vault/vault.ts
var Vault = class {
  constructor(options, store) {
    __publicField(this, "options");
    __publicField(this, "store");
    __publicField(this, "emitter");
    __publicField(this, "isBatching", false);
    __publicField(this, "batchQueue", []);
    __publicField(this, "remoteFetcher");
    __publicField(this, "staticFetcher");
    __publicField(this, "defaultFetcher", (url) => {
      return fetch(url).then((r) => {
        if (r.status === 200) {
          return r.json();
        } else {
          const err = new Error(`${r.status} ${r.statusText}`);
          err.name = `HTTPError`;
          throw err;
        }
      });
    });
    this.options = Object.assign(
      {
        reducers: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      },
      options || {}
    );
    this.store = store || createStore2({
      customReducers: this.options.reducers,
      defaultState: this.options.defaultState,
      enableDevtools: this.options.enableDevtools
    });
    this.emitter = mitt_default();
    this.remoteFetcher = createFetchHelper(this, this.options.customFetcher);
    this.staticFetcher = createFetchHelper(this, (id, json) => json);
  }
  batch(cb) {
    this.isBatching = true;
    try {
      cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  async asyncBatch(cb) {
    this.isBatching = true;
    try {
      await cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  modifyEntityField(entity, key, value) {
    this.dispatch(
      entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      })
    );
  }
  dispatch(action) {
    if (!this.isBatching) {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });
        }
        this.store.dispatch(action);
        const state2 = this.getState();
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${realAction.type}`, { action: realAction, state: state2 });
        }
        return;
      }
      this.emitter.emit(action.type, { action, state: this.store.getState() });
      this.store.dispatch(action);
      const state = this.store.getState();
      this.emitter.emit(`after:${action.type}`, { action, state });
      return;
    } else {
      this.batchQueue.push(action);
    }
  }
  on(event, handler) {
    this.emitter.on(event, handler);
    return () => {
      this.emitter.off(event, handler);
    };
  }
  serialize(entity, config) {
    return (0, import_parser3.serialize)(this.getState().iiif, entity, config);
  }
  toPresentation2(entity) {
    return this.serialize(entity, import_parser3.serializeConfigPresentation2);
  }
  toPresentation3(entity) {
    return this.serialize(entity, import_parser3.serializeConfigPresentation3);
  }
  hydrate(reference, type, options = {}) {
    return this.get(reference, type, { ...options, skipSelfReturn: false });
  }
  get(reference, type, options = {}) {
    if (typeof type !== "string") {
      options = type || {};
      type = void 0;
    }
    const { skipSelfReturn = true } = options || {};
    let parent = options.parent ? typeof options.parent === "string" ? options.parent : options.parent.id : void 0;
    if (Array.isArray(reference)) {
      return reference.map((i) => this.get(i, options));
    }
    const state = this.getState();
    if ((0, import_parser3.isSpecificResource)(reference) && !options.preserveSpecificResources) {
      reference = reference.source;
    }
    if (typeof reference === "string") {
      const _type2 = resolveType(type ? type : state.iiif.mapping[reference]);
      if (!_type2) {
        if (skipSelfReturn) {
          return null;
        }
        return { id: reference, type: "unknown" };
      }
      reference = { id: reference, type: _type2 };
    }
    if (reference && reference.partOf && !parent && !options.skipPartOfCheck) {
      const first = Array.isArray(reference.partOf) ? reference.partOf[0] : reference.partOf;
      if (first) {
        if (typeof first === "string") {
          parent = first;
        }
        if (typeof first.id === "string") {
          parent = first.id;
        }
      }
    }
    const _type = resolveType(type ? type : reference?.type);
    const _id = reference?.id;
    const entities = state.iiif.entities[_type];
    if (!entities) {
      const request = state.iiif.requests[_id];
      if (request && request.resourceUri !== _id) {
        return this.get(request.resourceUri, options);
      }
      if (skipSelfReturn) {
        return null;
      }
      return reference;
    }
    const found = entities[reference.id];
    if (found && found[import_parser3.HAS_PART]) {
      const framing = found[import_parser3.HAS_PART].find((t) => {
        return parent ? t[import_parser3.PART_OF] === parent : t[import_parser3.PART_OF] === found.id;
      });
      return (0, import_parser3.frameResource)(found, framing);
    }
    return entities[reference.id] || (skipSelfReturn ? null : reference);
  }
  select(selector) {
    return selector(this.getState());
  }
  getStore() {
    return this.store;
  }
  getState() {
    return this.store.getState();
  }
  deep(input, prev) {
    if (typeof input === "undefined") {
      return this.get(prev, { skipSelfReturn: false });
    }
    if (typeof input === "function") {
      try {
        const next = input(this.get(prev, { skipSelfReturn: false }));
        const fn2 = (newInput) => this.deep(newInput, next);
        fn2.size = Array.isArray(next) ? next.length : 1;
        return fn2;
      } catch (e) {
        const fn2 = (newInput) => this.deep(newInput, void 0);
        fn2.size = 0;
        return fn2;
      }
    }
    const fn = (newInput) => this.deep(newInput, input);
    fn.size = Array.isArray(input) ? input.length : 1;
    return fn;
  }
  loadManifest(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  loadCollection(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  load(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    if (json) {
      return Promise.resolve(this.staticFetcher(_id, json, mapper));
    }
    return Promise.resolve(this.remoteFetcher(_id, {}, mapper));
  }
  loadSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.staticFetcher(_id, json, mapper);
  }
  loadManifestSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  loadCollectionSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  areInputsEqual(newInputs, lastInputs) {
    return areInputsEqual(newInputs, lastInputs);
  }
  subscribe(selector, subscription, skipInitial) {
    if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
      skipInitial = subscription;
      subscription = selector;
      selector = (a) => a;
    }
    return this.store.subscribe(selector, (s) => subscription(s, this), {
      equalityFn: areInputsEqual,
      fireImmediately: !skipInitial
    });
  }
  async ensureLoaded(_id) {
    const id = typeof _id === "string" ? _id : _id.id;
    if (!this.requestStatus(id)) {
      await this.load(id);
    }
  }
  requestStatus(id) {
    return this.select((state) => {
      return state.iiif.requests[id];
    });
  }
  // Pagination built on "meta".
  getPaginationState(resource) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return null;
    const existing = this.getResourceMeta(id, "@vault/pagination");
    if (existing?.state) {
      return existing.state;
    }
    const fullResource = this.get(resource);
    if (fullResource.first) {
      const initialState = {
        currentPage: null,
        currentPageIndex: null,
        isFetching: false,
        isFullyLoaded: false,
        next: fullResource.first,
        page: 1,
        pages: [],
        previous: null,
        totalItems: fullResource.total,
        currentLength: 0
      };
      this.setMetaValue([id, "@vault/pagination", "state"], initialState);
      return initialState;
    }
    return null;
  }
  async loadNextPage(resource, json) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return [null, null];
    const state = this.getPaginationState(resource);
    if (!state || state.isFullyLoaded || !state.next) {
      return [null, null];
    }
    if (state.isFetching) {
      return [state, null];
    }
    const nextPage = typeof state.next === "string" ? state.next : state.next.id;
    const previousPage = state.currentPage;
    const newState = {
      ...state,
      isFetching: true
    };
    this.setMetaValue([id, "@vault/pagination", "state"], newState);
    let collectionPage;
    try {
      collectionPage = await this.loadCollection(nextPage, json, (mapped) => {
        const { id: id2, ["@id"]: _id, ...properties } = mapped || {};
        if (_id) {
          return { ["@id"]: nextPage, ...properties };
        }
        return { id: nextPage, ...properties };
      });
    } catch (err) {
      const errState = {
        ...state,
        isFetching: false,
        error: err
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    if (!collectionPage) {
      const errState = {
        ...state,
        isFetching: false,
        error: new Error("Collection not found")
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    const fullCollection = this.get(id);
    const combinedItems = [
      ...fullCollection.items || [],
      ...collectionPage.items || []
    ].map((resource2) => ({
      id: resource2.id,
      type: resource2.type
    }));
    this.modifyEntityField({ id, type: "Collection" }, "items", combinedItems);
    const latestState = this.getPaginationState(resource);
    if (!latestState)
      throw new Error("Pagination state not found");
    const successState = {
      ...latestState,
      isFetching: false,
      error: null,
      currentPage: collectionPage.id,
      next: collectionPage.next?.id || null,
      currentPageIndex: latestState.pages.length,
      currentLength: combinedItems.length,
      pages: [
        ...latestState.pages,
        {
          id: collectionPage.id,
          type: "Collection",
          startIndex: fullCollection.items.length,
          pageLength: collectionPage.items.length,
          order: typeof latestState.currentPageIndex === "number" ? latestState.currentPageIndex + 1 : 0
        }
      ],
      isFullyLoaded: !collectionPage.next,
      previous: previousPage,
      page: latestState.pages.length + 1
    };
    this.setMetaValue([id, "@vault/pagination", "state"], successState);
    return [successState, collectionPage];
  }
  getResourceMeta(resource, metaKey) {
    const resourceMeta = this.getState().iiif.meta[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
  getObject(reference, type, options = {}) {
    const { reactive, ...otherOptions } = options;
    return wrapObject(this.get(reference, type, otherOptions), this, reactive);
  }
  async loadObject(id, json) {
    return wrapObject(await this.load(id, json), this);
  }
  async loadManifestObject(id, json) {
    return wrapObject(await this.loadManifest(id, json), this);
  }
  async loadCollectionObject(id, json) {
    return wrapObject(await this.loadCollection(id, json), this);
  }
  wrapObject(objectType) {
    return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);
  }
  isWrapped(object) {
    return isWrapped(object);
  }
  setMetaValue([id, meta, key], newValueOrUpdate) {
    this.dispatch(
      typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      })
    );
  }
};

// src/vault/utility/get-global.ts
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return {};
}

// src/vault-node.ts
var _importDynamic = new Function("modulePath", "return import(modulePath)");
async function fetchInternal(...args) {
  if (typeof fetch !== "undefined") {
    return fetch(...args);
  }
  const { default: fetch_ } = await _importDynamic("node-fetch");
  return fetch_(...args);
}
var Vault2 = class extends Vault {
  constructor(options, store) {
    const _options = options || {};
    _options.customFetcher = async (url) => {
      return fetchInternal(url).then((r) => r.json());
    };
    super(_options, store);
  }
};
function globalVault(options) {
  const g = getGlobal();
  try {
    const gv = g["IIIF_VAULT"];
    if (gv) {
      return gv;
    }
  } catch (e) {
  }
  const newVault = new Vault2(options);
  try {
    g["IIIF_VAULT"] = newVault;
  } catch (e) {
  }
  return newVault;
}
