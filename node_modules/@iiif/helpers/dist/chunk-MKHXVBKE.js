import {
  areInputsEqual,
  createFetchHelper
} from "./chunk-NPLDMOQC.js";
import {
  createStore
} from "./chunk-OFD6EF4T.js";
import {
  metaActions
} from "./chunk-YAISZCRN.js";
import {
  BATCH_ACTIONS,
  batchActions,
  entityActions
} from "./chunk-F2Q2OM3J.js";
import {
  mitt_default
} from "./chunk-6NZ5BWVI.js";
import {
  __publicField
} from "./chunk-G7A32JAG.js";

// src/vault/vault.ts
import {
  frameResource,
  HAS_PART,
  isSpecificResource,
  PART_OF,
  serialize,
  serializeConfigPresentation2,
  serializeConfigPresentation3
} from "@iiif/parser";

// src/vault/utility/objects.ts
function defineProperty(name, prototype, vault, enumerable = true) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  const cache = /* @__PURE__ */ new Map();
  Object.defineProperty(prototype, name, {
    enumerable,
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      const object = vault.get(prototype[REFS][name], {
        parent: this.id ? { id: this.id, type: this.type } : void 0
      });
      if (!cache.has(object)) {
        cache.clear();
        cache.set(object, wrapObject(object, vault));
      }
      return cache.get(object);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        if (this[REACTIVE]) {
          vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));
        } else {
          this[REFS][name] = items;
        }
      }
    }
  });
}
var REFS = Symbol.for("_refs_");
var REACTIVE = Symbol.for("_reactive_");
var DEFINED = Symbol.for("_defined_");
var PARENT = Symbol.for("_parent_");
function createPrototype(vault, reactive = false, parent) {
  const prototype = {
    id: "",
    type: "unknown",
    [DEFINED]: [],
    [REFS]: {},
    [PARENT]: parent || null,
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      const parent2 = this[PARENT];
      return vault.get(this.id, { parent: parent2 ? { id: parent2, type: "unknown" } : void 0 });
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    valueOf() {
      return this.unwrap();
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault, false);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault, false);
  defineProperty("accompanyingCanvas", prototype, vault, false);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function isWrapped(object) {
  return !!object[DEFINED];
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false, parent) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}

// src/vault/utility/resolve-type.ts
function resolveType(type) {
  switch (type) {
    case "Image":
    case "Video":
    case "Sound":
    case "Dataset":
    case "Text":
    case "Composite":
    case "List":
    case "Independents":
    case "Audience":
      return "ContentResource";
    case "ImageService1":
    case "ImageService2":
    case "ImageService3":
      return "Service";
  }
  return type;
}

// src/vault/vault.ts
var Vault = class {
  constructor(options, store) {
    __publicField(this, "options");
    __publicField(this, "store");
    __publicField(this, "emitter");
    __publicField(this, "isBatching", false);
    __publicField(this, "batchQueue", []);
    __publicField(this, "remoteFetcher");
    __publicField(this, "staticFetcher");
    __publicField(this, "defaultFetcher", (url) => {
      return fetch(url).then((r) => {
        if (r.status === 200) {
          return r.json();
        } else {
          const err = new Error(`${r.status} ${r.statusText}`);
          err.name = `HTTPError`;
          throw err;
        }
      });
    });
    this.options = Object.assign(
      {
        reducers: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      },
      options || {}
    );
    this.store = store || createStore({
      customReducers: this.options.reducers,
      defaultState: this.options.defaultState,
      enableDevtools: this.options.enableDevtools
    });
    this.emitter = mitt_default();
    this.remoteFetcher = createFetchHelper(this, this.options.customFetcher);
    this.staticFetcher = createFetchHelper(this, (id, json) => json);
  }
  batch(cb) {
    this.isBatching = true;
    try {
      cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  async asyncBatch(cb) {
    this.isBatching = true;
    try {
      await cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  modifyEntityField(entity, key, value) {
    this.dispatch(
      entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      })
    );
  }
  dispatch(action) {
    if (!this.isBatching) {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });
        }
        this.store.dispatch(action);
        const state2 = this.getState();
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${realAction.type}`, { action: realAction, state: state2 });
        }
        return;
      }
      this.emitter.emit(action.type, { action, state: this.store.getState() });
      this.store.dispatch(action);
      const state = this.store.getState();
      this.emitter.emit(`after:${action.type}`, { action, state });
      return;
    } else {
      this.batchQueue.push(action);
    }
  }
  on(event, handler) {
    this.emitter.on(event, handler);
    return () => {
      this.emitter.off(event, handler);
    };
  }
  serialize(entity, config) {
    return serialize(this.getState().iiif, entity, config);
  }
  toPresentation2(entity) {
    return this.serialize(entity, serializeConfigPresentation2);
  }
  toPresentation3(entity) {
    return this.serialize(entity, serializeConfigPresentation3);
  }
  hydrate(reference, type, options = {}) {
    return this.get(reference, type, { ...options, skipSelfReturn: false });
  }
  get(reference, type, options = {}) {
    if (typeof type !== "string") {
      options = type || {};
      type = void 0;
    }
    const { skipSelfReturn = true } = options || {};
    let parent = options.parent ? typeof options.parent === "string" ? options.parent : options.parent.id : void 0;
    if (Array.isArray(reference)) {
      return reference.map((i) => this.get(i, options));
    }
    const state = this.getState();
    if (isSpecificResource(reference) && !options.preserveSpecificResources) {
      reference = reference.source;
    }
    if (typeof reference === "string") {
      const _type2 = resolveType(type ? type : state.iiif.mapping[reference]);
      if (!_type2) {
        if (skipSelfReturn) {
          return null;
        }
        return { id: reference, type: "unknown" };
      }
      reference = { id: reference, type: _type2 };
    }
    if (reference && reference.partOf && !parent && !options.skipPartOfCheck) {
      const first = Array.isArray(reference.partOf) ? reference.partOf[0] : reference.partOf;
      if (first) {
        if (typeof first === "string") {
          parent = first;
        }
        if (typeof first.id === "string") {
          parent = first.id;
        }
      }
    }
    const _type = resolveType(type ? type : reference?.type);
    const _id = reference?.id;
    const entities = state.iiif.entities[_type];
    if (!entities) {
      const request = state.iiif.requests[_id];
      if (request && request.resourceUri !== _id) {
        return this.get(request.resourceUri, options);
      }
      if (skipSelfReturn) {
        return null;
      }
      return reference;
    }
    const found = entities[reference.id];
    if (found && found[HAS_PART]) {
      const framing = found[HAS_PART].find((t) => {
        return parent ? t[PART_OF] === parent : t[PART_OF] === found.id;
      });
      return frameResource(found, framing);
    }
    return entities[reference.id] || (skipSelfReturn ? null : reference);
  }
  select(selector) {
    return selector(this.getState());
  }
  getStore() {
    return this.store;
  }
  getState() {
    return this.store.getState();
  }
  deep(input, prev) {
    if (typeof input === "undefined") {
      return this.get(prev, { skipSelfReturn: false });
    }
    if (typeof input === "function") {
      try {
        const next = input(this.get(prev, { skipSelfReturn: false }));
        const fn2 = (newInput) => this.deep(newInput, next);
        fn2.size = Array.isArray(next) ? next.length : 1;
        return fn2;
      } catch (e) {
        const fn2 = (newInput) => this.deep(newInput, void 0);
        fn2.size = 0;
        return fn2;
      }
    }
    const fn = (newInput) => this.deep(newInput, input);
    fn.size = Array.isArray(input) ? input.length : 1;
    return fn;
  }
  loadManifest(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  loadCollection(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  load(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    if (json) {
      return Promise.resolve(this.staticFetcher(_id, json, mapper));
    }
    return Promise.resolve(this.remoteFetcher(_id, {}, mapper));
  }
  loadSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.staticFetcher(_id, json, mapper);
  }
  loadManifestSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  loadCollectionSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  areInputsEqual(newInputs, lastInputs) {
    return areInputsEqual(newInputs, lastInputs);
  }
  subscribe(selector, subscription, skipInitial) {
    if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
      skipInitial = subscription;
      subscription = selector;
      selector = (a) => a;
    }
    return this.store.subscribe(selector, (s) => subscription(s, this), {
      equalityFn: areInputsEqual,
      fireImmediately: !skipInitial
    });
  }
  async ensureLoaded(_id) {
    const id = typeof _id === "string" ? _id : _id.id;
    if (!this.requestStatus(id)) {
      await this.load(id);
    }
  }
  requestStatus(id) {
    return this.select((state) => {
      return state.iiif.requests[id];
    });
  }
  // Pagination built on "meta".
  getPaginationState(resource) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return null;
    const existing = this.getResourceMeta(id, "@vault/pagination");
    if (existing?.state) {
      return existing.state;
    }
    const fullResource = this.get(resource);
    if (fullResource.first) {
      const initialState = {
        currentPage: null,
        currentPageIndex: null,
        isFetching: false,
        isFullyLoaded: false,
        next: fullResource.first,
        page: 1,
        pages: [],
        previous: null,
        totalItems: fullResource.total,
        currentLength: 0
      };
      this.setMetaValue([id, "@vault/pagination", "state"], initialState);
      return initialState;
    }
    return null;
  }
  async loadNextPage(resource, json) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return [null, null];
    const state = this.getPaginationState(resource);
    if (!state || state.isFullyLoaded || !state.next) {
      return [null, null];
    }
    if (state.isFetching) {
      return [state, null];
    }
    const nextPage = typeof state.next === "string" ? state.next : state.next.id;
    const previousPage = state.currentPage;
    const newState = {
      ...state,
      isFetching: true
    };
    this.setMetaValue([id, "@vault/pagination", "state"], newState);
    let collectionPage;
    try {
      collectionPage = await this.loadCollection(nextPage, json, (mapped) => {
        const { id: id2, ["@id"]: _id, ...properties } = mapped || {};
        if (_id) {
          return { ["@id"]: nextPage, ...properties };
        }
        return { id: nextPage, ...properties };
      });
    } catch (err) {
      const errState = {
        ...state,
        isFetching: false,
        error: err
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    if (!collectionPage) {
      const errState = {
        ...state,
        isFetching: false,
        error: new Error("Collection not found")
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    const fullCollection = this.get(id);
    const combinedItems = [
      ...fullCollection.items || [],
      ...collectionPage.items || []
    ].map((resource2) => ({
      id: resource2.id,
      type: resource2.type
    }));
    this.modifyEntityField({ id, type: "Collection" }, "items", combinedItems);
    const latestState = this.getPaginationState(resource);
    if (!latestState)
      throw new Error("Pagination state not found");
    const successState = {
      ...latestState,
      isFetching: false,
      error: null,
      currentPage: collectionPage.id,
      next: collectionPage.next?.id || null,
      currentPageIndex: latestState.pages.length,
      currentLength: combinedItems.length,
      pages: [
        ...latestState.pages,
        {
          id: collectionPage.id,
          type: "Collection",
          startIndex: fullCollection.items.length,
          pageLength: collectionPage.items.length,
          order: typeof latestState.currentPageIndex === "number" ? latestState.currentPageIndex + 1 : 0
        }
      ],
      isFullyLoaded: !collectionPage.next,
      previous: previousPage,
      page: latestState.pages.length + 1
    };
    this.setMetaValue([id, "@vault/pagination", "state"], successState);
    return [successState, collectionPage];
  }
  getResourceMeta(resource, metaKey) {
    const resourceMeta = this.getState().iiif.meta[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
  getObject(reference, type, options = {}) {
    const { reactive, ...otherOptions } = options;
    return wrapObject(this.get(reference, type, otherOptions), this, reactive);
  }
  async loadObject(id, json) {
    return wrapObject(await this.load(id, json), this);
  }
  async loadManifestObject(id, json) {
    return wrapObject(await this.loadManifest(id, json), this);
  }
  async loadCollectionObject(id, json) {
    return wrapObject(await this.loadCollection(id, json), this);
  }
  wrapObject(objectType) {
    return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);
  }
  isWrapped(object) {
    return isWrapped(object);
  }
  setMetaValue([id, meta, key], newValueOrUpdate) {
    this.dispatch(
      typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      })
    );
  }
};

// src/vault/utility/get-global.ts
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return {};
}

export {
  Vault,
  getGlobal
};
