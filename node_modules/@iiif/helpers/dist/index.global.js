"use strict";
var IIIFHelpers = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = parse;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse(path) {
        var data = [];
        path.replace(segment, function(_3, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type])
              throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js
  var require_abs_svg_path = __commonJS({
    "node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = absolutize;
      function absolutize(path) {
        var startX = 0;
        var startY = 0;
        var x4 = 0;
        var y4 = 0;
        return path.map(function(seg) {
          seg = seg.slice();
          var type = seg[0];
          var command = type.toUpperCase();
          if (type != command) {
            seg[0] = command;
            switch (type) {
              case "a":
                seg[6] += x4;
                seg[7] += y4;
                break;
              case "v":
                seg[1] += y4;
                break;
              case "h":
                seg[1] += x4;
                break;
              default:
                for (var i3 = 1; i3 < seg.length; ) {
                  seg[i3++] += x4;
                  seg[i3++] += y4;
                }
            }
          }
          switch (command) {
            case "Z":
              x4 = startX;
              y4 = startY;
              break;
            case "H":
              x4 = seg[1];
              break;
            case "V":
              y4 = seg[1];
              break;
            case "M":
              x4 = startX = seg[1];
              y4 = startY = seg[2];
              break;
            default:
              x4 = seg[seg.length - 2];
              y4 = seg[seg.length - 1];
          }
          return seg;
        });
      }
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    ImageServiceLoader: () => ImageServiceLoader,
    Vault: () => Vault,
    buildLocaleString: () => buildLocaleString,
    createDateNavigation: () => createDateNavigation,
    createEventsHelper: () => createEventsHelper,
    createImageServiceStore: () => createImageServiceStore,
    createPaintingAnnotationsHelper: () => createPaintingAnnotationsHelper,
    createRangeHelper: () => createRangeHelper,
    createSearch1AutocompleteStore: () => createSearch1AutocompleteStore,
    createSearch1Store: () => createSearch1Store,
    createSequenceHelper: () => createSequenceHelper,
    createStringHelper: () => createStringHelper,
    createStylesHelper: () => createStylesHelper,
    createThumbnailHelper: () => createThumbnailHelper,
    decodeContentState: () => decodeContentState,
    encodeContentState: () => encodeContentState,
    expandTarget: () => expandTarget,
    fetch: () => fetchAndUpgrade,
    findAllCanvasesInRange: () => findAllCanvasesInRange,
    findAutocompleteService: () => findAutocompleteService,
    findFirstCanvasFromRange: () => findFirstCanvasFromRange,
    findFirstCanvasFromRangeWithSelector: () => findFirstCanvasFromRangeWithSelector,
    findManifestSelectedRange: () => findManifestSelectedRange,
    findSearch1Service: () => findSearch1Service,
    findSelectedRange: () => findSelectedRange,
    getAvailableLanguagesFromResource: () => getAvailableLanguagesFromResource,
    getClosestLanguage: () => getClosestLanguage,
    getCustomSizeFromService: () => getCustomSizeFromService,
    getFixedSizeFromImage: () => getFixedSizeFromImage,
    getFixedSizesFromService: () => getFixedSizesFromService,
    getImageCandidates: () => getImageCandidates,
    getImageCandidatesFromService: () => getImageCandidatesFromService,
    getImageFromTileSource: () => getImageFromTileSource,
    getImageServerFromId: () => getImageServerFromId,
    getManifestSequence: () => getManifestSequence,
    getSmallestScaleFactorAsSingleImage: () => getSmallestScaleFactorAsSingleImage,
    getThumbnail: () => getThumbnail,
    getValue: () => getValue,
    getVisibleCanvasesFromCanvasId: () => getVisibleCanvasesFromCanvasId,
    globalVault: () => globalVault,
    iiifString: () => iiifString,
    imageServiceLoader: () => imageServiceLoader,
    imageServices: () => imageServices,
    imageSizesMatch: () => imageSizesMatch,
    inferImageSizeFromUrl: () => inferImageSizeFromUrl,
    isBestMatch: () => isBestMatch,
    isImage3: () => isImage3,
    isImageApiSelector: () => isImageApiSelector,
    normaliseContentState: () => normaliseContentState,
    parseContentState: () => parseContentState,
    parseRotation: () => parseRotation,
    parseSelector: () => parseSelector,
    parseSpecificResource: () => parseSpecificResource,
    pickBestFromCandidates: () => pickBestFromCandidates,
    rangeToTableOfContentsTree: () => rangeToTableOfContentsTree,
    rangesToTableOfContentsTree: () => rangesToTableOfContentsTree,
    sampledTilesToTiles: () => sampledTilesToTiles,
    serialiseContentState: () => serialiseContentState,
    validateContentState: () => validateContentState
  });

  // src/compat.ts
  var metaState = {};
  var compatVault = {
    get(nonRef) {
      return nonRef;
    },
    setMetaValue([id, meta, key], value) {
      const oldValue = compatVault.getResourceMeta(id, meta);
      const oldValueItem = oldValue ? oldValue[key] : void 0;
      const newValue = typeof value === "function" ? value(oldValueItem) : value;
      metaState[id] = {
        ...metaState[id] || {},
        [meta]: {
          ...(metaState[id] || {})[meta] || {},
          [key]: newValue
        }
      };
    },
    getResourceMeta: (resource, metaKey) => {
      const resourceMeta = metaState[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    },
    async load(id) {
      const idToLoad = typeof id === "string" ? id : id.id;
      return fetch(idToLoad).then((response) => response.json());
    },
    requestStatus(id) {
      return void 0;
    }
  };

  // src/events.ts
  function createEventsHelper(vault = compatVault) {
    return {
      addEventListener(resource, event, listener, scope) {
        if (!resource) {
          return;
        }
        vault.setMetaValue(
          [resource.id, "eventManager", event],
          (registeredCallbacks) => {
            const callbacks = registeredCallbacks || [];
            for (const registered of callbacks) {
              if (registered.callback === listener) {
                return callbacks;
              }
            }
            return [...callbacks, { callback: listener, scope }];
          }
        );
        return listener;
      },
      removeEventListener(resource, event, listener) {
        if (!resource) {
          return;
        }
        vault.setMetaValue(
          [resource.id, "eventManager", event],
          (registeredCallbacks) => {
            return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
          }
        );
      },
      getListenersAsProps(resourceOrId, scope) {
        const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
        if (!resource || !resource.id) {
          return {};
        }
        const hooks = vault.getResourceMeta(resource.id, "eventManager");
        const props = {};
        if (hooks && resource) {
          for (const hook of Object.keys(hooks)) {
            props[hook] = (e3) => {
              const fullResource = vault.get(resource);
              for (const { callback, scope: _scope } of hooks[hook] || []) {
                if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                  callback(e3, fullResource);
                }
              }
            };
          }
        }
        return props;
      }
    };
  }

  // src/styles.ts
  function createStylesHelper(vault = compatVault) {
    return {
      applyStyles(resource, scope, styles) {
        const id = typeof resource === "string" ? resource : resource.id;
        return vault.setMetaValue([id, "styles", scope], styles);
      },
      getAppliedStyles(resource) {
        const id = typeof resource === "string" ? resource : resource.id;
        return vault.getResourceMeta(id, "styles");
      }
    };
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-J657UVVW.js
  var e = "http://library.stanford.edu/iiif/image-api/compliance.html#level0";
  var i = "http://library.stanford.edu/iiif/image-api/compliance.html#level1";
  var t = "http://library.stanford.edu/iiif/image-api/compliance.html#level2";
  var o = "http://library.stanford.edu/iiif/image-api/conformance.html#level0";
  var r = "http://library.stanford.edu/iiif/image-api/conformance.html#level1";
  var a = "http://library.stanford.edu/iiif/image-api/conformance.html#level2";
  var _ = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0";
  var I = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1";
  var l = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2";
  var p = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0";
  var s = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1";
  var n = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2";
  var E = "http://iiif.io/api/image/1/level0.json";
  var c = "http://iiif.io/api/image/1/profiles/level0.json";
  var F = "http://iiif.io/api/image/1/level1.json";
  var m = "http://iiif.io/api/image/1/profiles/level1.json";
  var f = "http://iiif.io/api/image/1/level2.json";
  var x = "http://iiif.io/api/image/1/profiles/level2.json";
  var A = "http://iiif.io/api/image/2/level0.json";
  var L = "http://iiif.io/api/image/2/profiles/level0.json";
  var h = "http://iiif.io/api/image/2/level1.json";
  var y = "http://iiif.io/api/image/2/profiles/level1.json";
  var d = "http://iiif.io/api/image/2/level2.json";
  var g = "http://iiif.io/api/image/2/profiles/level2.json";
  var M = "level0";
  var O = "level1";
  var v = "level2";
  var u = "http://iiif.io/api/image/2/level0";
  var N = "http://iiif.io/api/image/2/level1";
  var G = "http://iiif.io/api/image/2/level2";
  var R = [G, t, a, l, n, f, x, d, g, v];
  var C = [...R, N, i, r, I, s, F, m, h, y, O];
  var B = [u, N, G, e, i, t, o, r, a, _, I, l, p, s, n, E, c, F, m, f, x, A, L, h, y, d, g, M, O, v];
  var P = B;
  var S = [u, e, o, _, p, E, c, A, L, M];
  var z = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["sizeByWhListed"] };
  var b = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPx", "regionSquare", "sizeByWhListed", "sizeByH", "sizeByW", "sizeByWh"] };
  var j = { extraFormats: ["jpg", "png"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPct", "regionByPx", "regionSquare", "rotationBy90s", "sizeByWhListed", "sizeByConfinedWh", "sizeByH", "sizeByPct", "sizeByW", "sizeByWh"] };

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-D22QKJZO.js
  var d2 = Object.defineProperty;
  var e2 = (b5, a3, c2) => a3 in b5 ? d2(b5, a3, { enumerable: true, configurable: true, writable: true, value: c2 }) : b5[a3] = c2;
  var f2 = (b5, a3, c2) => (e2(b5, typeof a3 != "symbol" ? a3 + "" : a3, c2), c2);

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/image-3.js
  function A2(i3) {
    try {
      if (i3 === "full")
        return { full: true };
      if (i3 === "square")
        return { square: true };
      let e3 = i3.startsWith("pct:"), o4 = i3.substr(e3 ? 4 : 0).split(",").map((r3) => parseFloat(r3));
      return { x: o4[0], y: o4[1], w: o4[2], h: o4[3], percent: e3 };
    } catch {
      throw new Error("Expected 'full', 'square' or 'x,y,w,h'. Found " + i3);
    }
  }
  function P2(i3) {
    let e3 = { upscaled: false, max: false, confined: false };
    if (i3[0] === "^" && (e3.upscaled = true, i3 = i3.slice(1)), i3 === "max" || i3 === "full")
      return e3.max = true, e3.serialiseAsFull = i3 === "full", e3;
    if (i3[0] === "!" && (e3.confined = true, i3 = i3.slice(1)), i3[0] === "p")
      return e3.percentScale = parseFloat(i3.slice(4)), e3;
    let t4 = i3.split(",").map((o4) => o4.trim());
    return t4.length && (t4[0] !== "" && (e3.width = parseInt(t4[0], 10)), t4[1] !== "" && (e3.height = parseInt(t4[1], 10))), e3;
  }
  function $(i3) {
    let e3 = { angle: 0 };
    if (i3[0] === "!" && (e3.mirror = true, i3 = i3.substr(1)), e3.angle = parseFloat(i3) % 360, Number.isNaN(e3.angle))
      throw new Error(`Invalid rotation ${i3}`);
    return e3;
  }
  function R2(i3, e3 = "") {
    let t4 = i3.match(/^(([a-zA-Z]+):\/\/([^/]+))?((.*)+)/);
    if (!t4)
      throw new Error(`Invalid or unknown input ${i3}`);
    let o4 = t4[2], r3 = t4[3], a3 = t4[4];
    if (a3[0] === "/" && (a3 = a3.substring(1)), e3.length > 0) {
      if (e3[0] === "/" && (e3 = e3.substring(1)), e3 !== a3.substring(0, e3.length))
        throw new Error(`Path does not start with prefix (path: ${a3}, prefix: ${e3})`);
      a3 = a3.substring(e3.length);
    }
    return { scheme: o4, server: r3, path: a3, prefix: e3 };
  }
  function O2(i3, e3 = "") {
    let { path: t4, scheme: o4, server: r3, prefix: a3 } = R2(i3, e3), n2 = t4.split("/").reverse(), [s2, f5, p4, l4, ...y4] = n2, x4 = y4.reverse().filter(Boolean).join("/");
    if (n2.length === 1 || s2 === "")
      return { type: "base", scheme: o4, server: r3, prefix: a3, identifier: x4 };
    if (s2 === "info.json") {
      let [, ...E4] = n2;
      return { type: "info", scheme: o4, server: r3, prefix: a3, identifier: E4.reverse().filter(Boolean).join("/") };
    }
    if (typeof o4 > "u" || typeof r3 > "u" || typeof t4 > "u" || typeof l4 > "u" || typeof p4 > "u" || typeof f5 > "u" || typeof s2 > "u")
      throw new Error("Invalid image service URL");
    let [M3 = "", T3 = ""] = s2.split(".");
    return { type: "image", scheme: o4, server: r3, prefix: a3, identifier: x4, originalPath: t4, region: A2(l4), size: P2(p4), rotation: $(f5), quality: M3, format: T3 };
  }
  function b2(i3) {
    return R.indexOf(i3) !== -1 ? j : C.indexOf(i3) !== -1 ? b : z;
  }
  function h2(i3) {
    let e3 = i3 ? Array.isArray(i3.profile) ? i3.profile : [i3.profile] : [], t4 = { extraQualities: [], extraFormats: [], extraFeatures: [] };
    for (let o4 of e3)
      if (typeof o4 == "string" && (o4 = b2(o4)), !!o4) {
        if (o4.formats)
          for (let r3 of o4.formats)
            t4.extraFormats.indexOf(r3) === -1 && t4.extraFormats.push(r3);
        if (o4.qualities)
          for (let r3 of o4.qualities)
            t4.extraQualities.indexOf(r3) === -1 && t4.extraQualities.push(r3);
        if (o4.supports)
          for (let r3 of o4.supports)
            t4.extraFeatures.indexOf(r3) === -1 && t4.extraFeatures.push(r3);
        if (o4.maxHeight && (t4.maxHeight = o4.maxHeight), o4.maxWidth && (t4.maxWidth = o4.maxWidth), o4.maxArea && (t4.maxArea = o4.maxArea), o4.extraFormats)
          for (let r3 of o4.extraFormats)
            t4.extraFormats.indexOf(r3) === -1 && t4.extraFormats.push(r3);
        if (o4.extraQualities)
          for (let r3 of o4.extraQualities)
            t4.extraQualities.indexOf(r3) === -1 && t4.extraQualities.push(r3);
        if (o4.extraFeatures)
          for (let r3 of o4.extraFeatures)
            t4.extraFeatures.indexOf(r3) === -1 && t4.extraFeatures.push(r3);
        o4.maxHeight && (t4.maxHeight = o4.maxHeight), o4.maxWidth && (t4.maxWidth = o4.maxWidth), o4.maxArea && (t4.maxArea = o4.maxArea);
      }
    if (i3.extraFormats)
      for (let o4 of i3.extraFormats)
        t4.extraFormats.indexOf(o4) === -1 && t4.extraFormats.push(o4);
    if (i3.extraFeatures)
      for (let o4 of i3.extraFeatures)
        t4.extraFeatures.indexOf(o4) === -1 && t4.extraFeatures.push(o4);
    if (i3.extraQualities)
      for (let o4 of i3.extraQualities)
        t4.extraQualities.indexOf(o4) === -1 && t4.extraQualities.push(o4);
    return t4;
  }
  function Qe(i3) {
    let e3 = Array.isArray(i3.profile) ? i3.profile : [i3.profile];
    for (let t4 of e3)
      if (typeof t4 == "string" && S.indexOf(t4) !== -1)
        return true;
    return false;
  }
  function W(i3) {
    if (i3["@id"])
      return i3["@id"];
    if (i3.id)
      return i3.id;
  }
  function m2(i3) {
    if (!i3 || !i3.profile || !W(i3))
      return false;
    let e3 = Array.isArray(i3.profile) ? i3.profile : [i3.profile];
    for (let t4 of e3)
      if (typeof t4 == "string" && B.indexOf(t4) !== -1)
        return true;
    return false;
  }
  function Ke(i3) {
    if (!m2(i3))
      return false;
    let e3 = Array.isArray(i3.profile) ? i3.profile : [i3.profile];
    for (let t4 of e3)
      if (typeof t4 == "string") {
        if (C.indexOf(t4) !== -1)
          return true;
      } else {
        let o4 = [...t4.supports || [], ...t4.extraFeatures || []];
        if (o4.indexOf("regionByPx") !== -1 && (o4.indexOf("sizeByW") !== -1 || o4.indexOf("sizeByWh") !== -1))
          return true;
      }
    return false;
  }
  function B2({ x: i3 = 0, y: e3 = 0, w: t4, h: o4, full: r3, square: a3, percent: n2 }) {
    if (r3)
      return "full";
    if (a3)
      return "square";
    if (typeof t4 > "u" || typeof o4 > "u")
      throw new Error("RegionParameter: invalid region");
    let s2 = `${i3},${e3},${t4},${o4}`;
    return n2 ? `pct:${s2}` : s2;
  }
  function j2({ max: i3, percentScale: e3, upscaled: t4, confined: o4, width: r3, height: a3, serialiseAsFull: n2, version: s2 }) {
    let f5 = [];
    return t4 && f5.push("^"), i3 ? (f5.push(n2 ? "full" : "max"), f5.join("")) : (o4 && f5.push("!"), e3 && f5.push(`pct:${e3}`), r3 && f5.push(`${r3}`), f5.push(","), a3 && s2 === 3 && f5.push(`${a3}`), f5.join(""));
  }
  function Q(i3) {
    return `${i3.mirror ? "!" : ""}${(i3.angle || 0) % 360}`;
  }
  function H(i3, e3) {
    let t4 = i3.prefix.startsWith("/") ? i3.prefix.substring(1) : i3.prefix, o4 = `${i3.scheme}://${i3.server}/${t4 ? `${t4}/` : ""}${i3.identifier}`;
    if (i3.type === "base")
      return o4;
    if (i3.type === "info")
      return `${o4}/info.json`;
    let { size: r3 } = i3, { region: a3, rotation: n2, format: s2, quality: f5 } = i3;
    if (e3) {
      let p4 = e3["@context"] ? Array.isArray(e3["@context"]) ? e3["@context"] : [e3["@context"]] : [], l4 = p4.indexOf("http://iiif.io/api/image/2/context.json") !== -1, y4 = p4.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
      if ((r3.width === e3.width && !r3.height || r3.height === e3.height && !r3.width || r3.width === e3.width && r3.height === e3.height) && (r3 = { ...r3, max: true }), l4 && (r3.max && !r3.serialiseAsFull && (r3 = { ...r3, serialiseAsFull: true }), !r3.max && r3.width && r3.height && (r3 = { ...r3, height: void 0 }), r3 = { ...r3, version: 2 }), y4) {
        if (r3.max && r3.serialiseAsFull && (r3 = { ...r3, serialiseAsFull: false }), r3.width && !r3.height && e3.width && e3.height) {
          let x4 = e3.height / e3.width;
          r3 = { ...r3, height: Math.ceil(r3.width * x4) };
        }
        r3 = { ...r3, version: 3 };
      }
    }
    return [o4, B2(a3), j2(r3), Q(n2), `${f5}.${s2}`].filter(Boolean).join("/");
  }
  function L2(i3) {
    return i3.endsWith("info.json") ? i3 : i3.endsWith("/") ? `${i3}info.json` : `${i3}/info.json`;
  }
  function hi(i3) {
    let e3 = O2(L2(i3.id));
    if (e3.type !== "info")
      throw new Error("Invalid service URL");
    let t4 = h2(i3);
    return { identifier: e3.identifier, originalPath: "", server: e3.server, prefix: e3.prefix, scheme: e3.scheme, type: "image", quality: t4.extraQualities.indexOf("default") === -1 ? t4.extraQualities[0] : "default", region: { full: true }, size: { max: true, upscaled: false, confined: false }, format: "jpg", rotation: { angle: 0 } };
  }
  function Si(i3, e3, t4) {
    let o4 = t4.length, r3 = [];
    for (let a3 = 0; a3 < o4; a3++) {
      let n2 = t4[a3];
      if (!n2)
        continue;
      let s2 = n2.width;
      r3.push(i3 / s2);
    }
    return r3;
  }
  function zi(i3, e3, t4) {
    let o4 = t4.length, r3 = [];
    for (let a3 = 0; a3 < o4; a3++) {
      let n2 = t4[a3];
      n2 && r3.push({ width: Math.floor(i3 / n2), height: Math.floor(e3 / n2) });
    }
    return r3;
  }
  function S2(i3, e3) {
    if (e3 && e3.profile) {
      let t4 = e3.profile;
      if (t4) {
        let o4 = Array.isArray(t4) ? t4 : [t4];
        if (o4.includes(`level${i3}`) || o4.includes(`http://iiif.io/api/image/2/level${i3}.json`) || o4.includes(`http://iiif.io/api/image/1/level${i3}.json`) || o4.includes(`http://iiif.io/api/image/1/profiles/level${i3}.json`))
          return true;
        if (i3 === 2) {
          for (let r3 of o4)
            if (R.includes(r3))
              return true;
        }
        if (i3 === 1) {
          for (let r3 of o4)
            if (C.includes(r3))
              return true;
        }
        if (i3 === 0) {
          for (let r3 of o4)
            if (S.includes(r3))
              return true;
        }
      }
    }
    return false;
  }
  function Pi(i3) {
    return m2(i3) ? S2(0, i3) ? 0 : S2(1, i3) ? 1 : S2(2, i3) ? 2 : null : null;
  }
  function Oi(i3) {
    let e3 = i3.service ? Array.isArray(i3.service) ? i3.service : [i3.service] : [], t4 = e3.length, o4 = [];
    for (let r3 = 0; r3 < t4; r3++)
      m2(e3[r3]) && o4.push(e3[r3]);
    return o4;
  }
  function Wi(i3) {
    if (i3["@type"])
      return i3["@type"];
    if (i3.type)
      return i3.type;
  }

  // src/image-service/get-image-server-from-id.ts
  function getImageServerFromId(url) {
    const id = url.replace(/(https?:\/\/)?(www.)?/i, "");
    if (id.indexOf("/") !== -1) {
      return id.split("/")[0];
    }
    return id;
  }

  // src/image-service/sampled-tiles-to-tiles.ts
  function sampledTilesToTiles(width, height, sampledTiles) {
    const maxDim = width > height ? width : height;
    const len = sampledTiles.length;
    const newTiles = [];
    for (let i3 = 0; i3 < len; i3++) {
      const tile = sampledTiles[i3];
      if (!tile)
        continue;
      if (tile.scaleFactors.length === 0)
        continue;
      let lastSize = tile.scaleFactors[0];
      if (!lastSize)
        continue;
      let curWidth = maxDim / lastSize;
      const scaleFactors = [lastSize];
      while (curWidth >= tile.width) {
        lastSize = lastSize * 2;
        scaleFactors.push(lastSize);
        curWidth = curWidth / 2;
      }
      newTiles.push({
        ...tile,
        scaleFactors
      });
    }
    return newTiles;
  }

  // src/image-service/get-image-from-tile-source.ts
  function getImageFromTileSource(image, targetWidth, targetHeight) {
    const req = hi({
      "@context": image.version === 3 ? "http://iiif.io/api/image/3/context.json" : "http://iiif.io/api/image/2/context.json",
      id: L2(W(image)),
      profile: image.level === null || typeof image.level === "undefined" ? "level0" : `level${image.level}`,
      type: image.version === 3 ? "ImageService3" : "ImageService2"
    });
    if (req.type !== "image") {
      throw new Error("Invalid service");
    }
    req.size.max = false;
    req.size.width = targetWidth;
    req.size.height = targetHeight;
    const url = H(req);
    return {
      id: url,
      type: "fixed",
      width: targetWidth,
      height: targetHeight || image.height / (image.width || 1) * targetWidth,
      unsafe: image.width > targetWidth
    };
  }

  // src/image-service/is-best-match.ts
  function isBestMatch(request, current, candidate) {
    const width = !request.width ? request.maxWidth : request.width;
    return candidate.height <= request.maxHeight && candidate.width <= request.maxWidth && candidate.height >= request.minHeight && candidate.width >= request.minWidth && (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width));
  }

  // src/image-service/pick-best-from-candidates.ts
  function pickBestFromCandidates(inputRequest, candidates) {
    const log = [];
    const request = Object.assign(
      {
        unsafeImageService: false,
        atAnyCost: true,
        fallback: true,
        minHeight: 64,
        minWidth: 64,
        maxHeight: Infinity,
        maxWidth: Infinity,
        returnAllOptions: false,
        preferFixedSize: false,
        allowUnsafe: false,
        explain: false,
        height: 0,
        width: 0
      },
      inputRequest
    );
    const explain = (text, indent = 0) => request.explain ? log.push(
      new Array(indent).fill(0).map((e3) => "    ").join("") + text().trim()
    ) : void 0;
    const lastResorts = [];
    const fallback = [];
    let currentChoice = null;
    explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);
    const swapChoice = (candidate, current) => {
      explain(() => "Swapping choice", 3);
      if (isBestMatch(request, current, candidate)) {
        if (request.preferFixedSize && candidate.unsafe) {
          explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);
          fallback.push(candidate);
          return;
        }
        if (request.returnAllOptions && current) {
          fallback.push(current);
        }
        explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);
        currentChoice = candidate;
      } else if (request.returnAllOptions) {
        fallback.push(candidate);
      }
    };
    explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);
    const candidateGroups = candidates.length;
    for (let x4 = 0; x4 < candidateGroups; x4++) {
      const group = candidates[x4]();
      explain(() => `Candidate group ${x4}: ${JSON.stringify(group, null, 2)}`, 1);
      const candidatesLength = group.length;
      explain(
        () => `Checking candidate list number ${x4} and found ${candidatesLength} potential ways of creating image(s)`,
        1
      );
      for (let y4 = 0; y4 < candidatesLength; y4++) {
        const candidate = group[y4];
        explain(() => `-> Checking candidate ${y4}`, 1);
        if (candidate.type === "unknown" && request.atAnyCost) {
          explain(() => `We've found an unknown image type, adding this to the "last resort" list`, 2);
          lastResorts.push(candidate);
        }
        if (candidate.type === "fixed") {
          if (candidate.unsafe) {
            explain(() => `We've found an unsafe fixed image type, adding this to the "last resort" list`, 2);
            lastResorts.push(candidate);
          } else {
            explain(() => `We've found a fixed size image, checking if it matches the request`, 2);
            swapChoice(candidate, currentChoice);
          }
        }
        if (candidate.type === "fixed-service") {
          if (request.unsafeImageService) {
            explain(
              () => `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,
              2
            );
            const choice = getImageFromTileSource(candidate, request.width, request.height);
            swapChoice(choice, currentChoice);
          } else {
            explain(() => `Checking for an image from the tile source 3`, 2);
            const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);
            swapChoice(choice, currentChoice);
          }
        }
        if (candidate.type === "variable") {
          if (candidate.maxWidth) {
            const choice = getImageFromTileSource(
              {
                id: candidate.id,
                type: "fixed-service",
                width: candidate.maxWidth,
                height: candidate.maxWidth,
                level: candidate.level,
                version: candidate.version
              },
              candidate.maxWidth
            );
            swapChoice(choice, currentChoice);
          }
        }
      }
      if (currentChoice && !request.returnAllOptions) {
        if (currentChoice.unsafe || request.allowUnsafe) {
          continue;
        }
        explain(() => `We found a match in choice list number ${x4}, no searching any more`);
        break;
      }
    }
    if (request.atAnyCost && fallback.length === 0) {
      explain(
        () => currentChoice ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}` : `We found no images, but "atAnyCost" is set, so returning that`
      );
      return {
        best: currentChoice || lastResorts[0] || null,
        fallback: lastResorts.slice(1),
        log
      };
    }
    if (request.returnAllOptions) {
      explain(() => `Returning all options that we have found`);
      return {
        best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,
        fallback: [...fallback, ...lastResorts],
        log
      };
    }
    explain(() => `Returning the best image that we found, and a fallback`);
    return {
      best: currentChoice || fallback[0] || null,
      fallback: currentChoice ? fallback : fallback.slice(1),
      log
    };
  }

  // src/image-service/is-image-3.ts
  function isImage3(service) {
    const context = service["@context"] ? Array.isArray(service["@context"]) ? service["@context"] : [service["@context"]] : [];
    return context.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
  }

  // src/image-service/get-fixed-sizes-from-service.ts
  function getFixedSizesFromService(service) {
    if (!m2(service)) {
      return [];
    }
    return (service && service.sizes ? service.sizes : []).map((size) => {
      return {
        id: W(service),
        type: "fixed-service",
        height: size.height,
        width: size.width,
        level: Pi(service),
        version: isImage3(service) ? 3 : 2
      };
    });
  }

  // src/image-service/get-custom-size-from-service.ts
  function getCustomSizeFromService(service) {
    if (!Ke(service)) {
      return [];
    }
    const imagesSizes = [];
    const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];
    const pLen = profiles.length;
    for (let x4 = 0; x4 < pLen; x4++) {
      const profile = profiles[x4];
      if (profile && typeof profile !== "string") {
        if (profile.maxHeight || profile.maxWidth) {
          return [
            {
              id: W(service),
              type: "variable",
              minWidth: 0,
              minHeight: 0,
              maxHeight: profile.maxHeight || profile.maxWidth,
              maxWidth: profile.maxWidth || profile.maxHeight,
              level: Pi(service),
              version: service["@context"] === "http://iiif.io/api/image/3/context.json" ? 3 : 2
            }
          ];
        }
      }
    }
    if (service.tiles) {
      const len = service.tiles.length;
      for (let y4 = 0; y4 < len; y4++) {
        const tile = service.tiles[y4];
        if (tile && (tile.height || tile.width)) {
          imagesSizes.push({
            id: W(service),
            type: "variable",
            minHeight: 0,
            minWidth: 0,
            maxHeight: tile.height || tile.width,
            maxWidth: tile.width,
            level: Pi(service),
            version: isImage3(service) ? 3 : 2
          });
        }
      }
    }
    return imagesSizes;
  }

  // src/image-service/get-image-candidates-from-service.ts
  function getImageCandidatesFromService(service) {
    const candidates = [];
    const totalServices = service.length;
    for (let s2 = 0; s2 < totalServices; s2++) {
      const single = service[s2];
      if (!single)
        continue;
      const fixedSizes = getFixedSizesFromService(single);
      if (fixedSizes.length) {
        candidates.push(...fixedSizes);
      }
      const customSizes = getCustomSizeFromService(single);
      if (customSizes.length) {
        candidates.push(...customSizes);
      }
    }
    return candidates;
  }

  // src/image-service/infer-size-from-url.ts
  function inferImageSizeFromUrl(image) {
    const regex = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/;
    const match = image.match(regex);
    if (match && match[4] && match[5]) {
      const region = match[1];
      const width = parseInt(match[4], 10);
      const height = parseInt(match[5], 10);
      const format = match[7];
      if ((region === "max" || region === "full") && width && height && format) {
        return {
          type: "fixed",
          id: image,
          height,
          width
        };
      }
    }
    return { type: "unknown", id: image };
  }

  // src/image-service/get-fixed-size-from-image.ts
  function getFixedSizeFromImage(contentResource) {
    if (typeof contentResource === "string") {
      return inferImageSizeFromUrl(contentResource);
    }
    const type = Wi(contentResource);
    if (type !== "Image" && type !== "sc:Image") {
      return null;
    }
    const image = contentResource;
    const id = W(image);
    if (!id) {
      return null;
    }
    if (id && image.width && image.height) {
      return {
        id,
        type: "fixed",
        width: image.width,
        height: image.height,
        unsafe: true
      };
    }
    return inferImageSizeFromUrl(id);
  }

  // src/image-service/get-image-candidates.ts
  function getImageCandidates(unknownResource, dereference = true, loader) {
    const candidates = [];
    const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);
    if (fixedSizeFromImage === null) {
      return candidates;
    }
    const resource = unknownResource;
    candidates.push(fixedSizeFromImage);
    if (dereference && resource && resource.width && resource.height) {
      const refCandidates = [];
      const imageServices2 = Oi(resource);
      for (const service of imageServices2) {
        const request = {
          id: W(service),
          width: resource.width,
          height: resource.height
        };
        if (loader.canLoadSync(request)) {
          const externalService = loader.loadServiceSync(request);
          if (externalService) {
            if (!externalService.height) {
              externalService.height = resource.height;
            }
            if (!externalService.width) {
              externalService.width = resource.width;
            }
            refCandidates.push(...getImageCandidatesFromService([externalService]));
          }
        }
      }
      if (refCandidates.length) {
        candidates.push(...refCandidates);
        return candidates;
      }
    }
    if (resource.service) {
      candidates.push(...getImageCandidatesFromService(resource.service));
    }
    return candidates;
  }

  // src/image-service/image-sizes-match.ts
  function imageSizesMatch(sizesA, sizesB) {
    if (sizesA.length !== sizesB.length) {
      return false;
    }
    if (sizesA.length === 0 && sizesB.length === 0) {
      return true;
    }
    const len = sizesA.length;
    let matchOrder = true;
    for (let i3 = 0; i3 < len; i3++) {
      const a3 = sizesA[i3];
      const b5 = sizesB[i3];
      if (a3.width !== b5.width || a3.height !== b5.height) {
        matchOrder = false;
        break;
      }
    }
    if (matchOrder) {
      return true;
    }
    let matching = 0;
    for (let a3 = 0; a3 < len; a3++) {
      for (let b5 = 0; b5 < len; b5++) {
        if (sizesA[a3].width === sizesB[b5].width && sizesA[a3].height === sizesB[b5].height) {
          matching++;
          break;
        }
      }
    }
    return matching === len;
  }

  // src/image-service/image-service-loader.ts
  var ImageServiceLoader = class {
    constructor(options = {}) {
      __publicField(this, "config", {
        verificationsRequired: 1,
        approximateServices: false,
        enableFetching: true,
        disableThrottling: false
      });
      __publicField(this, "fetchingCount", 0);
      __publicField(this, "imageServices", {});
      __publicField(this, "knownImageServers", {});
      this.config = Object.assign(this.config, options);
    }
    /**
     * Preload image service
     *
     * This will preload an image service, fetching details and recording the image server that served
     * the request. Based on this it will make a template for predicting other image sources from this
     * server. You can optionally pass in other ids to verify that the prediction is accurate.
     *
     */
    // async preload(id: string, verify?: string[]): Promise<void> {}
    setConfig(config) {
      Object.assign(this.config, config);
    }
    /**
     * Sample pre-fetched service
     *
     * If you have already fetched an image service, or are creating a viewer that only talks to a single
     * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
     * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
     *
     * @param service
     * @param preLoaded Mark this as being pre-loaded (default: true)
     */
    sample(service, imageServiceRequest, preLoaded = true) {
      const server = getImageServerFromId(W(service));
      const serviceUrl = L2(W(service));
      const existing = this.knownImageServers[server];
      this.imageServices[serviceUrl] = Object.assign(service, { real: true });
      if (!existing && service.tiles && !Qe(service)) {
        this.knownImageServers[server] = {
          verifications: 0,
          malformed: false,
          root: server,
          preLoaded,
          sampledId: W(service),
          verified: false,
          server: null,
          result: {
            context: service["@context"] || [],
            sampledProfile: service.profile,
            resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,
            sampledSizes: service.sizes || [],
            sizeRatios: Si(service.width, service.height, service.sizes || []),
            sampledTiles: service.tiles || []
          }
        };
        return true;
      }
      return this.verify(service);
    }
    /**
     * Preload an image server
     *
     * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
     * allowing you to correct mistakes this implementation might have made.
     *
     * @param server
     * @param forceVerify
     */
    preLoad(server, forceVerify = true) {
      this.knownImageServers[server.root] = server;
      if (forceVerify) {
        this.knownImageServers[server.root].malformed = false;
        this.knownImageServers[server.root].verifications = this.config.verificationsRequired;
      }
    }
    /**
     * Predict
     *
     * Predicts what the image service will be for a content resource.
     *
     * @param resource
     * @param verify
     * @param force
     */
    predict(resource, verify = false, force = false) {
      const source = resource?.source;
      const serverId = getImageServerFromId(W(resource));
      const imageServer = this.knownImageServers[serverId];
      const serviceUrl = L2(W(resource));
      if (this.imageServices[serviceUrl]) {
        return this.imageServices[serviceUrl] || null;
      }
      if (!this.config.approximateServices) {
        return null;
      }
      if (!imageServer || !imageServer.result || !(source?.height || resource.height) || !(source?.width || resource.width) || !force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired) || resource.source && Qe(resource.source)) {
        return null;
      }
      if (!this.imageServices[serviceUrl]) {
        this.imageServices[serviceUrl] = {
          "@context": imageServer.result.context,
          "@id": W(resource),
          id: W(resource),
          protocol: "http://iiif.io/api/image",
          tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),
          sizes: source?.sizes || zi(
            Math.round(resource.width / imageServer.result.resourceServiceRatio),
            Math.round(resource.height / imageServer.result.resourceServiceRatio),
            imageServer.result.sizeRatios
          ),
          profile: source?.profile || imageServer.result.sampledProfile,
          height: source?.height || resource.height,
          width: source?.width || resource.width,
          real: false
        };
      }
      return this.imageServices[serviceUrl] || null;
    }
    async getThumbnailFromResource(unknownResource, request, dereference = true, otherCandidates = []) {
      const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];
      return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);
    }
    async getImageCandidates(unknownResource, dereference = true) {
      const resource = unknownResource;
      if (dereference && resource && resource.height && resource.width) {
        const imageServices2 = Oi(resource);
        for (const service of imageServices2) {
          const request = {
            id: W(service),
            width: service.width ? service.width : resource.width,
            height: service.height ? service.height : resource.height,
            source: service
          };
          await this.loadService(request);
        }
      }
      return getImageCandidates(unknownResource, dereference, this);
    }
    /**
     * Verify approximation
     *
     * Given an image service, it will dereference that image service and compare the result with what
     * would have been generated if we used internal guessing.
     *
     * @param resource
     * @return Promise<boolean>
     */
    async verify(resource) {
      const prediction = this.predict(resource, false, true);
      const imageService = await this.fetchService(W(resource));
      if (!prediction) {
        return false;
      }
      const isValid = prediction.height === imageService.height && prediction.width === imageService.width && prediction["@context"] === imageService["@context"] && imageSizesMatch(prediction.sizes || [], imageService.sizes || []);
      if (isValid) {
        const serverId = getImageServerFromId(W(resource));
        const server = this.knownImageServers[serverId];
        if (server) {
          server.verifications += 1;
          if (server.verifications >= this.config.verificationsRequired) {
            server.verified = true;
          }
        }
      }
      return isValid;
    }
    canLoadSync(service) {
      const serviceId = typeof service === "string" ? service : W(service);
      const canonical = L2(serviceId);
      if (this.imageServices[canonical]) {
        return true;
      }
      const server = this.knownImageServers[getImageServerFromId(serviceId)];
      return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);
    }
    /**
     * Mark image service as malformed
     *
     * If you run into issues requesting images, you can mark an image service as malformed, and it will
     * return you a new one. Future image services will also be requested fresh, and the system will have
     * failed. Report a bug if this happens.
     *
     * @param resource
     */
    async markAsMalformed(resource) {
      this.knownImageServers[getImageServerFromId(W(resource))].malformed = true;
      return this.loadService(resource, true);
    }
    /**
     * Fetch an image service (use loadService instead)
     *
     * @param serviceId
     * @param forceFresh
     */
    async fetchService(serviceId, forceFresh = false) {
      const serviceUrl = L2(serviceId);
      const service = this.imageServices[serviceUrl];
      if (service && (!forceFresh || service.real)) {
        return service;
      }
      if (!this.config.enableFetching) {
        throw new Error("Fetching is not enabled");
      }
      const json = await this.fetch(serviceUrl).then((service2) => service2.json());
      if (!json.id && json["@id"]) {
        json.id = json["@id"];
      }
      if (json.id !== serviceId) {
        json.id = serviceId;
        if (json["@id"]) {
          json["@id"] = serviceId;
        }
      }
      this.imageServices[serviceUrl] = Object.assign(json, { real: true });
      return this.imageServices[serviceUrl];
    }
    async fetch(input, init) {
      return fetch(input, init);
    }
    /**
     * Load an image service
     *
     * @param resource
     * @param forceFresh
     *
     * @todo make this batched, so only the maximum required can be done at once, to allow
     *       for the prediction engine to kick in.
     */
    async loadService(resource, forceFresh = false) {
      if (!this.config.disableThrottling) {
        let running = true;
        while (running) {
          if (this.fetchingCount >= this.config.verificationsRequired) {
            await new Promise((resolve) => setTimeout(resolve, 500));
          } else {
            running = false;
            break;
          }
        }
      }
      const imageServer = this.knownImageServers[getImageServerFromId(W(resource))];
      if (imageServer && !imageServer.malformed && !forceFresh) {
        await imageServer.result;
        const service = this.loadServiceSync(resource);
        if (service) {
          return service;
        }
      }
      this.fetchingCount++;
      const serviceJson = await this.fetchService(W(resource), forceFresh);
      this.fetchingCount--;
      if (serviceJson.real) {
        this.sample(serviceJson, resource);
      }
      return serviceJson;
    }
    /**
     * Load service synchronously
     *
     * If you know that the image service you are
     * @param resource
     */
    loadServiceSync(resource) {
      const serviceId = L2(W(resource));
      if (this.imageServices[serviceId]) {
        return this.imageServices[serviceId];
      }
      if (!this.config.approximateServices) {
        return null;
      }
      return this.predict(resource);
    }
  };

  // node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, getInitialState, subscribe, destroy };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
  function mitt_default(n2) {
    return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t4, e3) {
      var i3 = n2.get(t4);
      i3 ? i3.push(e3) : n2.set(t4, [e3]);
    }, off: function(t4, e3) {
      var i3 = n2.get(t4);
      i3 && (e3 ? i3.splice(i3.indexOf(e3) >>> 0, 1) : n2.set(t4, []));
    }, emit: function(t4, e3) {
      var i3 = n2.get(t4);
      i3 && i3.slice().map(function(n3) {
        n3(e3);
      }), (i3 = n2.get("*")) && i3.slice().map(function(n3) {
        n3(t4, e3);
      });
    } };
  }

  // src/image-service/image-service-store.ts
  function createImageServiceStore(options = {}) {
    const events = options.events || mitt_default();
    const loader = options.loader || new ImageServiceLoader();
    const store = createStore((set, get) => ({
      loaded: {},
      loadServiceSync: (service, detail, backgroundRequest) => {
        const id = service.id || service["@id"];
        const existing = get().loaded[id];
        if (existing && existing.status === "done") {
          return existing.service;
        }
        if (existing && existing.status === "loading") {
          return null;
        }
        if (existing && existing.status === "error") {
          throw new Error("Failed to load image service");
        }
        const request = {
          id: W(service),
          width: service.width || detail?.width || 0,
          height: service.height || detail?.height || 0,
          source: service
        };
        const loaded = loader.loadServiceSync(request);
        if (loaded) {
          set((state) => ({
            loaded: {
              ...state.loaded,
              [id]: {
                status: "done",
                service: loaded,
                real: true
              }
            }
          }));
          events.emit("image-service.loaded", { id, service: loaded });
        } else {
          if (backgroundRequest) {
            get().loadService(service, detail).then(() => {
            });
          }
        }
        return loaded;
      },
      loadService: async (service, detail) => {
        const id = service.id || service["@id"];
        const existing = get().loaded[id];
        if (existing && existing.status === "done") {
          return existing.service;
        }
        if (existing && existing.status === "loading") {
          return new Promise((resolve, reject) => {
            const handler = (e3) => {
              if (e3.id === id) {
                events.off("image-service.loaded", handler);
                resolve(e3.service || service);
              }
            };
            events.on("image-service.loaded", handler);
          });
        }
        if (existing && existing.status === "error" && !detail?.force) {
          throw new Error("Failed to load image service");
        }
        events.emit("image-service.loading", { id });
        try {
          const request = {
            id: W(service),
            width: service.width || 0,
            height: service.height || 0,
            source: service
          };
          const loaded = await loader.loadService(request, detail?.force);
          set((state) => ({
            loaded: {
              ...state.loaded,
              [id]: {
                status: "done",
                service: loaded,
                real: loaded.real
              }
            }
          }));
          events.emit("image-service.loaded", { id, service: loaded });
          return loaded;
        } catch (error) {
          events.emit("image-service.error", { id, error });
          throw error;
        }
      }
    }));
    return {
      store,
      events
    };
  }
  var imageServices = createImageServiceStore();

  // src/image-service/get-smallest-scale-factor-as-single-image.ts
  function getSmallestScaleFactorAsSingleImage(service) {
    if (!service.width || !service.height) {
      return null;
    }
    if (service.tiles) {
      const tiles = service.tiles.sort((a3, b5) => {
        return Math.max(...b5.scaleFactors) - Math.max(...a3.scaleFactors);
      });
      const len = tiles.length;
      for (let i3 = 0; i3 < len; i3++) {
        const tile = tiles[i3];
        if (!tile)
          continue;
        const targetSize = tile.width;
        if (!targetSize) {
          continue;
        }
        const sizeLen = tile.scaleFactors.length;
        const sortedScales = tile.scaleFactors.sort();
        for (let j5 = 0; j5 < sizeLen; j5++) {
          const size = sortedScales[j5];
          if (!size)
            continue;
          if (service.width / size <= targetSize && service.height / size <= targetSize) {
            return {
              id: W(service),
              type: "fixed-service",
              width: service.width / size | 0,
              height: service.height / size | 0,
              level: Pi(service),
              version: isImage3(service) ? 3 : 2
            };
          }
        }
      }
    }
    return null;
  }

  // src/thumbnail.ts
  var imageServiceLoader = new ImageServiceLoader();
  var helpers = /* @__PURE__ */ new Map();
  function getThumbnail(input, {
    vault = compatVault,
    dereference = false,
    ...options
  } = {}) {
    let helper = helpers.get(vault);
    if (!helper) {
      helper = createThumbnailHelper(vault);
      helpers.set(vault, helper);
    }
    return helper.getBestThumbnailAtSize(input, options, dereference);
  }
  function createThumbnailHelper(vault = compatVault, dependencies = {}) {
    const loader = dependencies.imageServiceLoader || imageServiceLoader;
    async function getBestThumbnailAtSize(input, request, dereference = false, candidates = [], dimensions) {
      const thumbnailNotFound = () => loader.getThumbnailFromResource(void 0, request, dereference, candidates);
      if (!input) {
        return await loader.getThumbnailFromResource(void 0, request, dereference, candidates);
      }
      if (typeof input === "string") {
        const fixed = getFixedSizeFromImage(input);
        if (fixed) {
          candidates.push(fixed);
        }
        return await loader.getThumbnailFromResource(void 0, request, dereference, candidates);
      }
      const fullInput = vault.get(input, { skipSelfReturn: false });
      if (typeof fullInput === "string") {
        return { best: getFixedSizeFromImage(fullInput), fallback: [], log: [] };
      }
      if (!fullInput) {
        return await thumbnailNotFound();
      }
      const parseThumbnail = async (resource) => {
        if (resource && resource.thumbnail && resource.thumbnail.length) {
          const thumbnail = vault.get(resource.thumbnail[0]);
          const potentialThumbnails = await loader.getImageCandidates(thumbnail, dereference);
          if (potentialThumbnails && potentialThumbnails.length) {
            candidates.push(...potentialThumbnails);
          }
        }
      };
      await parseThumbnail(fullInput);
      switch (fullInput.type) {
        case "Annotation": {
          const contentResources = Array.isArray(fullInput.body) ? fullInput.body : [fullInput.body];
          const firstContentResources = vault.get(contentResources[0]);
          if (dimensions && !firstContentResources.width) {
            firstContentResources.width = dimensions.width;
            firstContentResources.height = dimensions.height;
          }
          return await loader.getThumbnailFromResource(firstContentResources, request, dereference, candidates);
        }
        case "Canvas": {
          const canvas = fullInput;
          return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
            width: canvas.width,
            height: canvas.height
          });
        }
        case "AnnotationPage": {
          const annotationPage = fullInput;
          return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
        }
        case "Choice": {
          const choice = fullInput;
          if (!choice.items || choice.items[0]) {
            return await thumbnailNotFound();
          }
          return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
        }
        case "Collection": {
          const collection = fullInput;
          const firstManifest = collection.items[0];
          if (!firstManifest) {
            return await thumbnailNotFound();
          }
          return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
        }
        case "Manifest": {
          const manifest = fullInput;
          const firstCanvas = manifest.items[0];
          if (!firstCanvas) {
            return await thumbnailNotFound();
          }
          return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
        }
        case "SpecificResource":
        case "Image":
        case "Dataset":
        case "Sound":
        case "Text":
        case "TextualBody":
        case "Video":
          if (dimensions && !fullInput.width) {
            fullInput.width = dimensions.width;
            fullInput.height = dimensions.height;
          }
          return loader.getThumbnailFromResource(fullInput, request, dereference, candidates);
      }
      return await thumbnailNotFound();
    }
    return {
      getBestThumbnailAtSize
    };
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-NJNTZ6QT.js
  function r2(e3) {
    for (let n2 in e3)
      (typeof e3[n2] > "u" || e3[n2] === null) && delete e3[n2];
    return e3;
  }
  function i2(e3) {
    return Array.isArray(e3) ? e3 : e3 ? [e3] : [];
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-RCT3CZAV.js
  var P3 = ["sc:Collection", "sc:Manifest", "sc:Canvas", "sc:AnnotationList", "oa:Annotation", "sc:Range", "sc:Layer", "sc:Sequence", "oa:Choice", "Service", "ContentResource"];
  function S3(t4) {
    if (typeof t4 > "u" || t4 === null)
      throw new Error("Null or undefined is not a valid entity.");
    if (Array.isArray(t4))
      throw new Error("Array is not a valid entity");
    if (typeof t4 != "object")
      throw new Error(`${typeof t4} is not a valid entity`);
    if (typeof t4["@type"] == "string") {
      let e3 = P3.indexOf(t4["@type"]);
      if (e3 !== -1)
        return P3[e3];
    }
    if (t4.profile)
      return "Service";
    if (t4.format || t4["@type"])
      return "ContentResource";
    throw new Error("Resource type is not known");
  }
  var h3 = class t2 {
    constructor(e3, n2 = {}) {
      f2(this, "traversals");
      f2(this, "options");
      this.traversals = { collection: [], manifest: [], canvas: [], annotationList: [], sequence: [], annotation: [], contentResource: [], choice: [], range: [], service: [], layer: [], ...e3 }, this.options = { convertPropsToArray: true, mergeMemberProperties: true, allowUndefinedReturn: false, ...n2 };
    }
    static all(e3) {
      return new t2({ collection: [e3], manifest: [e3], canvas: [e3], annotationList: [e3], sequence: [e3], annotation: [e3], contentResource: [e3], choice: [e3], range: [e3], service: [e3], layer: [e3] });
    }
    traverseCollection(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseCollectionItems(e3))), this.traversals.collection);
    }
    traverseCollectionItems(e3) {
      if (this.options.mergeMemberProperties) {
        let n2 = [...(e3.manifests || []).map((r3) => typeof r3 == "string" ? { "@id": r3, "@type": "sc:Manifest" } : r3), ...(e3.collections || []).map((r3) => typeof r3 == "string" ? { "@id": r3, "@type": "sc:Collection" } : r3), ...e3.members || []], i3 = [], a3 = n2.filter((r3) => i3.includes(r3["@id"]) ? false : (i3.push(r3["@id"]), true));
        delete e3.collections, delete e3.manifests, e3.members = a3;
      }
      return e3.manifests && (e3.manifests = e3.manifests.map((n2) => this.traverseManifest(typeof n2 == "string" ? { "@id": n2, "@type": "sc:Manifest" } : n2))), e3.collections && (e3.collections = e3.collections.map((n2) => this.traverseCollection(typeof n2 == "string" ? { "@id": n2, "@type": "sc:Collection" } : n2))), e3.members && (e3.members = e3.members.map((n2) => typeof n2 == "string" ? n2 : n2["@type"] === "sc:Collection" ? this.traverseCollection(n2) : n2["@type"] === "sc:Manifest" ? this.traverseManifest(n2) : this.traverseUnknown(n2))), e3;
    }
    traverseManifest(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(e3))), this.traversals.manifest);
    }
    traverseManifestItems(e3) {
      return e3.sequences && (e3.sequences = e3.sequences.map((n2) => this.traverseSequence(n2))), e3.structures && (e3.structures = e3.structures.map((n2) => this.traverseRange(n2))), e3;
    }
    traverseSequence(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseSequenceItems(e3))), this.traversals.sequence);
    }
    traverseSequenceItems(e3) {
      return e3.canvases && (e3.canvases = e3.canvases.map((n2) => this.traverseCanvas(n2))), e3;
    }
    traverseCanvas(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(e3))), this.traversals.canvas);
    }
    traverseCanvasItems(e3) {
      return e3.images && (e3.images = e3.images.map((n2) => this.traverseAnnotation(n2))), e3.otherContent && (e3.otherContent = e3.otherContent.map((n2) => this.traverseAnnotationList(n2))), e3;
    }
    traverseRange(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseRangeItems(e3))), this.traversals.range);
    }
    traverseRangeItems(e3) {
      if (this.options.mergeMemberProperties) {
        let n2 = [...(e3.ranges || []).map((i3) => typeof i3 == "string" ? { "@id": i3, "@type": "sc:Range" } : i3), ...(e3.canvases || []).map((i3) => typeof i3 == "string" ? { "@id": i3, "@type": "sc:Canvas" } : i3), ...e3.members || []];
        delete e3.ranges, delete e3.canvases, e3.members = n2.length ? n2.map((i3) => this.traverseUnknown(i3)) : void 0;
      }
      return e3;
    }
    traverseAnnotationList(e3) {
      let n2 = typeof e3 == "string" ? { "@id": e3, "@type": "sc:AnnotationList" } : e3;
      return this.traverseType(this.traverseDescriptive(this.traverseAnnotationListItems(n2)), this.traversals.annotationList);
    }
    traverseAnnotationListItems(e3) {
      return e3.resources && (e3.resources = e3.resources.map((n2) => this.traverseAnnotation(n2))), e3;
    }
    traverseAnnotation(e3) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationItems(e3))), this.traversals.annotation);
    }
    traverseAnnotationItems(e3) {
      return e3.resource && (Array.isArray(e3.resource) ? e3.resource = e3.resource.map((n2) => this.traverseContentResource(n2)) : e3.resource = this.traverseContentResource(e3.resource)), e3.on, e3;
    }
    traverseLayer(e3) {
      return this.traverseType(this.traverseLinking(this.traverseLayerItems(e3)), this.traversals.layer);
    }
    traverseLayerItems(e3) {
      return e3.otherContent && (e3.otherContent = e3.otherContent.map((n2) => this.traverseAnnotationList(n2))), e3;
    }
    traverseChoice(e3) {
      return this.traverseType(this.traverseChoiceItems(e3), this.traversals.choice);
    }
    traverseChoiceItems(e3) {
      return e3.default && e3.default !== "rdf:nil" && (e3.default = this.traverseContentResource(e3.default)), e3.item && e3.item !== "rdf:nil" && (e3.item = e3.item.map((n2) => this.traverseContentResource(n2))), e3;
    }
    traverseService(e3) {
      return this.traverseType(this.traverseLinking(e3), this.traversals.service);
    }
    traverseContentResource(e3) {
      return e3["@type"] === "oa:Choice" ? this.traverseChoice(e3) : this.traverseType(this.traverseDescriptive(this.traverseLinking(e3)), this.traversals.contentResource);
    }
    traverseUnknown(e3) {
      if (!e3["@type"] || typeof e3 == "string")
        return e3;
      switch (S3(e3)) {
        case "sc:Collection":
          return this.traverseCollection(e3);
        case "sc:Manifest":
          return this.traverseManifest(e3);
        case "sc:Canvas":
          return this.traverseCanvas(e3);
        case "sc:Sequence":
          return this.traverseSequence(e3);
        case "sc:Range":
          return this.traverseRange(e3);
        case "oa:Annotation":
          return this.traverseAnnotation(e3);
        case "sc:AnnotationList":
          return this.traverseAnnotationList(e3);
        case "sc:Layer":
          return this.traverseLayer(e3);
        case "Service":
          return this.traverseService(e3);
        case "oa:Choice":
          return this.traverseChoice(e3);
        case "ContentResource":
          return this.traverseContentResource(e3);
      }
      return e3.profile ? this.traverseService(e3) : e3;
    }
    traverseImageResource(e3) {
      let n2 = Array.isArray(e3), i3 = Array.isArray(e3) ? e3 : [e3], a3 = [];
      for (let r3 of i3)
        typeof r3 == "string" ? a3.push(this.traverseContentResource({ "@id": r3, "@type": "dctypes:Image" })) : a3.push(this.traverseContentResource(r3));
      return !n2 && !this.options.convertPropsToArray ? a3[0] : a3;
    }
    traverseDescriptive(e3) {
      return e3.thumbnail && (e3.thumbnail = this.traverseImageResource(e3.thumbnail)), e3.logo && (e3.logo = this.traverseImageResource(e3.logo)), e3;
    }
    traverseOneOrMoreServices(e3) {
      let n2 = Array.isArray(e3), i3 = Array.isArray(e3) ? e3 : [e3], a3 = [];
      for (let r3 of i3)
        a3.push(this.traverseService(r3));
      return !n2 && !this.options.convertPropsToArray ? a3[0] : a3;
    }
    traverseLinking(e3) {
      return e3.related && (e3.related = this.traverseOneOrManyType(e3.related, this.traversals.contentResource)), e3.rendering && (e3.rendering = this.traverseOneOrManyType(e3.rendering, this.traversals.contentResource)), e3.service && (e3.service = this.traverseOneOrMoreServices(e3.service)), e3.seeAlso && (e3.seeAlso = this.traverseOneOrManyType(e3.seeAlso, this.traversals.contentResource)), e3.within && (typeof e3.within == "string" || (e3.within = this.traverseOneOrManyType(e3.within, this.traversals.contentResource))), e3.startCanvas && (typeof e3.startCanvas == "string" ? e3.startCanvas = this.traverseType({ "@id": e3.startCanvas, "@type": "sc:Canvas" }, this.traversals.canvas) : e3.startCanvas && this.traverseType(e3.startCanvas, this.traversals.canvas)), e3.contentLayer && (typeof e3.contentLayer == "string" ? e3.contentLayer = this.traverseLayer({ "@id": e3.contentLayer, "@type": "sc:Layer" }) : e3.contentLayer = this.traverseLayer(e3.contentLayer)), e3;
    }
    traverseOneOrManyType(e3, n2) {
      if (!Array.isArray(e3))
        if (this.options.convertPropsToArray)
          e3 = [e3];
        else
          return this.traverseType(e3, n2);
      return e3.map((i3) => this.traverseType(i3, n2));
    }
    traverseType(e3, n2) {
      return n2.reduce((i3, a3) => {
        let r3 = a3(i3);
        return typeof r3 > "u" && !this.options.allowUndefinedReturn ? i3 : r3;
      }, e3);
    }
  };
  var O3 = "http://library.stanford.edu/iiif/image-api/compliance.html#level1";
  var w = "http://library.stanford.edu/iiif/image-api/compliance.html#level2";
  var b3 = "http://library.stanford.edu/iiif/image-api/conformance.html#level1";
  var F2 = "http://library.stanford.edu/iiif/image-api/conformance.html#level2";
  var D = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1";
  var N2 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2";
  var k = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1";
  var G2 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2";
  var j3 = "http://iiif.io/api/image/1/level1.json";
  var q = "http://iiif.io/api/image/1/profiles/level1.json";
  var V2 = "http://iiif.io/api/image/1/level2.json";
  var U = "http://iiif.io/api/image/1/profiles/level2.json";
  var $2 = "http://iiif.io/api/image/2/level1.json";
  var W2 = "http://iiif.io/api/image/2/profiles/level1.json";
  var B3 = "http://iiif.io/api/image/2/level2.json";
  var H2 = "http://iiif.io/api/image/2/profiles/level2.json";
  var J = "level1";
  var z2 = "level2";
  var K = "http://iiif.io/api/image/2/level1";
  var Q2 = "http://iiif.io/api/image/2/level2";
  var _2 = [K, Q2, O3, w, b3, F2, D, N2, k, G2, j3, q, V2, U, $2, W2, B3, H2, J, z2];
  var y2 = { attributionLabel: "Attribution", lang: "none", providerId: "http://example.org/provider", providerName: "" };
  function X(t4) {
    if (typeof t4 == "string")
      return [t4];
    if (!t4)
      return [];
    let e3 = Array.isArray(t4) ? t4 : [t4], n2 = [];
    for (let i3 of e3) {
      if (typeof i3 == "string") {
        n2.push(i3);
        continue;
      }
      n2.push({ "@language": i3["@language"] || i3.language, "@value": i3["@value"] || i3.value });
    }
    return n2;
  }
  function u2(t4, e3 = "none") {
    if (!t4)
      return { none: [""] };
    let n2 = X(t4), i3 = {};
    for (let a3 of n2) {
      if (typeof a3 == "string") {
        i3[e3] = i3[e3] ? i3[e3] : [], i3[e3].push(a3 || "");
        continue;
      }
      if (!a3["@language"]) {
        i3[e3] = i3[e3] ? i3[e3] : [], i3[e3].push(a3["@value"] || "");
        continue;
      }
      let r3 = a3["@language"];
      i3[r3] = i3[r3] ? i3[r3] : [], i3[r3].push(a3["@value"] || "");
    }
    return Object.keys(i3).length === 0 ? { none: [""] } : i3;
  }
  function L3(t4) {
    if (Array.isArray(t4))
      return L3(t4.find((e3) => typeof e3 == "string"));
    if (R.indexOf(t4) !== -1)
      return "level2";
    if (_2.indexOf(t4) !== -1)
      return "level1";
    if (P.indexOf(t4) !== -1)
      return "level0";
    if (typeof t4 == "string")
      return t4;
  }
  function Y(t4) {
    let e3 = Array.isArray(t4) ? t4 : [t4];
    for (let n2 of e3)
      switch (n2) {
        case "http://iiif.io/api/image/2/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2":
          return "ImageService2";
        case "http://iiif.io/api/image/1/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
          return "ImageService1";
        case "http://iiif.io/api/annex/openannotation/context.json":
          return "ImageApiSelector";
      }
  }
  function Z(t4) {
    switch (t4) {
      case "http://iiif.io/api/image/2/level0.json":
      case "http://iiif.io/api/image/2/level1.json":
      case "http://iiif.io/api/image/2/level2.json":
        return "ImageService2";
      case "http://iiif.io/api/auth/1/kiosk":
      case "http://iiif.io/api/auth/1/login":
      case "http://iiif.io/api/auth/1/clickthrough":
      case "http://iiif.io/api/auth/1/external":
      case "http://iiif.io/api/auth/0/kiosk":
      case "http://iiif.io/api/auth/0/login":
      case "http://iiif.io/api/auth/0/clickthrough":
      case "http://iiif.io/api/auth/0/external":
        return "AuthCookieService1";
      case "http://iiif.io/api/auth/1/token":
      case "http://iiif.io/api/auth/0/token":
        return "AuthTokenService1";
      case "http://iiif.io/api/auth/1/logout":
      case "http://iiif.io/api/auth/0/logout":
        return "AuthLogoutService1";
      case "http://iiif.io/api/search/1/search":
      case "http://iiif.io/api/search/0/search":
        return "SearchService1";
      case "http://iiif.io/api/search/1/autocomplete":
      case "http://iiif.io/api/search/0/autocomplete":
        return "AutoCompleteService1";
    }
  }
  function R3(t4) {
    for (let e3 of ["sc", "oa", "dcterms", "dctypes", "iiif"])
      if (t4.startsWith(`${e3}:`))
        return t4.slice(e3.length + 1);
    return t4;
  }
  var ee = ["Collection", "Manifest", "Annotation", "AnnotationPage", "Range", "Service"];
  function m3(t4) {
    let e3 = t4["@id"] || t4.id, n2 = t4["@type"] || t4.type, i3 = t4.profile || void 0, a3 = t4["@context"] || void 0;
    if (i3) {
      let r3 = Z(i3);
      if (r3)
        return r3;
    }
    if (a3) {
      let r3 = Y(a3);
      if (r3)
        return r3;
    }
    if (n2) {
      if (Array.isArray(n2)) {
        if (n2.indexOf("oa:CssStylesheet") !== -1)
          return "CssStylesheet";
        if (n2.indexOf("cnt:ContentAsText") !== -1)
          return "TextualBody";
        n2 = n2[0];
      }
      for (let r3 of ["sc", "oa", "dcterms", "dctypes", "iiif"])
        if (n2.startsWith(`${r3}:`)) {
          n2 = n2.slice(r3.length + 1);
          break;
        }
      switch (n2) {
        case "Layer":
          return "AnnotationCollection";
        case "AnnotationList":
          return "AnnotationPage";
        case "cnt:ContentAsText":
          return "TextualBody";
      }
    }
    if (n2 && ee.indexOf(n2) !== -1)
      return n2;
    if (t4.format) {
      if (t4.format.startsWith("image/"))
        return "Image";
      if (t4.format.startsWith("text/") || t4.format === "application/pdf")
        return "Text";
      if (t4.format.startsWith("application/"))
        return "Dataset";
    }
    return e3 && (e3.endsWith(".jpg") || e3.endsWith(".png") || e3.endsWith(".jpeg")) ? "Image" : n2 || "unknown";
  }
  var te = /http(s)?:\/\/(creativecommons.org|rightsstatements.org)[^"'\\<\n]+/gm;
  function ne(t4) {
    let e3 = t4.match(te);
    return e3 ? e3[0] : t4;
  }
  function ie(t4, e3 = "Rights/License", n2 = "none") {
    let i3 = null, a3 = [], r3 = Array.isArray(t4) ? t4 : [t4];
    for (let s2 of r3) {
      let c2 = s2 ? ne(s2) : void 0;
      if (c2 && (c2.indexOf("creativecommons.org") !== -1 || c2.indexOf("rightsstatements.org") !== -1)) {
        c2.startsWith("https://") ? i3 = `http://${c2.slice(8)}` : i3 = c2;
        continue;
      }
      c2 && a3.push({ label: { [n2]: [e3] }, value: { [n2]: [c2] } });
    }
    return [i3, a3];
  }
  var re = ["http://iiif.io/api/presentation/2/context.json", "http://iiif.io/api/image/2/context.json", "http://iiif.io/api/image/1/context.json", "http://library.stanford.edu/iiif/image-api/1.1/context.json", "http://iiif.io/api/search/1/context.json", "http://iiif.io/api/search/0/context.json", "http://iiif.io/api/auth/1/context.json", "http://iiif.io/api/auth/0/context.json", "http://iiif.io/api/annex/openannotation/context.json"];
  function ae(t4) {
    if (t4) {
      let e3 = Array.isArray(t4) ? t4 : [t4], n2 = [];
      for (let i3 of e3)
        i3 === "http://iiif.io/api/presentation/2/context.json" && n2.push("http://iiif.io/api/presentation/3/context.json"), re.indexOf(i3) === -1 && n2.push(i3);
      if (e3.length)
        return n2.length === 1 ? n2[0] : n2;
    }
  }
  function se(t4) {
    return t4 ? t4.map((e3) => ({ label: u2(e3.label), value: u2(e3.value) })) : [];
  }
  var x2 = 0;
  function E2(t4, e3) {
    let n2 = encodeURI(t4.id || t4["@id"] || "").trim();
    return n2 && e3 ? `${n2}/${e3}` : n2 || (x2++, `http://example.org/${t4["@type"]}${e3 ? `/${e3}` : ""}/${x2}`);
  }
  function p2(t4) {
    let e3 = [...t4.behavior || []];
    t4.viewingHint && e3.push(t4.viewingHint);
    let n2;
    return Array.isArray(t4.motivation) ? n2 = t4.motivation.map(R3) : t4.motivation && (n2 = R3(t4.motivation)), { "@context": t4["@context"] ? ae(t4["@context"]) : void 0, id: (t4["@id"] || E2(t4)).trim(), type: m3(t4), behavior: e3.length ? e3 : void 0, height: t4.height ? t4.height : void 0, width: t4.width ? t4.width : void 0, motivation: n2, viewingDirection: t4.viewingDirection, profile: t4.profile, format: t4.format ? t4.format : void 0, duration: void 0, timeMode: void 0 };
  }
  function f3(t4) {
    let [e3, n2] = ie(t4.license), i3 = [...t4.metadata ? se(t4.metadata) : [], ...n2];
    return { rights: e3, metadata: i3.length ? i3 : void 0, label: t4.label ? u2(t4.label) : void 0, requiredStatement: t4.attribution ? { label: u2(y2.attributionLabel), value: u2(t4.attribution) } : void 0, navDate: t4.navDate, summary: t4.description ? u2(t4.description) : void 0, thumbnail: oe(t4.thumbnail) };
  }
  function oe(t4) {
    return t4 && (Array.isArray(t4) ? t4 : [t4]).map((n2) => typeof n2 == "string" ? { id: n2, type: "Image" } : (n2.type === "unknown" && (n2.type = "Image"), n2));
  }
  function pe(t4) {
    if (!t4.within)
      return;
    let e3 = Array.isArray(t4.within) ? t4.within : [t4.within], n2 = [];
    for (let i3 of e3)
      if (typeof i3 == "string") {
        if (i3)
          switch (t4["@type"]) {
            case "sc:Manifest":
              n2.push({ id: i3, type: "Collection" });
              break;
          }
      } else
        i3["@id"] && n2.push({ id: i3["@id"], type: m3(i3) });
    return n2.length ? n2 : void 0;
  }
  function l2(t4) {
    let e3 = t4.related ? Array.isArray(t4.related) ? t4.related : [t4.related] : [], n2 = t4.contentLayer;
    return { provider: t4.logo || e3.length ? [{ id: y2.providerId, type: "Agent", homepage: e3.length ? [e3[0]] : void 0, logo: t4.logo ? Array.isArray(t4.logo) ? t4.logo : [t4.logo] : void 0, label: u2(y2.providerName) }] : void 0, partOf: pe(t4), rendering: t4.rendering, seeAlso: t4.seeAlso, start: t4.startCanvas, service: t4.service ? i2(t4.service) : void 0, supplementary: n2 ? [n2] : void 0 };
  }
  function fe(t4) {
    return { chars: t4.chars, format: t4.format ? t4.format : void 0, language: t4.language };
  }
  function d3(t4, e3) {
    return t4 ? typeof t4 == "string" ? { id: t4, type: e3 } : typeof t4?.["@id"] == "string" ? { id: t4["@id"], type: e3 } : typeof t4.id == "string" ? { id: t4.id, type: e3 } : null : null;
  }
  function ce(t4) {
    let e3 = {};
    if (t4.first) {
      let n2 = d3(t4.first, "Collection");
      n2 && (e3.first = n2);
    }
    if ((t4.total || t4.total === 0) && (e3.total = t4.total), t4.prev) {
      let n2 = d3(t4.prev, "Collection");
      n2 && (e3.prev = n2);
    }
    if (t4.next) {
      let n2 = d3(t4.next, "Collection");
      n2 && (e3.next = n2);
    }
    return e3;
  }
  function le(t4) {
    let e3 = [];
    for (let n2 of t4) {
      let i3 = { ...n2 };
      i3.items && i3.items.length === 0 && delete i3.items, e3.push(i3);
    }
    return e3;
  }
  function ue(t4) {
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4), ...ce(t4), items: le(t4.members) });
  }
  function he(t4) {
    let e3 = [], n2 = [], i3, a3;
    for (let s2 of t4.sequences || [])
      s2.canvases.length && e3.push(...s2.canvases), s2.behavior && n2.push(...s2.behavior), s2.viewingDirection && (a3 = s2.viewingDirection), s2.startCanvas && (i3 = s2.startCanvas);
    let r3 = p2(t4);
    return n2.length && (r3.behavior ? r3.behavior.push(...n2) : r3.behavior = n2), r2({ ...r3, ...f3(t4), ...l2(t4), viewingDirection: a3, start: i3, items: e3, structures: ve(t4.structures) });
  }
  function ve(t4) {
    if (!t4)
      return t4;
    let e3 = /* @__PURE__ */ new Map();
    for (let i3 of t4)
      e3.set(i3.id, i3);
    let n2 = [];
    for (let i3 of t4)
      if (i3.items) {
        let a3 = i3.items.map((r3) => typeof r3 == "string" ? (n2.push(r3), e3.get(r3) || r3) : r3 && r3.id ? (n2.push(r3.id), e3.get(r3.id) || r3) : r3);
        i3.items = a3;
      }
    return t4.filter((i3) => n2.indexOf(i3.id) === -1);
  }
  function de(t4) {
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4), annotations: t4.otherContent && t4.otherContent.length ? t4.otherContent : void 0, items: t4.images && t4.images.length ? [{ id: E2(t4, "annotation-page"), type: "AnnotationPage", items: t4.images }] : void 0 });
  }
  function ye(t4) {
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4), items: t4.resources && t4.resources.length ? t4.resources : void 0 });
  }
  function ge(t4) {
    return !t4.canvases || t4.canvases.length === 0 ? { canvases: [], behavior: [] } : { canvases: t4.canvases, behavior: t4.viewingHint ? [t4.viewingHint] : [], viewingDirection: t4.viewingDirection, startCanvas: t4.startCanvas };
  }
  function me(t4) {
    function e3(n2) {
      if (Array.isArray(n2)) {
        if (n2.length > 1)
          return { type: "List", items: n2.map(e3) };
        n2 = n2[0];
      }
      if (typeof n2 == "string")
        return encodeURI(n2).trim();
      if ("@type" in n2) {
        let i3;
        if (typeof n2.full == "string")
          i3 = n2.full;
        else if (n2.full["@type"] === "dctypes:Image")
          i3 = { id: n2.full["@id"], type: "Image" };
        else if (n2.full["@type"] === "sc:Canvas")
          i3 = { id: n2.full["@id"], type: "Canvas" };
        else
          throw new Error(`Unsupported source type on annotation: ${n2.full["@type"]}`);
        return { type: "SpecificResource", source: i3, selector: g2(n2.selector) };
      } else
        return encodeURI(n2["@id"]).trim();
    }
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4), target: e3(t4.on), body: Array.isArray(t4.resource) ? t4.resource.map(T) : T(t4.resource) });
  }
  function T(t4) {
    return t4.type === "Choice" ? t4 : M2(t4);
  }
  function M2(t4) {
    let e3 = t4;
    return r2({ ...p2(e3), ...f3(e3), ...l2(e3), ...fe(e3) });
  }
  function Ce(t4) {
    let e3 = [];
    return t4.default && t4.default !== "rdf:nil" && e3.push(t4.default), t4.item && t4.item !== "rdf:nil" && e3.push(...t4.item), r2({ ...p2(t4), ...f3(t4), items: e3 });
  }
  function Ae(t4) {
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4), items: t4.members });
  }
  function Ie(t4) {
    let { "@id": e3, "@type": n2, "@context": i3, profile: a3, ...r3 } = t4, s2 = {};
    return e3 && (s2["@id"] = e3), s2["@type"] = m3(t4), s2["@type"] === "unknown" && (i3 && i3.length && (s2["@context"] = i3), s2["@type"] = "Service"), a3 && (s2.profile = L3(a3)), r2({ ...s2, ...r3 });
  }
  function Pe(t4) {
    return r2({ ...p2(t4), ...f3(t4), ...l2(t4) });
  }
  var _e = new h3({ collection: [ue], manifest: [he], canvas: [de], annotationList: [ye], sequence: [ge], annotation: [me], contentResource: [M2], choice: [Ce], range: [Ae], service: [Ie], layer: [Pe] });
  function be(t4) {
    return t4 && t4["@context"] && (t4["@context"] === "http://iiif.io/api/presentation/2/context.json" || t4["@context"].indexOf("http://iiif.io/api/presentation/2/context.json") !== -1 || t4["@context"] === "http://www.shared-canvas.org/ns/context.json") || t4["@context"] === "http://iiif.io/api/image/2/context.json" || t4["@id"] && t4["@type"] === "sc:Collection" || t4["@id"] && t4["@type"] === "sc:Manifest" ? (t4["@context"] || (t4["@context"] = "http://iiif.io/api/presentation/2/context.json"), _e.traverseUnknown(t4)) : t4;
  }
  function g2(t4) {
    if ((Array.isArray(t4["@type"]) && t4["@type"].includes("oa:SvgSelector") || t4["@type"] == "oa:SvgSelector") && ("chars" in t4 || "value" in t4))
      return { type: "SvgSelector", value: "chars" in t4 ? t4.chars : t4.value };
    if (t4["@type"] === "oa:FragmentSelector")
      return { type: "FragmentSelector", value: t4.value };
    if (t4["@type"] === "oa:Choice")
      return [g2(t4.default), ...(Array.isArray(t4.item) ? t4.item : [t4.item]).map(g2)];
    if (t4["@type"] == "iiif:ImageApiSelector")
      return { type: "ImageApiSelector", region: "region" in t4 ? t4.region : void 0, rotation: "rotation" in t4 ? t4.rotation : void 0 };
    throw new Error(`Unsupported selector type: ${t4["@type"]}`);
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-ERHCHADU.js
  function v2(a3) {
    return typeof a3 == "string" ? false : a3 && !a3.type && "source" in a3 ? (a3.type = "SpecificResource", true) : !!a3 && a3.type === "SpecificResource";
  }
  function o2(...a3) {
    return (e3) => a3.reduce((t4, n2) => n2(t4), e3);
  }
  var p3 = ["Collection", "Manifest", "Canvas", "AnnotationPage", "AnnotationCollection", "Annotation", "ContentResource", "Range", "Service", "Selector", "Agent"];
  function y3(a3, e3) {
    if (typeof a3 > "u" || a3 === null)
      throw new Error("Null or undefined is not a valid entity.");
    if (Array.isArray(a3))
      throw new Error("Array is not a valid entity");
    if (typeof a3 != "object") {
      if (e3)
        return e3;
      throw new Error(`${typeof a3} is not a valid entity`);
    }
    if (typeof a3.type == "string") {
      let t4 = p3.indexOf(a3.type);
      if (t4 !== -1)
        return p3[t4];
    }
    if (a3.profile)
      return "Service";
    throw new Error("Resource type is not known");
  }
  var l3 = class a2 {
    constructor(e3, t4 = {}) {
      f2(this, "traversals");
      f2(this, "options");
      f2(this, "_traverseManifest", o2(this.traverseManifestItems.bind(this), this.traverseNavPlace.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this), this.traverseManifestStructures.bind(this), this.traverseInlineAnnotationPages.bind(this)));
      f2(this, "_traverseCanvas", o2(this.traverseCanvasItems.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this), this.traverseInlineAnnotationPages.bind(this)));
      f2(this, "_traverseAnnotationPage", o2(this.traverseAnnotationPageItems.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this)));
      f2(this, "_traverseRange", o2(this.traverseRangeRanges.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this)));
      this.traversals = { collection: [], manifest: [], canvas: [], annotationCollection: [], annotationPage: [], annotation: [], contentResource: [], choice: [], range: [], service: [], agent: [], specificResource: [], geoJson: [], ...e3 }, this.options = { allowUndefinedReturn: false, ...t4 };
    }
    static all(e3) {
      return new a2({ collection: [e3], manifest: [e3], canvas: [e3], annotationCollection: [e3], annotationPage: [e3], annotation: [e3], contentResource: [e3], choice: [e3], range: [e3], service: [e3], geoJson: [e3], specificResource: [e3], agent: [e3] });
    }
    traverseDescriptive(e3) {
      return e3.thumbnail && (e3.thumbnail = i2(e3.thumbnail).map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.provider && (e3.provider = e3.provider.map((t4) => this.traverseAgent(t4, e3))), e3;
    }
    traverseLinking(e3) {
      return e3.seeAlso && (e3.seeAlso = e3.seeAlso.map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.service && (e3.service = i2(e3.service).map((t4) => this.traverseService(t4))), e3.services && (e3.services = i2(e3.services).map((t4) => this.traverseService(t4, e3))), e3.logo && (e3.logo = e3.logo.map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.homepage && (e3.homepage = i2(e3.homepage).map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.partOf && (e3.partOf = e3.partOf.map((t4) => typeof t4 == "string" || !t4.type ? this.traverseType(t4, { parent: e3 }, this.traversals.contentResource) : t4.type === "Canvas" ? this.traverseType(t4, { parent: e3 }, this.traversals.canvas) : t4.type === "AnnotationCollection" ? this.traverseType(t4, { parent: e3 }, this.traversals.annotationCollection) : t4.type === "Collection" ? this.traverseType(t4, { parent: e3 }, this.traversals.collection) : this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.start && (v2(e3.start) ? e3.start = this.traverseSpecificResource(e3.start, "Canvas", e3) : e3.start = this.traverseType(e3.start, { parent: e3 }, this.traversals.canvas)), e3.rendering && (e3.rendering = e3.rendering.map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3.supplementary && (e3.supplementary = e3.supplementary.map((t4) => this.traverseType(t4, { parent: e3 }, this.traversals.contentResource))), e3;
    }
    traverseCollectionItems(e3) {
      return e3.items && e3.items.map((t4) => t4.type === "Collection" ? this.traverseCollection(t4) : this.traverseManifest(t4)), e3;
    }
    traverseCollection(e3, t4) {
      return this.traverseType(this.traverseDescriptive(this.traverseNavPlace(this.traverseInlineAnnotationPages(this.traverseLinking(this.traverseLinkedCanvases(this.traverseCollectionItems(e3)))))), { parent: t4 }, this.traversals.collection);
    }
    traverseGeoJson(e3, t4) {
      return this.traverseType(e3, { parent: t4 }, this.traversals.geoJson);
    }
    traverseNavPlace(e3) {
      return e3.navPlace && (e3.navPlace = this.traverseGeoJson(e3.navPlace, e3)), e3;
    }
    traverseManifestItems(e3) {
      return e3.items && (e3.items = e3.items.map((t4) => this.traverseCanvas(t4))), e3;
    }
    traverseManifestStructures(e3) {
      return e3.structures && (e3.structures = e3.structures.map((t4) => this.traverseRange(t4))), e3;
    }
    traverseManifest(e3, t4) {
      return this.traverseType(this._traverseManifest(e3), { parent: t4 }, this.traversals.manifest);
    }
    traverseCanvasItems(e3) {
      return e3.items = (e3.items || []).map((t4) => this.traverseAnnotationPage(t4, e3)), e3;
    }
    traverseInlineAnnotationPages(e3) {
      return typeof e3 == "string" || !e3 || e3.annotations && (e3.annotations = e3.annotations.map((t4) => this.traverseAnnotationPage(t4, e3))), e3;
    }
    traverseCanvas(e3, t4) {
      return this.traverseType(this._traverseCanvas(e3), { parent: t4 }, this.traversals.canvas);
    }
    traverseAnnotationPageItems(e3) {
      return e3.items && (e3.items = e3.items.map((t4) => this.traverseAnnotation(t4, e3))), e3;
    }
    traverseAnnotationPage(e3, t4) {
      return this.traverseType(this._traverseAnnotationPage(e3), { parent: t4 }, this.traversals.annotationPage);
    }
    traverseAnnotationBody(e3) {
      return Array.isArray(e3.body) ? e3.body = e3.body.map((t4) => this.traverseContentResource(t4, e3)) : e3.body && (e3.body = this.traverseContentResource(e3.body, e3)), e3;
    }
    traverseLinkedCanvases(e3) {
      return e3.placeholderCanvas && (e3.placeholderCanvas = this.traverseCanvas(e3.placeholderCanvas)), e3.accompanyingCanvas && (e3.accompanyingCanvas = this.traverseCanvas(e3.accompanyingCanvas)), e3;
    }
    traverseAnnotation(e3, t4) {
      return this.traverseType(this.traverseLinking(this.traverseAnnotationBody(this.traverseDescriptive(e3))), { parent: t4 }, this.traversals.annotation);
    }
    traverseContentResourceLinking(e3) {
      return typeof e3 == "string" || !e3 || e3 && e3.service && (e3.service = i2(e3.service || []).map((t4) => this.traverseService(t4, e3))), e3;
    }
    traverseContentResource(e3, t4) {
      return e3.type === "Choice" && (e3.items = e3.items.map((n2) => this.traverseContentResource(n2, e3))), v2(e3) ? this.traverseSpecificResource(e3, "ContentResource") : this.traverseType(this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(e3)), { parent: t4 }, this.traversals.contentResource);
    }
    traverseSpecificResource(e3, t4, n2) {
      let s2 = e3.source;
      return typeof e3.source == "string" && (s2 = { id: e3.source, type: t4 || "unknown" }), this.traverseType({ ...e3, source: t4 === "Canvas" || s2.type === "Canvas" ? this.traverseType(s2, { parent: n2 }, this.traversals.canvas) : t4 === "ContentResource" ? this.traverseContentResource(s2, { parent: n2 }) : this.traverseUnknown(s2, { parent: n2, typeHint: t4 }) }, { parent: n2 }, this.traversals.specificResource);
    }
    traverseRangeRanges(e3) {
      return e3.items && (e3.items = e3.items.map((t4) => typeof t4 == "string" ? this.traverseCanvas({ id: t4, type: "Canvas" }, e3) : v2(t4) ? this.traverseSpecificResource(t4, "Canvas", e3) : t4.type === "Manifest" ? this.traverseManifest(t4, e3) : this.traverseRange(t4, e3))), e3;
    }
    traverseRange(e3, t4) {
      return this.traverseType(this._traverseRange(e3), { parent: t4 }, this.traversals.range);
    }
    traverseAgent(e3, t4) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(e3)), { parent: t4 }, this.traversals.agent);
    }
    traverseType(e3, t4, n2) {
      return n2.reduce((s2, c2) => {
        let h5 = c2(s2, t4);
        return typeof h5 > "u" && !this.options.allowUndefinedReturn ? s2 : h5;
      }, e3);
    }
    traverseService(e3, t4) {
      let n2 = Object.assign({}, e3);
      return n2 && n2.service && (n2.service = i2(n2.service).map((s2) => this.traverseService(s2))), this.traverseType(n2, { parent: t4 }, this.traversals.service);
    }
    traverseUnknown(e3, { parent: t4, typeHint: n2 } = {}) {
      let s2 = y3(e3, n2);
      switch (s2) {
        case "Collection":
          return this.traverseCollection(e3, t4);
        case "Manifest":
          return this.traverseManifest(e3, t4);
        case "Canvas":
          return this.traverseCanvas(e3, t4);
        case "AnnotationPage":
          return this.traverseAnnotationPage(e3, t4);
        case "Annotation":
          return this.traverseAnnotation(e3, t4);
        case "ContentResource":
          return this.traverseContentResource(e3, t4);
        case "Range":
          return this.traverseRange(e3, t4);
        case "Service":
          return this.traverseService(e3, t4);
        case "Agent":
          return this.traverseAgent(e3, t4);
        default:
          throw new Error(`Unknown or unsupported resource type of ${s2}`);
      }
    }
  };

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-NQRGLBGA.js
  function L4(e3, n2) {
    let i3 = n2 || "unknown";
    if (!e3)
      return;
    if (typeof e3 == "string")
      return { id: e3, type: i3 };
    if (v2(e3))
      return L4(e3.source, n2);
    let r3 = i3 && i3 !== "unknown" ? i3 : e3.type || e3["@type"], t4 = e3.id || e3["@id"];
    if (r3 && r3.indexOf(":") !== -1 && (r3 = r3.split(":").pop()), t4 && r3)
      return { id: t4, type: r3 };
  }
  var w2 = {};
  var d4 = "iiif-parser:hasPart";
  var g3 = "iiif-parser:partOf";
  var T2 = "iiif-parser:isExternal";
  var m4 = "__$UNSET$__";
  var j4 = "__$UNWRAP$__";
  var o3 = [];
  Object.freeze(o3);
  Object.freeze(w2);
  function oe2(e3) {
    if (e3 === w2 || Object.keys(e3).length === 0)
      return true;
    for (let n2 in e3)
      return false;
    return true;
  }
  function ae2(e3, n2) {
    if (n2 && n2["@explicit"]) {
      let i3 = {}, r3 = Object.keys(n2);
      for (let t4 of r3)
        t4 === g3 || t4 === "@explicit" || (oe2(n2[t4]) ? i3[t4] = e3[t4] : i3[t4] = n2[t4]);
      return i3;
    }
    return e3;
  }
  function F3(e3, n2, i3) {
    let r3 = L4(n2);
    if (!r3)
      return [void 0, void 0];
    let t4 = e3.requests[r3.id], a3 = r3.type || e3.mapping[r3.id];
    if (!a3 || t4 && t4.resourceUri && (!e3.entities[a3] || !e3.entities[a3][t4.resourceUri]))
      return [void 0, void 0];
    let s2 = e3.entities[a3][t4 ? t4.resourceUri : r3.id];
    if (r3.type && !s2)
      return F3(e3, { id: r3.id }, i3);
    if (s2 && s2[d4]) {
      let c2 = s2[d4].find((l4) => i3 ? l4[g3] === i3.id : l4[g3] === s2.id);
      return [ae2(s2, c2), s2];
    }
    return [s2, s2];
  }
  var K2 = { id: "https://iiif-parser/annotation-page", type: "AnnotationPage", behavior: o3, label: null, thumbnail: o3, summary: null, requiredStatement: null, metadata: o3, rights: null, provider: o3, items: o3, seeAlso: o3, homepage: o3, rendering: o3, service: o3 };
  var G3 = { id: "https://iiif-parser/empty-canvas", type: "Canvas", label: null, behavior: o3, thumbnail: o3, accompanyingCanvas: null, placeholderCanvas: null, summary: null, requiredStatement: null, metadata: o3, rights: null, navDate: null, provider: o3, items: o3, annotations: o3, seeAlso: o3, homepage: o3, partOf: o3, rendering: o3, service: o3, duration: 0, height: 0, width: 0 };
  var X2 = { id: "https://iiif-parser/empty-collection", type: "Collection", label: null, viewingDirection: "left-to-right", behavior: o3, thumbnail: o3, accompanyingCanvas: null, placeholderCanvas: null, summary: null, requiredStatement: null, metadata: o3, rights: null, navDate: null, provider: o3, items: o3, annotations: o3, seeAlso: o3, homepage: o3, partOf: o3, rendering: o3, service: o3, services: o3 };
  var Y2 = { id: "https://iiif-parser/empty-manifest", type: "Manifest", annotations: o3, behavior: o3, homepage: o3, items: o3, label: null, metadata: o3, navDate: null, provider: o3, partOf: o3, accompanyingCanvas: null, placeholderCanvas: null, rendering: o3, requiredStatement: null, rights: null, seeAlso: o3, service: o3, services: o3, start: null, structures: o3, summary: null, thumbnail: o3, viewingDirection: "left-to-right" };
  var J2 = { id: "https://iiif-parser/empty-canvas", type: "Range", label: null, behavior: o3, thumbnail: o3, accompanyingCanvas: null, placeholderCanvas: null, summary: null, requiredStatement: null, metadata: o3, rights: null, navDate: null, provider: o3, items: o3, annotations: o3, seeAlso: o3, homepage: o3, partOf: o3, rendering: o3, service: o3, start: null, supplementary: null, viewingDirection: "left-to-right" };
  var B4 = { id: "https://iiif-parser/empty-agent", type: "Agent", label: {}, logo: o3, seeAlso: o3, homepage: o3 };
  var Q3 = { id: "https://iiif-parser/empty-service", type: "UnknownService" };
  function k2(e3, n2 = {}) {
    if (Array.isArray(e3))
      return k2(e3[0]);
    if (typeof e3 == "string") {
      let [i3, r3] = e3.split("#");
      return r3 ? { type: "SpecificResource", source: { id: i3, type: n2.typeHint || "Unknown" }, selector: { type: "FragmentSelector", value: r3 } } : { type: "SpecificResource", source: { id: i3, type: n2.typeMap && n2.typeMap[i3] || n2.typeHint || "Unknown" } };
    }
    if (e3.type === "Choice" || e3.type === "List" || e3.type === "Composite" || e3.type === "Independents")
      return k2(e3.items[0]);
    if (!e3.type && "source" in e3 && (e3.type = "SpecificResource"), e3.type === "SpecificResource")
      return e3.source.type === "Canvas" && e3.source.partOf && typeof e3.source.partOf == "string" && (e3.source.partOf = [{ id: e3.source.partOf, type: "Manifest" }]), e3.selector ? { type: "SpecificResource", source: e3.source, selector: e3.selector } : { type: "SpecificResource", source: e3.source };
    if (e3.id) {
      e3.type === "Canvas" && e3.partOf && typeof e3.partOf == "string" && (e3.partOf = [{ id: e3.partOf, type: "Manifest" }]);
      let [i3, r3] = e3.id.split("#");
      return r3 ? { type: "SpecificResource", source: { ...e3, id: i3 }, selector: { type: "FragmentSelector", value: r3 } } : { type: "SpecificResource", source: { ...e3, id: i3 } };
    }
    return { type: "SpecificResource", source: e3 };
  }
  function se2() {
    return { Collection: {}, Manifest: {}, Canvas: {}, AnnotationPage: {}, AnnotationCollection: {}, Annotation: {}, ContentResource: {}, Range: {}, Service: {}, Selector: {}, Agent: {} };
  }
  function Z2(e3, n2) {
    if (typeof e3 == "string")
      return { id: e3, type: n2 };
    if (!e3.id)
      throw new Error(`Invalid resource does not have an ID (${JSON.stringify(e3)}, ${n2})`);
    return e3;
  }
  function le2(e3, n2) {
    return (i3, r3) => {
      let t4 = e3[i3] ? e3[i3] : {};
      return (a3, s2) => {
        let c2 = Z2(a3, r3 || i3);
        return c2 && c2.id && i3 ? (t4[c2.id] = t4[c2.id] ? W3(t4[c2.id], c2, { parent: s2.parent, isTopLevel: n2.id === c2.id }) : W3({ id: c2.id, type: c2.type }, c2, { parent: s2.parent, isTopLevel: n2.id === c2.id }), { id: c2.id, type: i3 === "ContentResource" ? i3 : c2.type }) : c2;
      };
    };
  }
  function $3(e3, n2, i3) {
    if (!n2)
      return e3;
    if (Array.isArray(e3)) {
      if (!Array.isArray(n2))
        throw new Error("Cannot merge array with non-array");
      let r3 = [...e3];
      for (let t4 of n2)
        if (t4["@id"] && !t4.id && (t4.id = t4["@id"]), t4["@type"] && !t4.type && (t4.type = t4["@type"]), t4 != null)
          if (Array.isArray(t4))
            r3.push(t4);
          else if (typeof t4 == "object" && t4.id && t4.type) {
            let a3 = r3.findIndex((s2) => s2.id === t4.id && s2.type === t4.type);
            a3 >= 0 && (r3[a3] = $3(r3[a3], t4));
          } else
            e3.indexOf(t4) === -1 && r3.push(t4);
      return r3;
    } else if (typeof e3 == "object") {
      if (Array.isArray(n2) || typeof n2 != "object")
        throw new Error("Cannot merge object with non-object");
      let r3 = { ...e3 }, t4 = [], a3 = [], s2 = Object.keys(e3).filter((l4) => l4 !== d4 && l4 !== "id" && l4 !== "type"), c2 = {}, A3 = {};
      for (let [l4, u3] of Object.entries(n2)) {
        if (l4 === d4 || l4 === "id" || l4 === "type")
          continue;
        let y4 = r3[l4];
        y4 === u3 ? a3.push(l4) : y4 === o3 || !y4 ? (t4.push(l4), r3[l4] = u3) : (y4 && u3 && (c2[l4] = y4, A3[l4] = u3), r3[l4] = $3(y4, u3), r3[l4] === c2[l4] && (a3.push(l4), delete c2[l4]));
      }
      if (i3 && (i3.parent && i3.parent.id || i3.isTopLevel)) {
        let l4 = [], u3 = {};
        if (i3.parent ? u3[g3] = i3.parent.id : i3.isTopLevel && (u3[g3] = e3.id), r3[d4] && r3[d4].length) {
          let y4 = !(r3[d4] || []).find((v3) => v3["@explicit"]), C2 = t4.length > 0 || a3.length !== s2.length;
          if (y4 && C2)
            for (let v3 of r3[d4]) {
              let p4 = { ...v3 }, _3 = Object.keys(c2);
              if (p4) {
                p4["@explicit"] = true;
                for (let M3 of s2)
                  M3 !== d4 && (p4[M3] = w2);
                for (let M3 of _3)
                  p4[M3] = c2[M3];
              }
              l4.push(p4);
            }
          else
            l4.push(...r3[d4]);
          if (C2) {
            let v3 = Object.keys(A3);
            u3["@explicit"] = true;
            for (let p4 of t4)
              u3[p4] = w2;
            for (let p4 of a3)
              u3[p4] = w2;
            for (let p4 of v3)
              u3[p4] = A3[p4];
          }
        }
        u3.id = r3.id, u3.type = r3.type, l4.push(u3), r3[d4] = l4;
      }
      return r3;
    } else if (e3)
      return e3;
    return n2;
  }
  function W3(e3, n2, i3) {
    if (typeof e3 == "string")
      return e3;
    if (n2.id !== e3.id || n2.type !== e3.type) {
      if (n2.type === "ImageService3")
        return n2;
      if (e3.type === "ImageService3")
        return e3;
      throw new Error(`Can only merge entities with identical identifiers and type! ${n2.type}(${n2.id}) => ${e3.type}(${e3.id})`);
    }
    return $3({ ...e3 }, n2, i3);
  }
  function ce2(e3) {
    return (n2, i3) => (r3) => {
      let { id: t4, type: a3 } = Z2(r3, i3 || n2);
      if (typeof t4 > "u")
        throw new Error("Found invalid entity without an ID.");
      return n2 === "ContentResource" || n2 === "Service" ? e3[t4] = n2 : e3[t4] = a3, r3;
    };
  }
  function fe2(e3) {
    let n2 = Object.assign({}, e3);
    if (n2["@id"] && (n2.id = n2["@id"]), n2["@type"] && (n2.type = n2["@type"]), n2.service) {
      let i3 = [];
      n2.service = Array.isArray(n2.service) ? n2.service : [n2.service];
      for (let r3 of n2.service)
        i3.push({ id: r3["@id"] || r3.id, type: r3["@type"] || r3.type });
      n2.service = i3;
    }
    return Object.assign({}, Q3, n2);
  }
  function ue2(e3) {
    return (n2) => {
      e3.Service = e3.Service ? e3.Service : {};
      let i3 = n2.id || n2["@id"], r3 = fe2(n2);
      return r3 && r3.id && (e3.Service[r3.id] ? e3.Service[i3] = W3(e3.Service[i3], r3) : e3.Service[i3] = r3), n2;
    };
  }
  function de2(e3) {
    let n2 = JSON.stringify(e3), i3 = 5381, r3 = n2.length;
    for (; r3; )
      i3 = i3 * 33 ^ n2.charCodeAt(--r3);
    let a3 = (i3 >>> 0).toString(16);
    return a3.length % 2 ? "0" + a3 : a3;
  }
  function U2(e3) {
    return (n2) => typeof n2 == "string" ? { id: n2, type: e3 } : n2.id ? n2.type ? n2 : { type: e3, ...n2 } : { id: `vault://${de2(n2)}`, type: e3, ...n2 };
  }
  function E3(e3) {
    return (n2) => ({ ...e3, ...n2 });
  }
  function D2(e3) {
    return Array.isArray(e3) ? e3 : [e3];
  }
  function pe2(e3) {
    return e3.body && (e3.body = D2(e3.body)), e3.seeAlso && (e3.seeAlso = D2(e3.seeAlso)), e3.audience && (e3.audience = D2(e3.audience)), e3.accessibility && (e3.accessibility = D2(e3.accessibility)), e3.motivation && (e3.motivation = D2(e3.motivation)), e3;
  }
  function ee2(e3, { typeHint: n2, partOfTypeHint: i3 } = {}) {
    if (typeof e3 == "string" && (e3 = { id: e3, type: n2 || "unknown" }), v2(e3))
      return typeof e3.source == "string" && (e3.source = { id: e3.source, type: n2 || "unknown" }), e3.source.type === "Canvas" && e3.source.partOf && typeof e3.source.partOf == "string" && (e3.source.partOf = [{ id: e3.source.partOf, type: i3 || "Manifest" }]), e3;
    let r3;
    if ((e3.id || "").indexOf("#") !== -1) {
      let [t4, a3] = (e3.id || "").split("#");
      e3.id = t4, a3 && (r3 = { type: "FragmentSelector", value: a3 });
    }
    return { type: "SpecificResource", source: e3, selector: r3 };
  }
  function ye2(e3) {
    let n2 = Object.assign({}, e3);
    return e3 && e3.items && (n2.items = e3.items.map((i3) => typeof i3 == "string" || i3.type === "Canvas" ? ee2(i3) : i3)), n2;
  }
  function me2(e3) {
    let n2 = Object.assign({}, e3);
    return n2.start ? (n2.start = ee2(n2.start, { typeHint: "Canvas" }), n2) : e3;
  }
  function ve2(e3) {
    let n2 = Object.assign({}, e3);
    return n2.target ? (n2.target = k2(n2.target, { typeHint: "Canvas" }), n2) : e3;
  }
  function ge2(e3) {
    return e3;
  }
  function q2(e3) {
    return typeof e3.items > "u" && (e3[T2] = true), e3;
  }
  function Ue(e3) {
    let n2 = be(e3), i3 = se2(), r3 = {}, t4 = le2(i3, n2), a3 = ce2(r3), c2 = new l3({ collection: [q2, E3(X2), a3("Collection"), t4("Collection")], manifest: [q2, E3(Y2), me2, a3("Manifest"), t4("Manifest")], canvas: [E3(G3), a3("Canvas"), t4("Canvas")], annotationPage: [q2, U2("AnnotationPage"), E3(K2), a3("AnnotationPage"), t4("AnnotationPage")], annotation: [U2("Annotation"), pe2, ve2, a3("Annotation"), t4("Annotation")], contentResource: [U2("ContentResource"), a3("ContentResource"), t4("ContentResource")], range: [E3(J2), ye2, a3("Range", "Canvas"), t4("Range", "Canvas")], agent: [E3(B4), a3("Agent"), t4("Agent")], specificResource: [ge2], service: [ue2(i3)] }).traverseUnknown(n2);
    return { entities: i3, resource: c2, mapping: r3 };
  }
  function he2(e3) {
    let n2 = {};
    for (let [i3, r3] of e3) {
      if (i3 === j4 && r3 !== m4)
        return r3;
      r3 !== m4 && typeof r3 < "u" && r3 !== null && (n2[i3] = r3);
    }
    return n2;
  }
  function We(e3, n2, i3) {
    if (!n2.type || !n2.id)
      throw new Error("Unknown entity");
    if (!i3[n2.type])
      throw new Error(`Serializer not found for ${n2.type}`);
    function r3(t4, a3, s2 = 0) {
      let c2 = i3[t4.type];
      if (!c2)
        return m4;
      if (s2 > 20)
        throw new Error("Circular reference: " + t4.id + " " + t4.type);
      let [A3, l4] = F3(e3, t4.type ? t4 : t4.id, a3) || (t4.id && t4.type ? t4 : null);
      if (!A3)
        return m4;
      let u3 = c2(A3, e3, { parent: a3, isTopLevel: n2.id === t4.id, fullResource: l4 }), y4 = u3.next();
      for (; !y4.done; ) {
        let C2 = y4.value, v3 = m4;
        if (C2)
          if (Array.isArray(C2)) {
            let p4 = [];
            for (let _3 of C2)
              p4.push(r3(_3, t4, s2 + 1));
            v3 = p4;
          } else
            v3 = r3(C2, t4, s2 + 1);
        y4 = u3.next(v3);
      }
      return y4.value === m4 ? m4 : he2(y4.value);
    }
    return r3(n2);
  }
  function P4(e3, { allowSourceString: n2 = true, allowString: i3 = false, allowedStringType: r3 } = {}) {
    let t4 = (a3) => {
      if (n2 && a3 && a3.source && typeof a3.source != "string") {
        let s2 = Object.keys(a3.source);
        if (a3.source.id && a3.source.type && s2.length === 2)
          return { ...a3, source: a3.source.id };
      }
      return a3;
    };
    if (e3) {
      if (e3.source && e3.source.partOf)
        return t4(e3);
      let a3 = Object.keys(e3);
      if (a3.length === 2 && e3.type && e3.source || a3.length === 3 && e3.type && e3.source && a3.indexOf("selector") !== -1 && !e3.selector)
        return i3 && (!r3 || r3 === e3.source.type) ? e3.source.id : e3.source.type === "ContentResource" ? { type: "SpecificResource", source: e3.source.id } : e3.source;
      if (e3.selector && !Array.isArray(e3.selector) && typeof e3.selector != "string" && e3.selector.type === "FragmentSelector") {
        let s2 = `${e3.source.id}#${e3.selector.value}`;
        return i3 ? s2 : { id: s2, type: e3.source.type };
      }
    }
    return t4(e3);
  }
  function O4(e3) {
    if (!e3)
      return;
    let n2 = Object.keys(e3);
    if (n2.length !== 0) {
      if (n2.length === 1) {
        let i3 = n2[0];
        if (!i3)
          return "";
        let r3 = (e3[i3] || []).join("");
        return i3 === "@none" || i3 === "none" || i3 === "en" ? r3 : { "@language": i3, "@value": r3 };
      }
      return n2.map((i3) => ({ "@language": i3, "@value": (e3[i3] || []).join("") }));
    }
  }
  function ne2(e3) {
    return Array.isArray(e3) ? e3.map((n2) => ne2(n2)) : typeof e3 == "string" ? e3 : e3.type && e3.type === "Canvas" ? e3.id : e3;
  }
  function h4(e3, n2 = false) {
    if (e3)
      return e3.length > 1 && !n2 ? e3 : e3[0] || void 0;
  }
  function Se(e3) {
    if (e3) {
      if (typeof e3 == "string")
        return { "@id": e3 };
      if ("@id" in e3) {
        let n2 = { ...e3 };
        return delete n2["@type"], n2;
      }
      return { "@context": "http://iiif.io/api/image/2/context.json", "@id": e3.id, profile: `http://iiif.io/api/image/2/profiles/${e3.profile}.json` };
    }
  }
  function N3(e3, n2) {
    return [["@id", e3.id], ["@type", n2], ["format", e3.format], ["height", e3.height], ["width", e3.width], ["viewingDirection", e3.viewingDirection !== "left-to-right" ? e3.viewingDirection : void 0], ["license", e3.license ? e3.license : void 0]];
  }
  function* x3(e3) {
    let n2 = e3.provider ? yield e3.provider[0] : void 0;
    return [["label", O4(e3.label)], ["metadata", e3.metadata && e3.metadata.length ? e3.metadata.map((i3) => ({ label: O4(i3.label) || "", value: O4(i3.value) || "" })) : void 0], ["description", O4(e3.summary)], ["thumbnail", h4(yield e3.thumbnail)], ["navDate", e3.navDate], ["logo", n2 ? h4(n2.logo) : void 0], ["homepage", n2 ? n2.homepage : void 0], ["attribution", e3.requiredStatement ? O4(e3.requiredStatement.value) : void 0]];
  }
  function* I2(e3) {
    let n2 = e3.start && e3.start.type && e3.start.type === "SpecificResource" ? P4(e3.start) : e3.start;
    return [["seeAlso", h4(yield e3.seeAlso)], ["service", h4((e3.service || []).map(Se))], ["rendering", h4(yield e3.rendering)], ["startCanvas", n2 ? n2.id : void 0]];
  }
  function Re(e3) {
    return e3.type === "SpecificResource";
  }
  function Ae2(e3) {
    return e3 && e3.type === "FragmentSelector";
  }
  function Ce2(e3) {
    if (e3 && Re(e3)) {
      let n2 = e3.id, i3 = e3.selector ? Array.isArray(e3.selector) ? e3.selector[0] : e3.selector : void 0;
      return Ae2(i3) && (n2 += "#" + i3.value), n2;
    }
    return e3?.id;
  }
  var Ge = { Manifest: function* (e3, n2, { isTopLevel: i3 }) {
    return [...i3 ? [["@context", "http://iiif.io/api/presentation/2/context.json"]] : [], ...N3(e3, "sc:Manifest"), ...yield* x3(e3), ...yield* I2(e3), ["sequences", [{ "@id": `${e3.id}/sequence0`, "@type": "sc:Sequence", canvases: yield e3.items }]], ["structures", yield e3.structures]];
  }, Canvas: function* (e3) {
    let i3 = (yield e3.items)[0];
    return [...N3(e3, "sc:Canvas"), ...yield* x3(e3), ...yield* I2(e3), ["images", i3 ? [i3.resources] : void 0], ["annotations", e3.annotations && e3.annotations.length ? h4(yield e3.annotations) : void 0]];
  }, AnnotationPage: function* (e3) {
    return [...N3(e3, "sc:AnnotationList"), ...yield* x3(e3), ["resources", e3.items && e3.items.length ? h4(yield e3.items) : void 0]];
  }, Annotation: function* (e3) {
    return [["@id", e3.id], ["@type", "oa:Annotation"], ["motivation", "sc:painting"], ["on", ne2(e3.target)], ["resource", h4(yield e3.body, true)]];
  }, ContentResource: function* (e3) {
    switch (e3.type) {
      case "Image":
        return [...N3(e3, "dctypes:Image"), ...yield* x3(e3), ...yield* I2(e3)];
      case "Text":
      case "Dataset":
      default:
        return [...N3(e3, void 0), ...yield* x3(e3)];
    }
  }, AnnotationCollection: function* (e3) {
    return [["@id", e3.id], ["@type", "sc:Layer"], ["label", O4(e3.label)]];
  }, Collection: function* (e3) {
    return [...N3(e3, "sc:Collection"), ...yield* x3(e3), ...yield* I2(e3), ["members", yield* e3.items]];
  }, Range: function* (e3) {
    let n2 = [], i3 = [];
    if (e3.items)
      for (let r3 of e3.items) {
        let t4 = r3.type === "SpecificResource" ? r3.source : r3;
        if (t4) {
          let a3 = yield t4;
          n2.push({ "@id": Ce2(r3), "@type": t4.type, label: a3 ? a3.label : void 0, within: e3.id }), t4.type === "Canvas" && i3.push(t4.id);
        }
      }
    return [...N3(e3, "sc:Range"), ...yield* x3(e3), ...yield* I2(e3), ["canvases", i3.length === n2.length ? i3 : void 0], ["members", i3.length !== n2.length ? n2 : void 0]];
  } };
  function b4(e3) {
    return [["id", e3.id?.startsWith("vault://") ? void 0 : e3.id], ["type", e3.type], ["format", e3.format], ["profile", e3.profile], ["height", e3.height || void 0], ["width", e3.width || void 0], ["duration", e3.duration || void 0], ["viewingDirection", e3.viewingDirection !== "left-to-right" ? e3.viewingDirection : void 0], ["behavior", e3.behavior && e3.behavior.length ? e3.behavior : void 0], ["timeMode", e3.timeMode], ["motivation", Array.isArray(e3.motivation) ? e3.motivation[0] : e3.motivation], [d4, m4]];
  }
  function f4(e3) {
    if (e3 === m4 || !e3 || e3.length === 0)
      return;
    let n2 = e3.filter((i3) => i3 !== m4);
    if (n2.length !== 0)
      return n2;
  }
  function te2(e3) {
    if (e3 && e3.type && e3.type === "ImageService2") {
      let { id: n2, type: i3, profile: r3, ...t4 } = e3, a3 = typeof r3 == "string" ? r3 : Array.isArray(r3) ? r3.find((s2) => typeof s2 == "string") : "";
      return { "@id": n2, "@type": i3, profile: a3 ? a3.startsWith("http") ? a3 : `http://iiif.io/api/image/2/${a3}.json` : "http://iiif.io/api/image/2/level0.json", ...t4 };
    }
    return e3;
  }
  function ie2(e3) {
    if (Array.isArray(e3) || (e3 = e3 ? [e3] : []), !(!e3 || e3.length === 0))
      return e3.map(te2);
  }
  function* S4(e3) {
    return [["label", e3.label], ["metadata", f4(e3.metadata)], ["summary", e3.summary], ["requiredStatement", e3.requiredStatement], ["rights", Array.isArray(e3.rights) ? e3.rights[0] || void 0 : e3.rights || void 0], ["navDate", e3.navDate], ["language", e3.language], ["thumbnail", f4(yield e3.thumbnail)], ["placeholderCanvas", yield e3.placeholderCanvas], ["accompanyingCanvas", yield e3.accompanyingCanvas], ["provider", f4(yield e3.provider)]];
  }
  function* R4(e3, n2) {
    let i3 = [];
    for (let r3 of e3.partOf || [])
      r3.type === "Manifest" && n2.type === "Manifest" || i3.push(yield r3);
    return [["seeAlso", f4(yield e3.seeAlso)], ["service", f4(ie2(e3.service))], ["services", f4(ie2(e3.services))], ["rendering", f4(yield e3.rendering)], ["supplementary", f4(yield e3.supplementary)], ["homepage", f4(yield e3.homepage)], ["logo", f4(yield e3.logo)], ["partOf", f4(i3)], ["start", e3.start ? P4(e3.start) : e3.start]];
  }
  var Qe2 = { Manifest: function* (e3, n2, { isTopLevel: i3 }) {
    if (!i3)
      return [...b4(e3), ...yield* S4(e3), ["navPlace", e3.navPlace]];
    let r3 = "http://iiif.io/api/presentation/3/context.json";
    return (e3.navPlace || re2(e3)) && (r3 = ["http://iiif.io/api/presentation/3/context.json", "http://iiif.io/api/extension/navplace/context.json"]), [["@context", e3["@context"] ? e3["@context"] : r3], ...b4(e3), ...yield* S4(e3), ...yield* R4(e3), ["items", yield e3.items], ["structures", f4(yield e3.structures)], ["annotations", f4(yield e3.annotations)], ["navPlace", e3.navPlace]];
  }, Canvas: function* (e3, n2, { parent: i3 }) {
    return i3 && i3.type !== "Manifest" && i3.type !== "Canvas" ? [["id", e3.id]] : [...b4(e3), ...yield* S4(e3), ...yield* R4(e3, i3), ["items", yield e3.items], ["annotations", f4(yield e3.annotations)], ["navPlace", e3.navPlace]];
  }, Agent: function* (e3) {
    return [["id", e3.id], ["type", "Agent"], ["label", e3.label], ...yield* R4(e3)];
  }, AnnotationPage: function* (e3) {
    let n2 = Object.entries(e3).map(([r3, t4]) => [r3, Array.isArray(t4) ? f4(t4) : t4]).filter(([r3, t4]) => r3 !== "items" && r3 !== "id" && r3 !== d4 && r3 !== g3 && r3 !== T2), i3 = yield e3.items;
    return [["id", e3.id?.startsWith("vault://") ? void 0 : e3.id], ...n2, ...yield* R4(e3), ["items", i3.length || e3[T2] === false ? i3 : m4]];
  }, Service: function* (e3) {
    return [[j4, te2(e3)]];
  }, Annotation: function* (e3) {
    let n2 = Object.entries(e3).map(([r3, t4]) => r3 === "motivation" ? [r3, Array.isArray(t4) ? t4[0] : t4] : r3 === "target" ? [r3, P4(t4, { allowString: true, allowSourceString: true, allowedStringType: "Canvas" })] : [r3, Array.isArray(t4) ? f4(t4) : t4]).filter(([r3]) => r3 !== "body" && r3 !== d4 && r3 !== T2), i3;
    if (Array.isArray(e3.body)) {
      let r3 = [];
      for (let t4 of e3.body)
        if (t4 && v2(t4)) {
          let a3 = { ...t4 };
          t4.source.type !== "Canvas" ? a3.source = yield t4.source : a3.source = t4.source, r3.push(P4(a3, { allowSourceString: true }));
        } else
          r3.push(yield t4);
      i3 = r3;
    } else
      e3.body && v2(e3.body) ? (i3 = { ...e3.body }, i3.source = yield e3.body.source) : i3 = yield e3.body;
    return [...n2, ...yield* S4(e3), ...yield* R4(e3), ["body", i3.length === 1 ? i3[0] : i3]];
  }, ContentResource: function* (e3) {
    return ze([...b4(e3), ...yield* S4(e3), ...yield* R4(e3), ["annotations", f4(yield e3.annotations)], ["items", f4(yield e3.items)]], e3);
  }, AnnotationCollection: function* (e3) {
    return [["id", e3.id], ["type", "AnnotationCollection"], ["label", e3.label]];
  }, Collection: function* (e3, n2, { isTopLevel: i3 }) {
    if (i3) {
      let r3 = "http://iiif.io/api/presentation/3/context.json";
      return (e3.navPlace || re2(e3)) && (r3 = ["http://iiif.io/api/extension/navplace/context.json", "http://iiif.io/api/presentation/3/context.json"]), [["@context", r3], ...b4(e3), ...yield* S4(e3), ...yield* R4(e3), ["items", f4(yield e3.items)], ["navPlace", e3.navPlace]];
    }
    return [...b4(e3), ...yield* S4(e3), ["navPlace", e3.navPlace]];
  }, Range: function* (e3) {
    let n2 = [];
    for (let i3 of e3.items)
      i3.type === "Range" ? n2.push(yield i3) : i3 && i3.type === "SpecificResource" ? n2.push(P4(i3)) : n2.push(i3);
    return [...b4(e3), ...yield* S4(e3), ...yield* R4(e3), ["items", n2], ["annotations", f4(yield e3.annotations)], ["navPlace", e3.navPlace]];
  } };
  function ze(e3, n2) {
    let i3 = Object.keys(n2), r3 = e3.map(([t4]) => t4);
    for (let t4 of i3)
      t4 === d4 || t4 === T2 || r3.indexOf(t4) === -1 && typeof n2[t4] < "u" && e3.push([t4, n2[t4]]);
    return e3;
  }
  function re2(e3) {
    if (!e3.items || !Array.isArray(e3.items))
      return false;
    for (let n2 of e3.items)
      if (n2.navPlace)
        return true;
    return false;
  }

  // src/i18n.ts
  function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false, skipLanguages = []) {
    if (skipLanguages.length) {
      languages = languages.filter((l4) => skipLanguages.indexOf(l4) === -1);
    }
    if (!languages || languages.length === 0) {
      return void 0;
    }
    if (languages.length === 1) {
      return languages[0];
    }
    if (!i18nLanguage) {
      if (languages.indexOf("none") !== -1) {
        return "none";
      }
      return languages[0];
    }
    if (languages.indexOf(i18nLanguage) !== -1) {
      return i18nLanguage;
    }
    const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
    if (root && languages.indexOf(root) !== -1) {
      return root;
    }
    for (const lang of i18nLanguages) {
      if (languages.indexOf(lang) !== -1) {
        return lang;
      }
    }
    if (!strictFallback && i18nLanguage) {
      const inverseRoot = languages.map((l4) => l4.indexOf("-") !== -1 ? l4.slice(0, l4.indexOf("-")) : null);
      const inverseIdx = inverseRoot.indexOf(i18nLanguage);
      if (inverseIdx !== -1) {
        return languages[inverseIdx];
      }
      for (const lang of i18nLanguages) {
        const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
        const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
        if (inverseIdx2 !== -1) {
          return languages[inverseIdx2];
        }
      }
    }
    if (languages.indexOf("none") !== -1) {
      return "none";
    }
    if (languages.indexOf("@none") !== -1) {
      return "@none";
    }
    return languages[0];
  }
  function buildLocaleString(inputText, i18nLanguage, options = {}) {
    const {
      strictFallback = false,
      defaultText = "",
      separator = "\n",
      fallbackLanguages = [],
      closest,
      skipLanguages
    } = options;
    const languages = Object.keys(inputText || {});
    const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback, skipLanguages);
    if (!inputText) {
      return defaultText;
    }
    if (typeof inputText === "string") {
      return inputText;
    }
    const candidateText = language ? inputText[language] : void 0;
    if (candidateText && language) {
      if (typeof candidateText === "string") {
        return candidateText;
      }
      if (candidateText.length === 1 && candidateText[0] === "") {
        const skip = options.skipLanguages || [];
        return buildLocaleString(inputText, i18nLanguage, {
          ...options,
          skipLanguages: [...skip, language]
        });
      }
      return candidateText.join(separator);
    }
    return "";
  }
  function getValue(inputText, options = {}) {
    return buildLocaleString(
      inputText,
      options.language || (typeof navigator !== "undefined" ? navigator.language : "en"),
      options
    );
  }
  function getLanguagesFromLanguageMap(languageMap) {
    if (!languageMap)
      return [];
    if (typeof languageMap === "string")
      return [];
    if (Array.isArray(languageMap))
      return [];
    return Object.keys(languageMap).filter((l4) => l4 !== "none");
  }
  function getAvailableLanguagesFromResource(item) {
    const foundLanguages = /* @__PURE__ */ new Set();
    const findLanguages = l3.all((resource) => {
      if ("label" in resource) {
        const languages = getLanguagesFromLanguageMap(resource.label);
        languages.forEach((l4) => foundLanguages.add(l4));
      }
      if ("summary" in resource) {
        const languages = getLanguagesFromLanguageMap(resource.summary);
        languages.forEach((l4) => foundLanguages.add(l4));
      }
      if ("language" in resource) {
        if (typeof resource.language === "string") {
          foundLanguages.add(resource.language);
        }
      }
      if ("requiredStatement" in resource) {
        if (resource.requiredStatement && !Array.isArray(resource.requiredStatement)) {
          if ("label" in resource.requiredStatement) {
            const languages = getLanguagesFromLanguageMap(resource.requiredStatement.label);
            languages.forEach((l4) => foundLanguages.add(l4));
          }
          if ("value" in resource.requiredStatement) {
            const languages = getLanguagesFromLanguageMap(resource.requiredStatement.value);
            languages.forEach((l4) => foundLanguages.add(l4));
          }
        }
      }
      if ("metadata" in resource) {
        if (Array.isArray(resource.metadata)) {
          resource.metadata.forEach((m5) => {
            if ("label" in m5) {
              const languages = getLanguagesFromLanguageMap(m5.label);
              languages.forEach((l4) => foundLanguages.add(l4));
            }
            if ("value" in m5) {
              const languages = getLanguagesFromLanguageMap(m5.value);
              languages.forEach((l4) => foundLanguages.add(l4));
            }
          });
        }
      }
    });
    findLanguages.traverseUnknown(item);
    return Array.from(foundLanguages);
  }
  var iiifString = createStringHelper();
  function createStringHelper(options = {}) {
    return (template, ...params) => {
      let result = "";
      for (let i3 = 0; i3 < template.length; i3++) {
        result += template[i3];
        if (i3 < params.length) {
          const param = params[i3];
          if (param === null || param === void 0) {
            continue;
          } else if (typeof param === "string") {
            result += param;
          } else {
            result += getValue(param, options);
          }
        }
      }
      return result;
    };
  }

  // node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js
  var _slicedToArray = /* @__PURE__ */ function() {
    function sliceIterator(arr, i3) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e2 = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e2;
        }
      }
      return _arr;
    }
    return function(arr, i3) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i3);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var TAU = Math.PI * 2;
  var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
    var x4 = _ref.x, y4 = _ref.y;
    x4 *= rx;
    y4 *= ry;
    var xp = cosphi * x4 - sinphi * y4;
    var yp = sinphi * x4 + cosphi * y4;
    return {
      x: xp + centerx,
      y: yp + centery
    };
  };
  var approxUnitArc = function approxUnitArc2(ang1, ang2) {
    var a3 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x22 = Math.cos(ang1 + ang2);
    var y22 = Math.sin(ang1 + ang2);
    return [{
      x: x1 - y1 * a3,
      y: y1 + x1 * a3
    }, {
      x: x22 + y22 * a3,
      y: y22 - x22 * a3
    }, {
      x: x22,
      y: y22
    }];
  };
  var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
    var sign = ux * vy - uy * vx < 0 ? -1 : 1;
    var dot = ux * vx + uy * vy;
    if (dot > 1) {
      dot = 1;
    }
    if (dot < -1) {
      dot = -1;
    }
    return sign * Math.acos(dot);
  };
  var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rxsq * pypsq + rysq * pxpsq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
  };
  var arcToBezier = function arcToBezier2(_ref2) {
    var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
    var curves = [];
    if (rx === 0 || ry === 0) {
      return [];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return [];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    var segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    for (var i3 = 0; i3 < segments; i3++) {
      curves.push(approxUnitArc(ang1, ang2));
      ang1 += ang2;
    }
    return curves.map(function(curve) {
      var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
      var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x22 = _mapToEllipse2.x, y22 = _mapToEllipse2.y;
      var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x4 = _mapToEllipse3.x, y4 = _mapToEllipse3.y;
      return { x1, y1, x2: x22, y2: y22, x: x4, y: y4 };
    });
  };
  var modules_default = arcToBezier;

  // src/annotation-targets/normalize-svg.ts
  var import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
  var import_abs_svg_path = __toESM(require_abs_svg_path(), 1);
  function parseAndNormalizeSvgPath(path) {
    const parsed = (0, import_parse_svg_path.default)(path);
    const absolute = (0, import_abs_svg_path.default)(parsed);
    let prevCmd;
    let startX = 0;
    let startY = 0;
    let bezierX = 0;
    let bezierY = 0;
    let quadX;
    let quadY;
    let x4 = 0;
    let y4 = 0;
    const out = [];
    for (let i3 = 0; i3 < absolute.length; i3++) {
      let seg = absolute[i3];
      const cmd = seg[0];
      switch (cmd) {
        case "M":
          startX = seg[1];
          startY = seg[2];
          break;
        case "H":
          seg = ["L", seg[1], startY];
          break;
        case "V":
          seg = ["L", startX, seg[1]];
          break;
        case "S":
          {
            let cx = x4;
            let cy = y4;
            if (prevCmd === "C" || prevCmd == "S") {
              cx += cx - bezierX;
              cy += cy - bezierY;
            }
            seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
          }
          break;
        case "T":
          if (prevCmd === "Q" || prevCmd == "T") {
            quadX = x4 * 2 - quadX;
            quadY = y4 * 2 - quadY;
          } else {
            quadX = x4;
            quadY = y4;
          }
          seg = ["Q", quadX, quadY, seg[1], seg[2]];
          break;
        case "Q":
          quadX = seg[1];
          quadY = seg[2];
          break;
        case "A":
          {
            const curves = modules_default({
              px: x4,
              py: y4,
              cx: seg[6],
              cy: seg[7],
              rx: seg[1],
              ry: seg[2],
              xAxisRotation: seg[3],
              largeArcFlag: seg[4],
              sweepFlag: seg[5]
            });
            if (!curves.length) {
              continue;
            }
            for (const [j5, curve] of curves.entries()) {
              seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
              if (j5 < curves.length - 1) {
                out.push(seg);
              }
            }
            seg = seg;
          }
          break;
        case "Z":
          seg = ["L", startX, startY];
          break;
      }
      prevCmd = cmd;
      x4 = seg[seg.length - 2];
      y4 = seg[seg.length - 1];
      if (["C", "Q", "A"].indexOf(cmd) > -1) {
        bezierX = seg[seg.length - 4];
        bezierY = seg[seg.length - 3];
      } else {
        bezierX = x4;
        bezierY = y4;
      }
      out.push(seg);
    }
    return out;
  }

  // src/annotation-targets/bezier.ts
  function flattenQuadraticBezier(start, control, end, tolerance = 1) {
    return new QuadraticBezier(start, control, end).subdivide(tolerance);
  }
  function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
    return new CubicBezier(
      new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
    ).subdivide(tolerance);
  }
  function hypot2(p4) {
    return p4.x * p4.x + p4.y * p4.y;
  }
  function approx_myint(x4) {
    const d5 = 0.67;
    return x4 / (1 - d5 + Math.pow(Math.pow(d5, 4) + 0.25 * x4 * x4, 0.25));
  }
  function approx_inv_myint(x4) {
    const b5 = 0.39;
    return x4 * (1 - b5 + Math.sqrt(b5 * b5 + 0.25 * x4 * x4));
  }
  var QuadraticBezier = class {
    constructor(start, control, end) {
      __publicField(this, "start");
      __publicField(this, "control");
      __publicField(this, "end");
      this.start = start;
      this.control = control;
      this.end = end;
    }
    eval(t4) {
      const mt = 1 - t4;
      return {
        x: this.start.x * mt * mt + 2 * this.control.x * mt * t4 + this.end.x * t4 * t4,
        y: this.start.y * mt * mt + 2 * this.control.y * mt * t4 + this.end.y * t4 * t4
      };
    }
    mapToBasic() {
      const { x: x0, y: y0 } = this.start;
      const { x: x1, y: y1 } = this.control;
      const { x: x22, y: y22 } = this.end;
      const ddx = 2 * x1 - x0 - x22;
      const ddy = 2 * y1 - y0 - y22;
      const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
      const u22 = (x22 - x1) * ddx + (y22 - y1) * ddy;
      const cross = (x22 - x0) * ddy - (y22 - y0) * ddx;
      const paramX0 = u0 / cross;
      const paramX2 = u22 / cross;
      const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
      return { x0, x2: x22, scale, cross };
    }
    subdivide(tolerance) {
      const params = this.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a22 = approx_myint(params.x2);
      const count = 0.5 * Math.abs(a22 - a0) * Math.sqrt(params.scale / tolerance);
      const n2 = Math.ceil(count);
      const u0 = approx_inv_myint(a0);
      const u22 = approx_inv_myint(a22);
      const tValues = [0];
      for (let i3 = 1; i3 < n2; i3++) {
        const u3 = approx_inv_myint(a0 + (a22 - a0) * i3 / n2);
        const t4 = (u3 - u0) / (u22 - u0);
        tValues.push(t4);
      }
      tValues.push(1);
      return tValues.map((t4) => this.eval(t4));
    }
  };
  var CubicBezier = class _CubicBezier {
    /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].
    constructor(coords) {
      __publicField(this, "c");
      this.c = coords;
    }
    weightsum(c0, c1, c2, c3) {
      const x4 = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
      const y4 = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
      return { x: x4, y: y4 };
    }
    eval(t4) {
      const mt = 1 - t4;
      const c0 = mt * mt * mt;
      const c1 = 3 * mt * mt * t4;
      const c2 = 3 * mt * t4 * t4;
      const c3 = t4 * t4 * t4;
      return this.weightsum(c0, c1, c2, c3);
    }
    deriv(t4) {
      const mt = 1 - t4;
      const c0 = -3 * mt * mt;
      const c3 = 3 * t4 * t4;
      const c1 = -6 * t4 * mt - c0;
      const c2 = 6 * t4 * mt - c3;
      return this.weightsum(c0, c1, c2, c3);
    }
    // quadratic bezier with matching endpoints and minimum max vector error
    midpoint_quadbez() {
      const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
      return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
    }
    subsegment(t0, t1) {
      const c2 = new Float64Array(8);
      const p0 = this.eval(t0);
      const p32 = this.eval(t1);
      c2[0] = p0.x;
      c2[1] = p0.y;
      const scale = (t1 - t0) / 3;
      const d1 = this.deriv(t0);
      c2[2] = p0.x + scale * d1.x;
      c2[3] = p0.y + scale * d1.y;
      const d22 = this.deriv(t1);
      c2[4] = p32.x - scale * d22.x;
      c2[5] = p32.y - scale * d22.y;
      c2[6] = p32.x;
      c2[7] = p32.y;
      return new _CubicBezier(c2);
    }
    // Very fancy subdivision scheme
    subdivide(tol) {
      const tol1 = 0.1 * tol;
      const tol2 = tol - tol1;
      const sqrt_tol2 = Math.sqrt(tol2);
      const err2 = hypot2(this.weightsum(1, -3, 3, -1));
      const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
      const quads = [];
      let sum = 0;
      for (let i4 = 0; i4 < n_quads; i4++) {
        const t0 = i4 / n_quads;
        const t1 = (i4 + 1) / n_quads;
        const quad = this.subsegment(t0, t1).midpoint_quadbez();
        const params = quad.mapToBasic();
        const a0 = approx_myint(params.x0);
        const a22 = approx_myint(params.x2);
        const scale = Math.sqrt(params.scale);
        let val2 = Math.abs(a22 - a0) * scale;
        if (Math.sign(params.x0) != Math.sign(params.x2)) {
          const xmin = sqrt_tol2 / scale;
          const cusp_val = sqrt_tol2 * Math.abs(a22 - a0) / approx_myint(xmin);
          val2 = Math.max(val2, cusp_val);
        }
        quads.push({
          quad,
          a0,
          a2: a22,
          val: val2
        });
        sum += val2;
      }
      const count = 0.5 * sum / sqrt_tol2;
      const n2 = Math.ceil(count);
      const result = [{ x: this.c[0], y: this.c[1] }];
      let val = 0;
      let i3 = 0;
      for (let j5 = 1; j5 < n2; j5++) {
        const target = sum * j5 / n2;
        while (val + quads[i3].val < target) {
          val += quads[i3].val;
          i3++;
        }
        const a0 = quads[i3].a0;
        const a22 = quads[i3].a2;
        const u0 = approx_inv_myint(a0);
        const u22 = approx_inv_myint(a22);
        const a3 = a0 + (a22 - a0) * (target - val) / quads[i3].val;
        const u3 = approx_inv_myint(a3);
        const t4 = (u3 - u0) / (u22 - u0);
        result.push(quads[i3].quad.eval(t4));
      }
      result.push({ x: this.c[6], y: this.c[7] });
      return result;
    }
  };

  // src/annotation-targets/parse-selector.ts
  var BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
  var TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(\.[0-9]+)?)?(,([0-9]+(\.[0-9]+)?))?/;
  var RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
  function parseSelector(source, {
    domParser,
    svgPreprocessor,
    iiifRenderingHints
  } = {}) {
    if (Array.isArray(source)) {
      return resolveHints(
        source.reduce(
          (data, nextSource) => {
            const {
              selector,
              selectors,
              iiifRenderingHints: newIiifRenderingHints
            } = parseSelector(nextSource, { domParser, svgPreprocessor, iiifRenderingHints });
            if (selector) {
              if (!data.selector) {
                data.selector = selector;
              }
              data.selectors.push(...selectors);
            }
            if (newIiifRenderingHints) {
              data.iiifRenderingHints = data.iiifRenderingHints || { type: "ImageApiSelector" };
              Object.assign(data.iiifRenderingHints, newIiifRenderingHints);
            }
            return data;
          },
          {
            selector: null,
            selectors: [],
            iiifRenderingHints
          }
        )
      );
    }
    if (!source) {
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    if (typeof source === "string") {
      const [id, fragment] = source.split("#");
      if (!fragment) {
        return resolveHints({
          selector: null,
          selectors: [],
          iiifRenderingHints
        });
      }
      return parseSelector(
        { type: "FragmentSelector", value: fragment },
        { svgPreprocessor, iiifRenderingHints, domParser }
      );
    }
    if (source.type) {
      if (source.type === "PointSelector" && (source.t || source.t === 0)) {
        const selector = {
          type: "TemporalSelector",
          temporal: {
            startTime: source.t
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      if (source.type === "PointSelector" && source.x && source.y) {
        const selector = {
          type: "PointSelector",
          spatial: {
            x: source.x,
            y: source.y
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
    }
    if (isImageApiSelector(source)) {
      const selectors = [];
      if (source.region) {
        const parsedRegion = parseSelector(
          { type: "FragmentSelector", value: "xywh=" + source.region },
          { domParser, svgPreprocessor, iiifRenderingHints }
        );
        selectors.push(...parsedRegion.selectors);
      }
      return resolveHints({
        selector: selectors[0],
        selectors,
        iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source
      });
    }
    if (source.type === "FragmentSelector") {
      const matchBoxSelector = BOX_SELECTOR.exec(source.value);
      if (matchBoxSelector) {
        let selector = {
          type: "BoxSelector",
          spatial: {
            unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
            x: Number.parseFloat(matchBoxSelector[3]),
            y: Number.parseFloat(matchBoxSelector[4]),
            width: Number.parseFloat(matchBoxSelector[5]),
            height: Number.parseFloat(matchBoxSelector[6])
          }
        };
        const matchBoxTimeSelector = source.value.match(TEMPORAL_SELECTOR);
        if (matchBoxTimeSelector) {
          selector = {
            type: "TemporalBoxSelector",
            spatial: selector.spatial,
            temporal: {
              startTime: matchBoxTimeSelector[3] ? Number.parseFloat(matchBoxTimeSelector[3]) : 0,
              endTime: matchBoxTimeSelector[6] ? Number.parseFloat(matchBoxTimeSelector[6]) : void 0
            }
          };
        }
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
      if (matchTimeSelector) {
        const selector = {
          type: "TemporalSelector",
          temporal: {
            startTime: matchTimeSelector[3] ? Number.parseFloat(matchTimeSelector[3]) : 0,
            endTime: matchTimeSelector[6] ? Number.parseFloat(matchTimeSelector[6]) : void 0
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    if (source.type === "SvgSelector" && "value" in source) {
      if (!domParser) {
        if (typeof window !== "undefined") {
          domParser = new window.DOMParser();
        } else {
          console.warn(
            "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
          );
        }
      }
      let points = [];
      let rect;
      let style;
      let svg = svgPreprocessor?.(source.value) ?? source.value;
      let svgShape;
      if (domParser) {
        const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
        if (!svgElement) {
          console.warn(`Illegal SVG selector: ${source.value}`);
          return resolveHints({
            selector: null,
            selectors: [],
            iiifRenderingHints
          });
        }
        const selectorElem = getSelectorElement(svgElement);
        if (selectorElem) {
          points = selectorElem.points;
          svgShape = selectorElem.shapeType;
          rect = [
            Math.min(...points.map((p4) => p4[0])),
            // llx
            Math.min(...points.map((p4) => p4[1])),
            // lly
            Math.max(...points.map((p4) => p4[0])),
            // urx
            Math.max(...points.map((p4) => p4[1]))
            // ury
          ];
          ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });
        }
      }
      const sel = {
        type: "SvgSelector",
        svg,
        svgShape,
        style,
        points: points.length ? points : void 0,
        spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
      };
      return resolveHints({
        selector: sel,
        selectors: [sel],
        iiifRenderingHints
      });
    }
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  function getShapeTypeFromPath(svgPath) {
    const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
      (acc, cmd) => {
        acc[cmd] += 1;
        return acc;
      },
      { C: 0, Q: 0, L: 0, M: 0 }
    );
    const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
    if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
      return "path";
    }
    if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
      if (cmdFrequencies.L === 4) {
        return "rect";
      }
      const lastSeg = svgPath.slice(-1)[0];
      if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
        return "polygon";
      } else {
        return "polyline";
      }
    }
    return "path";
  }
  function getSelectorElement(svgElem) {
    for (const element of Array.from(svgElem.children)) {
      switch (element?.tagName.toLowerCase()) {
        case "g":
          {
            const res = getSelectorElement(element);
            if (res) {
              return res;
            }
          }
          continue;
        case "path": {
          const p4 = element.getAttribute("d");
          if (!p4) {
            continue;
          }
          const normalized = parseAndNormalizeSvgPath(p4);
          return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
        }
        case "circle": {
          const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
          const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
          const r3 = Number.parseFloat(element.getAttribute("r") ?? "0");
          if (!r3) {
            continue;
          }
          const points = [];
          for (let angle = 0; angle <= 360; angle += 12) {
            const rad = angle * Math.PI / 180;
            points.push([cx + r3 * Math.cos(rad), cy + r3 * Math.sin(rad)]);
          }
          return { element, points, shapeType: "circle" };
        }
        case "ellipse": {
          const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
          const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
          const rx = Number.parseFloat(element.getAttribute("rx") ?? "0");
          const ry = Number.parseFloat(element.getAttribute("ry") ?? "0");
          if (!rx && !ry) {
            continue;
          }
          const points = [];
          for (let angle = 0; angle <= 360; angle += 12) {
            const t4 = Math.tan(angle / 360 * Math.PI);
            const px = rx * (1 - t4 ** 2) / (1 + t4 ** 2);
            const py = ry * 2 * t4 / (1 + t4 ** 2);
            points.push([cx + px, cy + py]);
          }
          return { element, points, shapeType: "ellipse" };
        }
        case "line": {
          const x0 = Number.parseFloat(element.getAttribute("x0") ?? "0");
          const y0 = Number.parseFloat(element.getAttribute("y0") ?? "0");
          const x1 = Number.parseFloat(element.getAttribute("x1") ?? "0");
          const y1 = Number.parseFloat(element.getAttribute("y1") ?? "0");
          if (x0 === x1 && y0 === y1) {
            continue;
          }
          return {
            element,
            points: [
              [x0, y0],
              [x1, y1]
            ],
            shapeType: "polyline"
          };
        }
        case "polygon":
        case "polyline": {
          const points = element.getAttribute("points")?.split(" ").map((ps) => ps.split(",").map(Number.parseFloat)) ?? [];
          if (!points.length) {
            continue;
          }
          let shapeType = "polyline";
          if (element.tagName.toLowerCase() === "polygon") {
            points.push(points[0]);
            shapeType = "polygon";
          }
          return { element, points, shapeType };
        }
        case "rect": {
          const x4 = Number.parseFloat(element.getAttribute("x") ?? "0");
          const y4 = Number.parseFloat(element.getAttribute("y") ?? "0");
          const width = Number.parseFloat(element.getAttribute("width") ?? "0");
          const height = Number.parseFloat(element.getAttribute("height") ?? "0");
          if (!width || !height) {
            continue;
          }
          return {
            element,
            points: [
              [x4, y4],
              [x4 + width, y4],
              [x4 + width, y4 + height],
              [x4, y4 + height],
              [x4, y4]
            ],
            shapeType: "rect"
          };
        }
        default:
          continue;
      }
    }
    return null;
  }
  function pathToPoints(normalizedPath) {
    const out = [];
    for (let i3 = 0; i3 < normalizedPath.length; i3++) {
      const startPoint = out[out.length - 1] ?? [0, 0];
      const seg = normalizedPath[i3];
      switch (seg[0]) {
        case "M":
        case "L":
          out.push([seg[1], seg[2]]);
          continue;
        case "C":
          out.push(
            ...flattenCubicBezier(
              { x: startPoint[0], y: startPoint[1] },
              { x: seg[1], y: seg[2] },
              { x: seg[3], y: seg[4] },
              { x: seg[5], y: seg[6] }
            ).map((p4) => [p4.x, p4.y]).slice(1)
            // skip first point, already part of output
          );
          continue;
        case "Q":
          out.push(
            ...flattenQuadraticBezier(
              { x: startPoint[0], y: startPoint[1] },
              { x: seg[1], y: seg[2] },
              { x: seg[3], y: seg[4] }
            ).map((p4) => [p4.x, p4.y]).slice(1)
            // skip first point, already part of output
          );
          continue;
      }
    }
    return out;
  }
  function extractStyles(selectorElement) {
    const style = {};
    if (selectorElement.hasAttribute("fill")) {
      style.fill = selectorElement.getAttribute("fill");
      selectorElement.removeAttribute("fill");
    } else if (selectorElement.style && selectorElement.style.fill) {
      style.fill = selectorElement.style.fill;
    }
    if (style.fill) {
      const rgbaMatch = RGBA_COLOR.exec(style.fill);
      if (rgbaMatch) {
        style.fillOpacity = Number.parseFloat(rgbaMatch[4]);
        style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
      }
    }
    if (selectorElement.hasAttribute("fill-opacity")) {
      style.fillOpacity = Number.parseFloat(selectorElement.getAttribute("fill-opacity"));
      selectorElement.removeAttribute("fill-opacity");
    } else if (selectorElement.style && selectorElement.style.fillOpacity) {
      style.fillOpacity = Number.parseFloat(selectorElement.style.fillOpacity);
    }
    if (selectorElement.hasAttribute("stroke")) {
      style.stroke = selectorElement.getAttribute("stroke");
      selectorElement.removeAttribute("stroke");
    } else if (selectorElement.style && selectorElement.style.stroke) {
      style.stroke = selectorElement.style.stroke;
    }
    if (style.stroke) {
      const rgbaMatch = RGBA_COLOR.exec(style.stroke);
      if (rgbaMatch) {
        style.strokeOpacity = Number.parseFloat(rgbaMatch[4]);
        style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
      }
    }
    if (selectorElement.hasAttribute("stroke-opacity")) {
      style.strokeOpacity = Number.parseFloat(selectorElement.getAttribute("stroke-opacity"));
      selectorElement.removeAttribute("stroke-opacity");
    } else if (selectorElement.style && selectorElement.style.strokeOpacity) {
      style.strokeOpacity = Number.parseFloat(selectorElement.style.strokeOpacity);
    }
    if (selectorElement.hasAttribute("stroke-width")) {
      style.strokeWidth = selectorElement.getAttribute("stroke-width");
      selectorElement.removeAttribute("stroke-width");
    } else if (selectorElement.style && selectorElement.style.strokeWidth) {
      style.strokeWidth = selectorElement.style.strokeWidth;
    }
    if (selectorElement.hasAttribute("stroke-dasharray")) {
      style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
      selectorElement.removeAttribute("stroke-dasharray");
    } else if (selectorElement.style && selectorElement.style.strokeDasharray) {
      style.strokeDasharray = selectorElement.style.strokeDasharray;
    }
    let rootElem = selectorElement;
    while (rootElem.tagName.toLowerCase() !== "svg") {
      rootElem = rootElem.parentElement;
      if (rootElem === null) {
        throw new Error("Could not find root SVG element");
      }
    }
    return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
  }
  function isImageApiSelector(t4) {
    if (!t4)
      return false;
    const type = t4.type || t4["@type"];
    return type === "iiif:ImageApiSelector" || type === "ImageApiSelector";
  }
  function resolveHints(supported) {
    if (supported.iiifRenderingHints) {
      const source = supported.iiifRenderingHints;
      if (source.rotation) {
        const parsedRotation = parseRotation(`${source.rotation}`);
        if (parsedRotation) {
          if (supported.selectors.length) {
            for (const selector of supported.selectors) {
              selector.rotation = parsedRotation;
            }
          } else {
            supported.selectors.push({
              type: "RotationSelector",
              rotation: parsedRotation
            });
          }
        }
      }
    } else {
      delete supported.iiifRenderingHints;
    }
    return supported;
  }
  function parseRotation(input) {
    let num = Number.parseFloat(input);
    if (num && input.startsWith("!")) {
      num = 360 - num;
    }
    if (num) {
      num = num % 360;
    }
    if (num !== num) {
      return 0;
    }
    return num || 0;
  }

  // src/annotation-targets/expand-target.ts
  function expandTarget(target, options = {}) {
    if (Array.isArray(target)) {
      return expandTarget(target[0]);
    }
    if (typeof target === "string") {
      const [id, fragment] = target.split("#");
      if (!fragment) {
        return {
          type: "SpecificResource",
          source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
          selector: null,
          selectors: []
        };
      }
      return expandTarget({
        type: "SpecificResource",
        source: { id, type: "Unknown" },
        selector: {
          type: "FragmentSelector",
          value: fragment
        }
      });
    }
    if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
      return expandTarget(target.items[0]);
    }
    if (!target.type && "source" in target) {
      target.type = "SpecificResource";
    }
    if (target.type === "SpecificResource") {
      if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
        target.source.partOf = [
          {
            id: target.source.partOf,
            type: "Manifest"
          }
        ];
      }
      const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
      return {
        type: "SpecificResource",
        source: target.source,
        selector,
        selectors
      };
    }
    if (target.id) {
      if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
        target.partOf = [
          {
            id: target.partOf,
            type: "Manifest"
          }
        ];
      }
      const [id, fragment] = target.id.split("#");
      if (!fragment) {
        return {
          type: "SpecificResource",
          source: {
            ...target,
            id
          },
          selector: null,
          selectors: []
        };
      }
      return expandTarget({
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: {
          type: "FragmentSelector",
          value: fragment
        }
      });
    }
    return {
      type: "SpecificResource",
      source: target,
      selector: null,
      selectors: []
    };
  }

  // src/content-state.ts
  function validateContentState(annotation, strict = false) {
    if (typeof annotation === "string") {
      if (annotation.startsWith("{")) {
        try {
          const parsed = JSON.parse(annotation);
          return validateContentState(parsed);
        } catch (err) {
          return [false, { reason: "Invalid JSON" }];
        }
      }
      return [true];
    }
    if (Array.isArray(annotation)) {
      for (const anno of annotation) {
        const [valid, reason] = validateContentState(anno);
        if (!valid && reason) {
          return [valid, reason];
        }
      }
      return [true];
    }
    if (annotation.type === "Annotation") {
      return [true];
    }
    if (strict && annotation.type === "Canvas" && !annotation.partOf) {
      return [false, { reason: "Canvas without partOf cannot be loaded" }];
    }
    return [true];
  }
  function serialiseContentState(annotation) {
    return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
  }
  function parseContentState(state, asyncOrFetcher) {
    state = state.trim();
    if (state[0] === "{") {
      return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
    }
    if (state.startsWith("http")) {
      if (!asyncOrFetcher) {
        throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
      }
      return fetch(state).then((r3) => r3.json());
    }
    return parseContentState(decodeContentState(state), asyncOrFetcher);
  }
  function encodeContentState(state) {
    const uriEncoded = encodeURIComponent(state);
    const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
    const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
    return base64url.replace(/=/g, "");
  }
  function decodeContentState(encodedContentState) {
    const base64url = restorePadding(encodedContentState);
    const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
    const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
    return decodeURIComponent(base64Decoded).trim();
  }
  function restorePadding(s2) {
    const pad = s2.length % 4;
    if (pad === 1) {
      throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
    }
    return s2 + (pad ? "====".slice(0, 4 - pad) : "");
  }
  function normaliseContentState(state) {
    if (!state) {
      throw new Error("Content state is empty");
    }
    if (!Array.isArray(state)) {
      state = [state];
    }
    let annoId = "vault://virtual-annotation/" + (/* @__PURE__ */ new Date()).getTime();
    const motivation = ["contentState"];
    const targets = [];
    for (const source of state) {
      if (typeof source === "string") {
        throw new Error("Content state is a [String] type and cannot be inferred");
      }
      if (source.type === "Annotation") {
        annoId = source.id;
        if (Array.isArray(source.motivation)) {
          for (const singleMotivation of source.motivation) {
            if (motivation.indexOf(singleMotivation) === -1) {
              motivation.push(singleMotivation);
            }
          }
        }
        if (Array.isArray(source.target)) {
          for (const target2 of source.target) {
            const expanded = expandTarget(target2);
            targets.push(expanded);
          }
        } else {
          const expanded = expandTarget(source.target);
          targets.push(expanded);
        }
        continue;
      }
      const target = expandTarget(source);
      targets.push(target);
    }
    return {
      id: annoId,
      type: "Annotation",
      motivation: ["contentState", ...state.motivation || []],
      target: targets,
      extensions: {}
    };
  }

  // src/painting-annotations/parse-specific-resource.ts
  function parseSpecificResource(resource) {
    if (resource.type === "SpecificResource") {
      return [resource.source, { selector: resource.selector }];
    }
    return [resource, { selector: null }];
  }

  // src/painting-annotations/helper.ts
  function createPaintingAnnotationsHelper(vault = compatVault) {
    function getAllPaintingAnnotations(canvasOrId) {
      const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
      if (!canvas) {
        return [];
      }
      const annotationPages = vault.get(canvas.items, { parent: canvas });
      const flatAnnotations = [];
      for (const page of annotationPages) {
        flatAnnotations.push(...vault.get(page.items, { parent: page }));
      }
      return flatAnnotations;
    }
    function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
      const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
      const types = [];
      let choices = {
        items: [],
        type: "complex-choice"
      };
      const items = [];
      for (const annotation of paintingAnnotations) {
        if (annotation.type !== "Annotation") {
          throw new Error(`getPaintables() accept either a canvas or list of annotations`);
        }
        const references = Array.from(Array.isArray(annotation.body) ? annotation.body : [annotation.body]);
        for (const reference of references) {
          const [ref, { selector }] = parseSpecificResource(reference);
          const body = vault.get(ref);
          const type = (body.type || "unknown").toLowerCase();
          if (type === "choice") {
            const nestedBodies = vault.get(body.items, { parent: body.id });
            const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b5) => b5.id === cid)).filter(Boolean) : [nestedBodies[0]];
            if (selected.length === 0) {
              selected.push(nestedBodies[0]);
            }
            choices.items.push({
              type: "single-choice",
              items: nestedBodies.map((b5) => ({
                id: b5.id,
                label: b5.label,
                selected: selected.indexOf(b5) !== -1
              })),
              label: ref.label
            });
            references.push(...selected);
            continue;
          }
          if (types.indexOf(type) === -1) {
            types.push(type);
          }
          items.push({
            type,
            annotationId: annotation.id,
            annotation,
            resource: body,
            target: annotation.target,
            selector
          });
        }
      }
      return {
        types,
        items,
        choice: choices.items.length < 2 ? choices.items[0] || null : choices,
        allChoices: choices.items.length ? choices : null
      };
    }
    function extractChoices(paintingAnnotationsOrCanvas) {
      const { choice } = getPaintables(paintingAnnotationsOrCanvas);
      return choice;
    }
    return {
      getAllPaintingAnnotations,
      getPaintables,
      extractChoices
    };
  }

  // src/shared-utilities.ts
  function hash(object) {
    const text = JSON.stringify(object);
    let numHash = 5381, index = text.length;
    while (index) {
      numHash = numHash * 33 ^ text.charCodeAt(--index);
    }
    const num = numHash >>> 0;
    const hexString = num.toString(16);
    if (hexString.length % 2) {
      return "0" + hexString;
    }
    return hexString;
  }

  // src/ranges.ts
  function createRangeHelper(vault = compatVault) {
    return {
      findFirstCanvasFromRange: (range) => findFirstCanvasFromRange(vault, range),
      findAllCanvasesInRange: (range) => findAllCanvasesInRange(vault, range),
      findManifestSelectedRange: (manifest, canvasId) => findManifestSelectedRange(vault, manifest, canvasId),
      findSelectedRange: (range, canvasId) => findSelectedRange(vault, range, canvasId),
      rangesToTableOfContentsTree: (rangeRefs, label) => rangesToTableOfContentsTree(vault, rangeRefs, label),
      rangeToTableOfContentsTree: (rangeRef) => rangeToTableOfContentsTree(vault, rangeRef)
    };
  }
  function findFirstCanvasFromRange(vault, range) {
    for (const inner of range.items) {
      if (typeof inner === "string") {
        return { id: inner, type: "Canvas" };
      }
      if (inner.type === "Canvas") {
        return inner;
      }
      if (inner.type === "SpecificResource") {
        if (inner.source?.type === "Canvas") {
          return inner.source;
        }
      }
      if (inner.type === "Range") {
        const found = findFirstCanvasFromRange(vault, vault.get(inner));
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  function findFirstCanvasFromRangeWithSelector(vault, range) {
    for (const inner of range.items) {
      if (typeof inner === "string") {
        return { type: "SpecificResource", source: { id: inner, type: "Canvas" } };
      }
      if (inner.type === "Canvas") {
        return { type: "SpecificResource", source: inner };
      }
      if (inner.type === "SpecificResource") {
        if (inner.source?.type === "Canvas") {
          return inner;
        }
      }
      if (inner.type === "Range") {
        const found = findFirstCanvasFromRangeWithSelector(vault, vault.get(inner));
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  function findAllCanvasesInRange(vault, range) {
    const found = [];
    for (const inner of range.items) {
      if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
        if (inner.source.id.indexOf("#") !== -1) {
          found.push({ id: inner.source.id.split("#")[0], type: "Canvas" });
        } else {
          found.push(inner.source);
        }
      }
      if (inner.type === "Range") {
        found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
      }
      if (inner.type === "SpecificResource") {
        const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
        found.push({ id: sourceId, type: "Canvas" });
      }
    }
    return found;
  }
  function findManifestSelectedRange(vault, manifest, canvasId) {
    for (const range of manifest.structures) {
      const found = findSelectedRange(vault, vault.get(range), canvasId);
      if (found) {
        return found;
      }
    }
    return null;
  }
  function findSelectedRange(vault, range, canvasId) {
    for (const inner of range.items) {
      const parsedId = inner?.source?.id?.split("#")[0];
      if (inner.type === "SpecificResource" && inner.source === canvasId) {
        return range;
      }
      if (inner.type === "SpecificResource" && inner.source?.type === "Canvas" && canvasId === parsedId) {
        return range;
      }
      if (inner.type === "Range") {
        const found = findSelectedRange(vault, vault.get(inner), canvasId);
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  function rangesToTableOfContentsTree(vault, rangeRefs, label) {
    if (rangeRefs.length === 0) {
      return null;
    }
    const ranges = vault.get(rangeRefs);
    if (ranges.length === 1) {
      return rangeToTableOfContentsTree(vault, ranges[0]);
    }
    const virtualRoot = {
      id: `vault://virtual-root/${hash(ranges)}`,
      type: "Range",
      label: label || { en: ["Table of Contents"] },
      items: ranges
    };
    return rangeToTableOfContentsTree(vault, virtualRoot);
  }
  function rangeToTableOfContentsTree(vault, rangeRef, seenIds = []) {
    if (!rangeRef)
      return null;
    const range = vault.get(rangeRef, { skipSelfReturn: false });
    const toc = {
      id: range.id,
      type: "Range",
      label: range.label,
      untitled: !range.label,
      isCanvasLeaf: false,
      isRangeLeaf: false,
      items: []
    };
    if (seenIds.indexOf(toc.id) !== -1) {
      toc.id = `vault://${hash(range)}`;
    }
    if (!range.items) {
      return toc;
    }
    if (range.behavior && range.behavior.includes("no-nav")) {
      return null;
    }
    for (const inner of range.items) {
      if (typeof inner === "string") {
        const maybeCanvas = vault.get({ id: inner, type: "Canvas" }, { skipSelfReturn: false });
        const foundCanvas = {
          id: inner,
          type: "Canvas",
          isCanvasLeaf: true,
          isRangeLeaf: false,
          label: maybeCanvas.label || { none: ["Untitled"] },
          untitled: !maybeCanvas.label,
          resource: {
            type: "SpecificResource",
            source: { id: inner, type: "Canvas" }
          }
        };
        if (seenIds.indexOf(foundCanvas.id) !== -1) {
          foundCanvas.id = `vault://${hash(inner)}`;
        }
        seenIds.push(foundCanvas.id);
        continue;
      }
      if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
        const maybeCanvas = vault.get(inner.source);
        const compressed = P4(inner);
        if (!maybeCanvas) {
          continue;
        }
        const foundCanvas = {
          id: compressed.type === "Canvas" ? compressed.id : inner.source.id,
          type: "Canvas",
          isCanvasLeaf: true,
          isRangeLeaf: false,
          label: maybeCanvas.label || { none: ["Untitled"] },
          untitled: !maybeCanvas.label,
          resource: inner
        };
        if (seenIds.indexOf(foundCanvas.id) !== -1) {
          foundCanvas.id = `vault://${hash(inner)}`;
        }
        seenIds.push(foundCanvas.id);
        toc.items.push(foundCanvas);
        continue;
      }
      if (inner.type === "Canvas") {
        const foundCanvas = {
          id: inner.id,
          type: "Canvas",
          label: inner.label,
          isCanvasLeaf: true,
          isRangeLeaf: false,
          resource: {
            type: "SpecificResource",
            source: inner
          }
        };
        if (seenIds.indexOf(foundCanvas.id) !== -1) {
          foundCanvas.id = `vault://${hash(inner)}`;
        }
        seenIds.push(foundCanvas.id);
        continue;
      }
      if (inner.type === "Range") {
        const foundRange = rangeToTableOfContentsTree(vault, inner, seenIds);
        if (foundRange) {
          toc.items.push(foundRange);
        }
        continue;
      }
    }
    toc.firstCanvas = findFirstCanvasFromRangeWithSelector(vault, range);
    toc.isRangeLeaf = toc.items ? toc.items.filter((i3) => i3.type === "Range").length === 0 : true;
    return toc;
  }

  // src/sequences.ts
  function createSequenceHelper(vault = compatVault) {
    return {
      getVisibleCanvasesFromCanvasId: (manifestOrRange, canvasId, preventPaged = false) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),
      getManifestSequence: (manifestOrRange, options = {}) => getManifestSequence(vault, manifestOrRange, options)
    };
  }
  function getVisibleCanvasesFromCanvasId(vault = compatVault, manifestOrRange, canvasId, preventPaged = false) {
    const behavior = manifestOrRange.behavior || [];
    const fullCanvas = canvasId ? vault.get(canvasId) : null;
    if (!fullCanvas) {
      return [];
    }
    const canvasBehavior = fullCanvas.behavior || [];
    const isPaged = preventPaged ? false : behavior.includes("paged");
    const isContinuous = isPaged ? false : behavior.includes("continuous");
    const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
    const isCanvasFacingPages = canvasBehavior.includes("facing-pages");
    const isCanvasNonPaged = canvasBehavior.includes("non-paged");
    if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {
      return [{ id: fullCanvas.id, type: "Canvas" }];
    }
    const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);
    if (isContinuous) {
      return manifestItems;
    }
    const canvasIndex = manifestItems.findIndex((r3) => r3.id === canvasId);
    if (canvasIndex === -1) {
      return [];
    }
    for (const indexes of ordering) {
      if (indexes.includes(canvasIndex)) {
        return indexes.map((index) => manifestItems[index]);
      }
    }
    return [{ id: fullCanvas.id, type: "Canvas" }];
  }
  function getManifestSequence(vault = compatVault, manifestOrRange, { disablePaging, skipNonPaged } = {}) {
    const behavior = manifestOrRange.behavior || [];
    const isPaged = behavior.includes("paged");
    const isContinuous = isPaged ? false : behavior.includes("continuous");
    const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
    const manifestItems = manifestOrRange.type === "Manifest" ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);
    if (isContinuous) {
      return [manifestItems, [manifestItems.map((_3, index) => index)]];
    }
    if (isIndividuals || !isPaged || disablePaging) {
      return [manifestItems, manifestItems.map((_3, index) => [index])];
    }
    const ordering = [];
    let currentOrdering = [];
    const flush = () => {
      if (currentOrdering.length) {
        ordering.push([...currentOrdering]);
        currentOrdering = [];
      }
    };
    let offset = 0;
    let flushNextPaged = false;
    for (let i3 = 0; i3 < manifestItems.length; i3++) {
      const canvas = vault.get(manifestItems[i3]);
      const canvasBehavior = canvas.behavior || [];
      if (canvasBehavior.includes("non-paged")) {
        if (i3 === offset) {
          offset++;
        }
        if (!skipNonPaged) {
          flush();
          ordering.push([i3]);
          flush();
        }
        continue;
      }
      if (i3 === offset || canvasBehavior.includes("facing-pages")) {
        if (currentOrdering.length) {
          flushNextPaged = true;
        }
        flush();
        ordering.push([i3]);
        flush();
        continue;
      }
      currentOrdering.push(i3);
      if (flushNextPaged) {
        flush();
        flushNextPaged = false;
        continue;
      }
      if (currentOrdering.length > 1) {
        flush();
      }
    }
    if (currentOrdering.length) {
      flush();
    }
    return [manifestItems, ordering];
  }

  // src/vault/utility/typesafe-actions-runtime.ts
  var createAction = function createAction2(type) {
    return function() {
      const base = { type, getType: () => type, toString: () => type };
      return (payload2, meta) => ({
        ...base,
        ...payload2 !== void 0 && { payload: payload2 },
        ...meta !== void 0 && { meta }
      });
    };
  };

  // src/vault/actions/entity-actions.ts
  var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
  var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
  var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
  var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
  var UPDATE_REFERENCE = "@iiif/UPDATE_REFERENCE";
  var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
  var ADD_METADATA = "@iiif/ADD_METADATA";
  var REMOVE_METADATA = "@iiif/REMOVE_METADATA";
  var UPDATE_METADATA = "@iiif/UPDATE_METADATA";
  var REORDER_METADATA = "@iiif/REORDER_METADATA";
  var importEntities = createAction(IMPORT_ENTITIES)();
  var modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
  var reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
  var addReference = createAction(ADD_REFERENCE)();
  var removeReference = createAction(REMOVE_REFERENCE)();
  var updateReference = createAction(UPDATE_REFERENCE)();
  var addMetadata = createAction(ADD_METADATA)();
  var updateMetadata = createAction(UPDATE_METADATA)();
  var removeMetadata = createAction(REMOVE_METADATA)();
  var reorderMetadata = createAction(REORDER_METADATA)();
  var entityActions = {
    importEntities,
    modifyEntityField,
    reorderEntityField,
    addReference,
    removeReference,
    updateReference,
    addMetadata,
    removeMetadata,
    updateMetadata,
    reorderMetadata
  };

  // src/vault/actions/mapping-actions.ts
  var ADD_MAPPING = "@iiif/ADD_MAPPING";
  var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
  var addMapping = createAction(ADD_MAPPING)();
  var addMappings = createAction(ADD_MAPPINGS)();

  // src/vault/actions/meta-actions.ts
  var SET_META_VALUE = "@iiif/SET_META_VALUE";
  var SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
  var UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
  var setMetaValue = createAction(SET_META_VALUE)();
  var setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)();
  var unsetMetaValue = createAction(UNSET_META_VALUE)();
  var metaActions = {
    setMetaValue,
    setMetaValueDynamic,
    unsetMetaValue
  };

  // src/vault/actions/request-actions.ts
  var RESOURCE_ERROR = "RESOURCE_ERROR";
  var RESOURCE_LOADING = "RESOURCE_LOADING";
  var RESOURCE_READY = "RESOURCE_READY";
  var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
  var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
  var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
  var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
  var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
  var requestResource = createAction(REQUEST_RESOURCE)();
  var requestError = createAction(REQUEST_ERROR)();
  var requestMismatch = createAction(REQUEST_MISMATCH)();
  var requestComplete = createAction(REQUEST_COMPLETE)();
  var requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)();

  // src/vault/actions/batch-actions.ts
  var BATCH_ACTIONS = "@iiif/BATCH";
  var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
  var batchActions = createAction(BATCH_ACTIONS)();
  var batchImport = createAction(BATCH_IMPORT)();

  // src/vault/utility/action-list-from-resource.ts
  var actionListFromResource = (id, response) => {
    const { entities, resource, mapping } = Ue(response);
    if (resource.id === void 0) {
      return [requestError({ id, message: "ID is not defined in resource." })];
    }
    const actions = [importEntities({ entities }), addMappings({ mapping })];
    if (resource.id !== id) {
      actions.push(addMapping({ id, type: resource.type }));
      actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
    }
    actions.push(requestComplete({ id }));
    return actions;
  };

  // src/vault/utility/are-inputs-equal.ts
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
      return newInputs === lastInputs;
    }
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (let i3 = 0; i3 < newInputs.length; i3++) {
      if (!isEqual(newInputs[i3], lastInputs[i3])) {
        return false;
      }
    }
    return true;
  }

  // src/vault/utility/resolve-if-exists.ts
  function resolveIfExists(state, url, parent) {
    const request = state.iiif.requests[url];
    const resourceType = state.iiif.mapping[url];
    if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    const fullEntity = state.iiif.entities[resourceType][request.resourceUri];
    if (fullEntity && fullEntity[d4]) {
      const framing = fullEntity[d4].find((t4) => {
        return parent ? t4[g3] === parent.id : t4[g3] === fullEntity.id;
      });
      return ae2(fullEntity, framing);
    }
    return fullEntity;
  }

  // src/vault/utility/is-promise.ts
  function isPromise(value) {
    return value && typeof value.then === "function";
  }

  // src/vault/utility/create-fetch-helper.ts
  function createFetchHelper(vault, fetcher, { waitTimeout = 30 } = {}) {
    return (url, options, mapper) => {
      const store = vault.getStore();
      const state = store.getState();
      const request = state.iiif.requests[url];
      if (request) {
        if (request.loadingState === RESOURCE_READY) {
          const resolvedEntity = resolveIfExists(state, url);
          if (resolvedEntity) {
            return resolvedEntity;
          }
        }
        switch (request.loadingState) {
          case RESOURCE_ERROR:
            break;
          case RESOURCE_LOADING: {
            return (async () => {
              let cleanupSubscription;
              let didContinue = false;
              try {
                const resolvedEntity = await Promise.race([
                  new Promise((resolve, reject) => {
                    if (didContinue) {
                      return;
                    }
                    cleanupSubscription = store.subscribe(() => {
                      const latestState = store.getState();
                      if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                        reject();
                        return;
                      }
                      if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                        const maybeResolvedEntity = resolveIfExists(latestState, url);
                        if (maybeResolvedEntity) {
                          resolve(maybeResolvedEntity);
                        } else {
                          reject();
                        }
                      }
                    });
                  }),
                  new Promise(
                    (resolve, reject) => setTimeout(
                      () => {
                        didContinue = true;
                        reject();
                      },
                      waitTimeout * 60 * 1e3
                    )
                  )
                ]);
                if (cleanupSubscription) {
                  cleanupSubscription();
                }
                if (resolvedEntity) {
                  return resolvedEntity;
                }
              } catch (e3) {
                if (cleanupSubscription) {
                  cleanupSubscription();
                }
              }
            })();
          }
        }
      }
      vault.dispatch(requestResource({ id: url }));
      const importResource = (resource) => {
        if (!resource) {
          return void 0;
        }
        if (!resource.id && !resource["@id"]) {
          if (resource["@type"]) {
            resource["@id"] = url;
            resource.id = url;
          } else {
            resource.id = url;
          }
        }
        const toDispatch = actionListFromResource(url, resource);
        vault.dispatch(batchActions({ actions: toDispatch }));
        return resolveIfExists(store.getState(), url);
      };
      try {
        const resourceOrPromise = fetcher(url, options);
        if (isPromise(resourceOrPromise)) {
          return (async () => {
            try {
              let data = await resourceOrPromise;
              if (mapper) {
                data = mapper(data);
              }
              return importResource(data);
            } catch (err) {
              vault.dispatch(requestError({ id: url, message: err.toString() }));
              throw err;
            }
          })();
        }
        return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);
      } catch (err) {
        vault.dispatch(requestError({ id: url, message: err.toString() }));
        throw err;
      }
    };
  }

  // src/vault/utility/get-default-entities.ts
  function getDefaultEntities() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }

  // node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs
  var import_meta2 = {};
  var reduxImpl = (reducer, initial) => (set, _get, api) => {
    api.dispatch = (action) => {
      set((state) => reducer(state, action), false, action);
      return action;
    };
    api.dispatchFromDevtools = true;
    return { dispatch: (...a3) => api.dispatch(...a3), ...initial };
  };
  var redux = reduxImpl;
  var trackedConnections = /* @__PURE__ */ new Map();
  var getTrackedConnectionState = (name) => {
    const api = trackedConnections.get(name);
    if (!api)
      return {};
    return Object.fromEntries(
      Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
    );
  };
  var extractConnectionInformation = (store, extensionConnector, options) => {
    if (store === void 0) {
      return {
        type: "untracked",
        connection: extensionConnector.connect(options)
      };
    }
    const existingConnection = trackedConnections.get(options.name);
    if (existingConnection) {
      return { type: "tracked", store, ...existingConnection };
    }
    const newConnection = {
      connection: extensionConnector.connect(options),
      stores: {}
    };
    trackedConnections.set(options.name, newConnection);
    return { type: "tracked", store, ...newConnection };
  };
  var devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
    const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
    let extensionConnector;
    try {
      extensionConnector = (enabled != null ? enabled : (import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
    } catch (e3) {
    }
    if (!extensionConnector) {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && enabled) {
        console.warn(
          "[zustand devtools middleware] Please install/enable Redux devtools extension"
        );
      }
      return fn(set, get, api);
    }
    const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
    let isRecording = true;
    api.setState = (state, replace, nameOrAction) => {
      const r3 = set(state, replace);
      if (!isRecording)
        return r3;
      const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
      if (store === void 0) {
        connection == null ? void 0 : connection.send(action, get());
        return r3;
      }
      connection == null ? void 0 : connection.send(
        {
          ...action,
          type: `${store}/${action.type}`
        },
        {
          ...getTrackedConnectionState(options.name),
          [store]: api.getState()
        }
      );
      return r3;
    };
    const setStateFromDevtools = (...a3) => {
      const originalIsRecording = isRecording;
      isRecording = false;
      set(...a3);
      isRecording = originalIsRecording;
    };
    const initialState = fn(api.setState, get, api);
    if (connectionInformation.type === "untracked") {
      connection == null ? void 0 : connection.init(initialState);
    } else {
      connectionInformation.stores[connectionInformation.store] = api;
      connection == null ? void 0 : connection.init(
        Object.fromEntries(
          Object.entries(connectionInformation.stores).map(([key, store2]) => [
            key,
            key === connectionInformation.store ? initialState : store2.getState()
          ])
        )
      );
    }
    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      let didWarnAboutReservedActionType = false;
      const originalDispatch = api.dispatch;
      api.dispatch = (...a3) => {
        if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && a3[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn(
            '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
          );
          didWarnAboutReservedActionType = true;
        }
        originalDispatch(...a3);
      };
    }
    connection.subscribe((message) => {
      var _a;
      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error(
              "[zustand devtools middleware] Unsupported action format"
            );
            return;
          }
          return parseJsonThen(
            message.payload,
            (action) => {
              if (action.type === "__setState") {
                if (store === void 0) {
                  setStateFromDevtools(action.state);
                  return;
                }
                if (Object.keys(action.state).length !== 1) {
                  console.error(
                    `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                  );
                }
                const stateFromDevtools = action.state[store];
                if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                  return;
                }
                if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                  setStateFromDevtools(stateFromDevtools);
                }
                return;
              }
              if (!api.dispatchFromDevtools)
                return;
              if (typeof api.dispatch !== "function")
                return;
              api.dispatch(action);
            }
          );
        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState);
              if (store === void 0) {
                return connection == null ? void 0 : connection.init(api.getState());
              }
              return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            case "COMMIT":
              if (store === void 0) {
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            case "ROLLBACK":
              return parseJsonThen(message.state, (state) => {
                if (store === void 0) {
                  setStateFromDevtools(state);
                  connection == null ? void 0 : connection.init(api.getState());
                  return;
                }
                setStateFromDevtools(state[store]);
                connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              });
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, (state) => {
                if (store === void 0) {
                  setStateFromDevtools(state);
                  return;
                }
                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                  setStateFromDevtools(state[store]);
                }
              });
            case "IMPORT_STATE": {
              const { nextLiftedState } = message.payload;
              const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
              if (!lastComputedState)
                return;
              if (store === void 0) {
                setStateFromDevtools(lastComputedState);
              } else {
                setStateFromDevtools(lastComputedState[store]);
              }
              connection == null ? void 0 : connection.send(
                null,
                // FIXME no-any
                nextLiftedState
              );
              return;
            }
            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }
          return;
      }
    });
    return initialState;
  };
  var devtools = devtoolsImpl;
  var parseJsonThen = (stringified, f5) => {
    let parsed;
    try {
      parsed = JSON.parse(stringified);
    } catch (e3) {
      console.error(
        "[zustand devtools middleware] Could not parse the received json",
        e3
      );
    }
    if (parsed !== void 0)
      f5(parsed);
  };
  var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
    const origSubscribe = api.subscribe;
    api.subscribe = (selector, optListener, options) => {
      let listener = selector;
      if (optListener) {
        const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
        let currentSlice = selector(api.getState());
        listener = (state) => {
          const nextSlice = selector(state);
          if (!equalityFn(currentSlice, nextSlice)) {
            const previousSlice = currentSlice;
            optListener(currentSlice = nextSlice, previousSlice);
          }
        };
        if (options == null ? void 0 : options.fireImmediately) {
          optListener(currentSlice, currentSlice);
        }
      }
      return origSubscribe(listener);
    };
    const initialState = fn(set, get, api);
    return initialState;
  };
  var subscribeWithSelector = subscribeWithSelectorImpl;

  // src/vault/store/reducers/mapping-reducer.ts
  var mappingReducer = (state = {}, action) => {
    switch (action.type) {
      case ADD_MAPPING:
        return {
          ...state,
          [action.payload.id]: action.payload.type
        };
      case ADD_MAPPINGS:
        return {
          ...state,
          ...action.payload.mapping
        };
      default:
        return state;
    }
  };

  // src/vault/utility/is-reference-list.ts
  function isReferenceList(state, id, type, key) {
    return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
  }

  // src/vault/utility/quick-merge.ts
  function quickMerge(a3, b5) {
    const newResource = {};
    const added = [];
    for (const [key, value] of Object.entries(a3 || {})) {
      added.push(key);
      const bValue = (b5 || {})[key];
      if (!bValue || bValue.length === 0) {
        newResource[key] = value;
        continue;
      }
      newResource[key] = bValue;
    }
    for (const [key, value] of Object.entries(b5 || {})) {
      if (added.indexOf(key) !== -1) {
        continue;
      }
      newResource[key] = value;
    }
    return newResource;
  }

  // src/vault/store/reducers/entities-reducer.ts
  function payload(action) {
    return action.payload;
  }
  function numberOr(a3, b5) {
    return typeof a3 === "undefined" ? b5 : a3;
  }
  var entitiesReducer = (state = getDefaultEntities(), action) => {
    const updateField = (entity, values) => {
      return {
        ...state,
        [payload(action).type]: {
          ...state[payload(action).type],
          [payload(action).id]: {
            ...entity,
            ...values
          }
        }
      };
    };
    switch (action.type) {
      case MODIFY_ENTITY_FIELD: {
        if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {
          return state;
        }
        const entity = state[payload(action).type][payload(action).id];
        if (typeof entity === "string") {
          return state;
        }
        return updateField(entity, { [payload(action).key]: payload(action).value });
      }
      case REORDER_ENTITY_FIELD: {
        if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
          return state;
        }
        const entity = state[payload(action).type][payload(action).id];
        if (typeof entity === "string") {
          return state;
        }
        const result = Array.from(entity[payload(action).key]);
        const [removed] = result.splice(payload(action).startIndex, 1);
        result.splice(payload(action).endIndex, 0, removed);
        return updateField(entity, { [payload(action).key]: result });
      }
      case IMPORT_ENTITIES: {
        const keys = Object.keys(payload(action).entities);
        const toReturn = { ...state };
        for (const key of keys) {
          const entities = payload(action).entities[key];
          const newEntities = { ...state[key] || {} };
          let changed = false;
          const ids = Object.keys(entities || {}) || [];
          if (entities && ids) {
            for (const id of ids) {
              changed = true;
              newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
            }
            if (changed) {
              toReturn[key] = newEntities;
            }
          }
        }
        return toReturn;
      }
      case ADD_REFERENCE: {
        if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
          return state;
        }
        const entity = state[payload(action).type][payload(action).id];
        const result = Array.from(entity[payload(action).key]);
        result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);
        return updateField(entity, { [payload(action).key]: result });
      }
      case UPDATE_REFERENCE:
      case REMOVE_REFERENCE: {
        if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
          return state;
        }
        const entity = state[payload(action).type][payload(action).id];
        const result = Array.from(entity[payload(action).key]);
        const indexToRemove = numberOr(
          payload(action).index,
          result.findIndex((e3) => e3 && e3.id === payload(action).reference.id)
        );
        if (indexToRemove === -1 || result[indexToRemove]?.id !== payload(action).reference.id) {
          return state;
        }
        if (action.type === UPDATE_REFERENCE) {
          result.splice(indexToRemove, 1, payload(action).reference);
        } else {
          result.splice(indexToRemove, 1);
        }
        return updateField(entity, { [payload(action).key]: result });
      }
      case ADD_METADATA: {
        const entity = state[payload(action).type][payload(action).id];
        if (!entity) {
          return state;
        }
        const metadata = Array.from(entity.metadata || []);
        const actionPayload = payload(action);
        metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {
          label: actionPayload.label,
          value: actionPayload.label
        });
        return updateField(entity, { metadata });
      }
      case REORDER_METADATA: {
        const entity = state[payload(action).type][payload(action).id];
        if (typeof entity === "string" || !entity) {
          return state;
        }
        const metadata = Array.from(entity.metadata || []);
        const [removed] = metadata.splice(payload(action).startIndex, 1);
        metadata.splice(payload(action).endIndex, 0, removed);
        return updateField(entity, { metadata });
      }
      case UPDATE_METADATA:
      case REMOVE_METADATA: {
        const entity = state[payload(action).type][payload(action).id];
        const metadata = Array.from(entity.metadata || []);
        const indexToRemove = payload(action).atIndex;
        if (typeof indexToRemove === "undefined" || indexToRemove === -1 || !metadata[indexToRemove]) {
          return state;
        }
        if (action.type === UPDATE_METADATA) {
          metadata.splice(indexToRemove, 1, { label: payload(action).label, value: payload(action).value });
        } else {
          metadata.splice(indexToRemove, 1);
        }
        return updateField(entity, { metadata });
      }
      default:
        return state;
    }
  };

  // src/vault/store/reducers/request-reducer.ts
  var requestReducer = (state = {}, action) => {
    switch (action.type) {
      case REQUEST_RESOURCE:
      case REQUEST_OFFLINE_RESOURCE:
        return {
          ...state,
          [action.payload.id]: {
            requestUri: action.payload.id,
            loadingState: RESOURCE_LOADING,
            uriMismatch: false,
            resourceUri: action.payload.id
          }
        };
      case REQUEST_MISMATCH:
        return {
          ...state,
          [action.payload.requestId]: {
            ...state[action.payload.requestId] || {},
            uriMismatch: true,
            resourceUri: action.payload.actualId
          },
          [action.payload.actualId]: {
            requestUri: action.payload.requestId,
            loadingState: state[action.payload.requestId].loadingState,
            uriMismatch: true,
            resourceUri: action.payload.actualId
          }
        };
      case REQUEST_ERROR:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_ERROR,
            error: action.payload.message
          }
        };
      case REQUEST_COMPLETE:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_READY,
            error: void 0
          }
        };
    }
    return state;
  };

  // src/vault/store/reducers/meta-reducer.ts
  var metaReducer = (state = {}, action) => {
    const { id, updateValue, value, meta, key } = action && action.payload || {};
    switch (action.type) {
      case SET_META_VALUE: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: value
            }
          }
        };
      }
      case SET_META_VALUE_DYNAMIC: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
            }
          }
        };
      }
      case UNSET_META_VALUE: {
        if (state[id] && state[id][meta] && state[id][meta][key]) {
          return {
            ...state,
            [id]: {
              ...state[id] || {},
              [meta]: {
                ...state[id] ? state[id][meta] || {} : {},
                [key]: void 0
              }
            }
          };
        }
        return state;
      }
      default:
        return state;
    }
  };

  // src/vault/utility/combine-reducers.ts
  function combineReducers(reducers2 = {}) {
    const reducerKeys = Object.keys(reducers2);
    return function combination(state = {}, action) {
      let hasChanged = false;
      const nextState = {};
      for (let i3 = 0; i3 < reducerKeys.length; i3++) {
        const key = reducerKeys[i3];
        nextState[key] = reducers2[key](state[key], action);
        hasChanged = hasChanged || nextState[key] !== state[key];
      }
      return hasChanged ? nextState : state;
    };
  }

  // src/vault/store/reducers/batch-reducer.ts
  function createBatchReducer(rootReducer) {
    return (state, action) => {
      if (action && action.type === BATCH_ACTIONS) {
        return action.payload.actions.reduce(rootReducer, state);
      }
      if (action && action.type === BATCH_IMPORT) {
        return {
          ...state,
          iiif: {
            ...state.iiif,
            ...action.payload.state
          }
        };
      }
      return rootReducer(state, action);
    };
  }

  // src/vault/store/index.ts
  var reducers = combineReducers({
    mapping: mappingReducer,
    entities: entitiesReducer,
    requests: requestReducer,
    meta: metaReducer
  });
  function getDefaultState() {
    return {
      iiif: {
        entities: getDefaultEntities(),
        meta: {},
        mapping: {},
        requests: {}
      }
    };
  }
  function createStore2(options = {}) {
    const {
      enableDevtools = false,
      iiifStoreName = "iiif",
      defaultState = getDefaultState(),
      customReducers = {}
    } = options;
    const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));
    const enabled = Boolean(typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__);
    const dv = !enabled || false ? (a3, r3) => a3 : devtools;
    return createStore(
      //
      subscribeWithSelector(
        //
        dv(
          //
          redux(rootReducer, defaultState),
          { enabled: enableDevtools }
        )
      )
    );
  }

  // src/vault/utility/objects.ts
  function defineProperty(name, prototype, vault, enumerable = true) {
    prototype[DEFINED] = prototype[DEFINED] || [];
    prototype[DEFINED].push(name);
    const cache = /* @__PURE__ */ new Map();
    Object.defineProperty(prototype, name, {
      enumerable,
      get() {
        if (typeof prototype[REFS][name] === "undefined") {
          return void 0;
        }
        const ref = prototype[REFS][name];
        if (!ref) {
          return ref;
        }
        const object = vault.get(prototype[REFS][name], {
          parent: this.id ? { id: this.id, type: this.type } : void 0
        });
        if (!cache.has(object)) {
          cache.clear();
          cache.set(object, wrapObject(object, vault));
        }
        return cache.get(object);
      },
      set(items) {
        const existing = prototype[REFS][name];
        if (existing !== items) {
          if (this[REACTIVE]) {
            vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));
          } else {
            this[REFS][name] = items;
          }
        }
      }
    });
  }
  var REFS = Symbol.for("_refs_");
  var REACTIVE = Symbol.for("_reactive_");
  var DEFINED = Symbol.for("_defined_");
  var PARENT = Symbol.for("_parent_");
  function createPrototype(vault, reactive = false, parent) {
    const prototype = {
      id: "",
      type: "unknown",
      [DEFINED]: [],
      [REFS]: {},
      [PARENT]: parent || null,
      [REACTIVE]: null,
      is(refOrObject) {
        if (typeof refOrObject === "string") {
          return this.id === refOrObject;
        }
        if (refOrObject.id) {
          return refOrObject.id === this.id;
        }
        return false;
      },
      reactive() {
        if (this[REACTIVE]) {
          return;
        }
        this[REACTIVE] = this.subscribe(() => this.refresh(), true);
        return () => {
          this.unreactive();
        };
      },
      refresh() {
        if (this.id) {
          const fresh = this.unwrap();
          for (const key of Object.keys(fresh || {})) {
            if (this[DEFINED].includes(key)) {
              this[REFS][key] = fresh[key];
            } else {
              this[key] = fresh[key];
            }
          }
        }
      },
      unreactive() {
        if (this[REACTIVE]) {
          this[REACTIVE]();
          this[REACTIVE] = null;
        }
      },
      unwrap() {
        if (!this.id) {
          throw new Error("Invalid object");
        }
        const parent2 = this[PARENT];
        return vault.get(this.id, { parent: parent2 ? { id: parent2, type: "unknown" } : void 0 });
      },
      toPresentation3() {
        return vault.toPresentation3(this.unwrap());
      },
      toPresentation2() {
        return vault.toPresentation2(this.unwrap());
      },
      valueOf() {
        return this.unwrap();
      },
      toJSON() {
        const that = this;
        return {
          ...that,
          items: that.items,
          annotations: that.annotations,
          structures: that.structures,
          seeAlso: that.seeAlso,
          service: that.service,
          services: that.services,
          rendering: that.rendering,
          partOf: that.partOf,
          start: that.start,
          supplementary: that.supplementary,
          homepage: that.homepage,
          thumbnail: that.thumbnail,
          placeholderCanvas: that.placeholderCanvas,
          accompanyingCanvas: that.accompanyingCanvas,
          provider: that.provider
        };
      },
      subscribe(subscription, skipInitial = true) {
        return vault.subscribe(
          () => {
            return this.id ? vault.get(this.id) : null;
          },
          subscription,
          skipInitial
        );
      }
    };
    defineProperty("items", prototype, vault);
    defineProperty("annotations", prototype, vault);
    defineProperty("structures", prototype, vault);
    defineProperty("seeAlso", prototype, vault);
    defineProperty("rendering", prototype, vault);
    defineProperty("partOf", prototype, vault);
    defineProperty("start", prototype, vault, false);
    defineProperty("supplementary", prototype, vault);
    defineProperty("homepage", prototype, vault);
    defineProperty("thumbnail", prototype, vault);
    defineProperty("placeholderCanvas", prototype, vault, false);
    defineProperty("accompanyingCanvas", prototype, vault, false);
    defineProperty("provider", prototype, vault);
    defineProperty("body", prototype, vault);
    defineProperty("logo", prototype, vault);
    return prototype;
  }
  function isWrapped(object) {
    return !!object[DEFINED];
  }
  function unwrapObject(object) {
    if (Array.isArray(object)) {
      return object.map((o4) => unwrapObject(o4));
    }
    if (!object || !object.type) {
      return object;
    }
    return { id: object.id, type: object.type };
  }
  function wrapObject(object, vault, reactive = false, parent) {
    if (Array.isArray(object)) {
      return object.map((o4) => wrapObject(o4, vault, reactive));
    }
    if (!object || !object.type || !object.id) {
      return object;
    }
    const prototype = createPrototype(vault, reactive);
    const newObject = Object.create(prototype);
    const wrapped = Object.assign(newObject, object);
    if (reactive) {
      wrapped.reactive();
    }
    return wrapped;
  }

  // src/vault/utility/resolve-type.ts
  function resolveType(type) {
    switch (type) {
      case "Image":
      case "Video":
      case "Sound":
      case "Dataset":
      case "Text":
      case "Composite":
      case "List":
      case "Independents":
      case "Audience":
        return "ContentResource";
      case "ImageService1":
      case "ImageService2":
      case "ImageService3":
        return "Service";
    }
    return type;
  }

  // src/vault/vault.ts
  var Vault = class {
    constructor(options, store) {
      __publicField(this, "options");
      __publicField(this, "store");
      __publicField(this, "emitter");
      __publicField(this, "isBatching", false);
      __publicField(this, "batchQueue", []);
      __publicField(this, "remoteFetcher");
      __publicField(this, "staticFetcher");
      __publicField(this, "defaultFetcher", (url) => {
        return fetch(url).then((r3) => {
          if (r3.status === 200) {
            return r3.json();
          } else {
            const err = new Error(`${r3.status} ${r3.statusText}`);
            err.name = `HTTPError`;
            throw err;
          }
        });
      });
      this.options = Object.assign(
        {
          reducers: {},
          customFetcher: this.defaultFetcher,
          enableDevtools: true
        },
        options || {}
      );
      this.store = store || createStore2({
        customReducers: this.options.reducers,
        defaultState: this.options.defaultState,
        enableDevtools: this.options.enableDevtools
      });
      this.emitter = mitt_default();
      this.remoteFetcher = createFetchHelper(this, this.options.customFetcher);
      this.staticFetcher = createFetchHelper(this, (id, json) => json);
    }
    batch(cb) {
      this.isBatching = true;
      try {
        cb(this);
        this.isBatching = false;
        this.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e3) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e3;
      }
      this.batchQueue = [];
    }
    async asyncBatch(cb) {
      this.isBatching = true;
      try {
        await cb(this);
        this.isBatching = false;
        this.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e3) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e3;
      }
      this.batchQueue = [];
    }
    modifyEntityField(entity, key, value) {
      this.dispatch(
        entityActions.modifyEntityField({
          id: entity.id,
          type: entity.type,
          key,
          value
        })
      );
    }
    dispatch(action) {
      if (!this.isBatching) {
        if (action.type === BATCH_ACTIONS) {
          for (const realAction of action.payload.actions) {
            this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });
          }
          this.store.dispatch(action);
          const state2 = this.getState();
          for (const realAction of action.payload.actions) {
            this.emitter.emit(`after:${realAction.type}`, { action: realAction, state: state2 });
          }
          return;
        }
        this.emitter.emit(action.type, { action, state: this.store.getState() });
        this.store.dispatch(action);
        const state = this.store.getState();
        this.emitter.emit(`after:${action.type}`, { action, state });
        return;
      } else {
        this.batchQueue.push(action);
      }
    }
    on(event, handler) {
      this.emitter.on(event, handler);
      return () => {
        this.emitter.off(event, handler);
      };
    }
    serialize(entity, config) {
      return We(this.getState().iiif, entity, config);
    }
    toPresentation2(entity) {
      return this.serialize(entity, Ge);
    }
    toPresentation3(entity) {
      return this.serialize(entity, Qe2);
    }
    hydrate(reference, type, options = {}) {
      return this.get(reference, type, { ...options, skipSelfReturn: false });
    }
    get(reference, type, options = {}) {
      if (typeof type !== "string") {
        options = type || {};
        type = void 0;
      }
      const { skipSelfReturn = true } = options || {};
      let parent = options.parent ? typeof options.parent === "string" ? options.parent : options.parent.id : void 0;
      if (Array.isArray(reference)) {
        return reference.map((i3) => this.get(i3, options));
      }
      const state = this.getState();
      if (v2(reference) && !options.preserveSpecificResources) {
        reference = reference.source;
      }
      if (typeof reference === "string") {
        const _type2 = resolveType(type ? type : state.iiif.mapping[reference]);
        if (!_type2) {
          if (skipSelfReturn) {
            return null;
          }
          return { id: reference, type: "unknown" };
        }
        reference = { id: reference, type: _type2 };
      }
      if (reference && reference.partOf && !parent && !options.skipPartOfCheck) {
        const first = Array.isArray(reference.partOf) ? reference.partOf[0] : reference.partOf;
        if (first) {
          if (typeof first === "string") {
            parent = first;
          }
          if (typeof first.id === "string") {
            parent = first.id;
          }
        }
      }
      const _type = resolveType(type ? type : reference?.type);
      const _id = reference?.id;
      const entities = state.iiif.entities[_type];
      if (!entities) {
        const request = state.iiif.requests[_id];
        if (request && request.resourceUri !== _id) {
          return this.get(request.resourceUri, options);
        }
        if (skipSelfReturn) {
          return null;
        }
        return reference;
      }
      const found = entities[reference.id];
      if (found && found[d4]) {
        const framing = found[d4].find((t4) => {
          return parent ? t4[g3] === parent : t4[g3] === found.id;
        });
        return ae2(found, framing);
      }
      return entities[reference.id] || (skipSelfReturn ? null : reference);
    }
    select(selector) {
      return selector(this.getState());
    }
    getStore() {
      return this.store;
    }
    getState() {
      return this.store.getState();
    }
    deep(input, prev) {
      if (typeof input === "undefined") {
        return this.get(prev, { skipSelfReturn: false });
      }
      if (typeof input === "function") {
        try {
          const next = input(this.get(prev, { skipSelfReturn: false }));
          const fn2 = (newInput) => this.deep(newInput, next);
          fn2.size = Array.isArray(next) ? next.length : 1;
          return fn2;
        } catch (e3) {
          const fn2 = (newInput) => this.deep(newInput, void 0);
          fn2.size = 0;
          return fn2;
        }
      }
      const fn = (newInput) => this.deep(newInput, input);
      fn.size = Array.isArray(input) ? input.length : 1;
      return fn;
    }
    loadManifest(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json, mapper);
    }
    loadCollection(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json, mapper);
    }
    load(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      if (json) {
        return Promise.resolve(this.staticFetcher(_id, json, mapper));
      }
      return Promise.resolve(this.remoteFetcher(_id, {}, mapper));
    }
    loadSync(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      return this.staticFetcher(_id, json, mapper);
    }
    loadManifestSync(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      return this.loadSync(_id, json, mapper);
    }
    loadCollectionSync(id, json, mapper) {
      const _id = typeof id === "string" ? id : id.id;
      return this.loadSync(_id, json, mapper);
    }
    areInputsEqual(newInputs, lastInputs) {
      return areInputsEqual(newInputs, lastInputs);
    }
    subscribe(selector, subscription, skipInitial) {
      if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
        skipInitial = subscription;
        subscription = selector;
        selector = (a3) => a3;
      }
      return this.store.subscribe(selector, (s2) => subscription(s2, this), {
        equalityFn: areInputsEqual,
        fireImmediately: !skipInitial
      });
    }
    async ensureLoaded(_id) {
      const id = typeof _id === "string" ? _id : _id.id;
      if (!this.requestStatus(id)) {
        await this.load(id);
      }
    }
    requestStatus(id) {
      return this.select((state) => {
        return state.iiif.requests[id];
      });
    }
    // Pagination built on "meta".
    getPaginationState(resource) {
      const id = typeof resource === "string" ? resource : resource.id;
      if (!id)
        return null;
      const existing = this.getResourceMeta(id, "@vault/pagination");
      if (existing?.state) {
        return existing.state;
      }
      const fullResource = this.get(resource);
      if (fullResource.first) {
        const initialState = {
          currentPage: null,
          currentPageIndex: null,
          isFetching: false,
          isFullyLoaded: false,
          next: fullResource.first,
          page: 1,
          pages: [],
          previous: null,
          totalItems: fullResource.total,
          currentLength: 0
        };
        this.setMetaValue([id, "@vault/pagination", "state"], initialState);
        return initialState;
      }
      return null;
    }
    async loadNextPage(resource, json) {
      const id = typeof resource === "string" ? resource : resource.id;
      if (!id)
        return [null, null];
      const state = this.getPaginationState(resource);
      if (!state || state.isFullyLoaded || !state.next) {
        return [null, null];
      }
      if (state.isFetching) {
        return [state, null];
      }
      const nextPage = typeof state.next === "string" ? state.next : state.next.id;
      const previousPage = state.currentPage;
      const newState = {
        ...state,
        isFetching: true
      };
      this.setMetaValue([id, "@vault/pagination", "state"], newState);
      let collectionPage;
      try {
        collectionPage = await this.loadCollection(nextPage, json, (mapped) => {
          const { id: id2, ["@id"]: _id, ...properties } = mapped || {};
          if (_id) {
            return { ["@id"]: nextPage, ...properties };
          }
          return { id: nextPage, ...properties };
        });
      } catch (err) {
        const errState = {
          ...state,
          isFetching: false,
          error: err
        };
        this.setMetaValue([id, "@vault/pagination", "state"], errState);
        return [errState, null];
      }
      if (!collectionPage) {
        const errState = {
          ...state,
          isFetching: false,
          error: new Error("Collection not found")
        };
        this.setMetaValue([id, "@vault/pagination", "state"], errState);
        return [errState, null];
      }
      const fullCollection = this.get(id);
      const combinedItems = [
        ...fullCollection.items || [],
        ...collectionPage.items || []
      ].map((resource2) => ({
        id: resource2.id,
        type: resource2.type
      }));
      this.modifyEntityField({ id, type: "Collection" }, "items", combinedItems);
      const latestState = this.getPaginationState(resource);
      if (!latestState)
        throw new Error("Pagination state not found");
      const successState = {
        ...latestState,
        isFetching: false,
        error: null,
        currentPage: collectionPage.id,
        next: collectionPage.next?.id || null,
        currentPageIndex: latestState.pages.length,
        currentLength: combinedItems.length,
        pages: [
          ...latestState.pages,
          {
            id: collectionPage.id,
            type: "Collection",
            startIndex: fullCollection.items.length,
            pageLength: collectionPage.items.length,
            order: typeof latestState.currentPageIndex === "number" ? latestState.currentPageIndex + 1 : 0
          }
        ],
        isFullyLoaded: !collectionPage.next,
        previous: previousPage,
        page: latestState.pages.length + 1
      };
      this.setMetaValue([id, "@vault/pagination", "state"], successState);
      return [successState, collectionPage];
    }
    getResourceMeta(resource, metaKey) {
      const resourceMeta = this.getState().iiif.meta[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    }
    getObject(reference, type, options = {}) {
      const { reactive, ...otherOptions } = options;
      return wrapObject(this.get(reference, type, otherOptions), this, reactive);
    }
    async loadObject(id, json) {
      return wrapObject(await this.load(id, json), this);
    }
    async loadManifestObject(id, json) {
      return wrapObject(await this.loadManifest(id, json), this);
    }
    async loadCollectionObject(id, json) {
      return wrapObject(await this.loadCollection(id, json), this);
    }
    wrapObject(objectType) {
      return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);
    }
    isWrapped(object) {
      return isWrapped(object);
    }
    setMetaValue([id, meta, key], newValueOrUpdate) {
      this.dispatch(
        typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
          id,
          meta,
          key,
          updateValue: newValueOrUpdate
        }) : metaActions.setMetaValue({
          id,
          meta,
          key,
          value: newValueOrUpdate
        })
      );
    }
  };

  // src/vault/utility/get-global.ts
  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    return {};
  }

  // src/vault/global-vault.ts
  function globalVault(options) {
    const g4 = getGlobal();
    try {
      const gv = g4["IIIF_VAULT"];
      if (gv) {
        return gv;
      }
    } catch (e3) {
    }
    const newVault = new Vault(options);
    try {
      g4["IIIF_VAULT"] = newVault;
    } catch (e3) {
    }
    return newVault;
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/upgrader.js
  var t3 = be;

  // src/fetch.ts
  function fetchAndUpgrade(input, init) {
    return fetch(input, init).then((resp) => resp.json()).then(t3);
  }

  // src/search1.ts
  var getId = (idOrAtId) => idOrAtId.id || idOrAtId["@id"];
  function findSearch1Service(manifest) {
    if (!manifest || !manifest.service) {
      return null;
    }
    return manifest ? manifest.service.find(
      (service) => service.profile === "SearchService1" || service.profile === "http://iiif.io/api/search/1/search"
    ) : null;
  }
  function findAutocompleteService(service) {
    if (!service || !service.service)
      return;
    const services = Array.isArray(service.service) ? service.service : [service.service];
    return services.find(
      (s2) => s2.profile === "http://iiif.io/api/search/0/autocomplete" || s2.profile === "http://iiif.io/api/search/1/autocomplete" || s2.profile === "AutoCompleteService1"
    );
  }
  var createSearch1AutocompleteStore = (service, options) => {
    const fetcher = options?.fetcher || defaultFetcher;
    const autocomplete = service ? findAutocompleteService(service) : void 0;
    const autocompleteEndpoint = autocomplete ? getId(autocomplete) : void 0;
    let abort = null;
    return createStore((set, get) => ({
      results: [],
      lastQuery: {},
      hasAutocomplete: !!autocomplete,
      endpoint: autocompleteEndpoint,
      loading: false,
      error: false,
      errorMessage: "",
      ignored: [],
      setSearchService(newService) {
        const autocomplete2 = findAutocompleteService(newService);
        if (autocomplete2) {
          set({
            endpoint: getId(autocomplete2),
            hasAutocomplete: true,
            results: [],
            loading: false,
            lastQuery: null,
            error: false,
            errorMessage: ""
          });
        }
      },
      clearSearch() {
        set({ results: [], loading: false, lastQuery: null });
      },
      async search(query, options2 = {}) {
        const endpoint = get().endpoint;
        if (get().hasAutocomplete === false) {
          return;
        }
        if (abort && !abort.signal.aborted) {
          abort.abort();
        }
        abort = new AbortController();
        const params = new URLSearchParams();
        params.set("q", query);
        if (options2.motivation) {
          params.set("motivation", options2.motivation);
        }
        if (options2.date) {
          params.set("date", options2.date);
        }
        if (options2.user) {
          params.set("user", options2.user);
        }
        let shouldLoad = true;
        if ((!query || query.length < 3) && !options2.motivation && !options2.date && !options2.user) {
          shouldLoad = false;
        }
        set({
          loading: shouldLoad,
          lastQuery: {
            q: query,
            motivation: options2.motivation,
            date: options2.date,
            user: options2.user
          }
        });
        if (!shouldLoad) {
          return;
        }
        return fetcher(`${endpoint}?${params.toString()}`, {
          signal: abort.signal,
          headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            ...options2.headers || {}
          }
        }).then(async ([json, error]) => {
          if (abort?.signal.aborted) {
            return;
          }
          if (json) {
            set({
              loading: false,
              ignored: json.ignored || [],
              results: json.terms,
              error: false,
              errorMessage: ""
            });
          } else {
            set({ results: [], error: true, errorMessage: error || void 0 });
          }
        });
      }
    }));
  };
  function defaultFetcher(query, { signal, headers }) {
    return fetch(query, {
      signal,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        ...headers || {}
      }
    }).then(async (response) => {
      if (response.ok) {
        return [await response.json(), null];
      }
      return [null, response.statusText];
    });
  }
  var createSearch1Store = (service, options) => {
    const fetcher = options?.fetcher || defaultFetcher;
    let searchService;
    if (typeof service === "string") {
      searchService = {
        "@context": "http://iiif.io/api/search/1/context.json",
        profile: "http://iiif.io/api/search/1/search",
        "@id": service,
        id: service,
        service: []
      };
    } else {
      searchService = service;
    }
    let abort = null;
    return createStore((set, get) => ({
      endpoint: searchService ? getId(searchService) : void 0,
      service: searchService,
      resources: [],
      hits: [],
      lastQuery: {},
      loading: false,
      error: false,
      highlight: {
        results: null,
        hit: null
      },
      hitIndex: -1,
      hasSearch: !!searchService,
      hasAutocomplete: searchService ? !!findAutocompleteService(searchService) : false,
      errorMessage: "",
      async search(query, options2 = {}) {
        const endpoint = get().endpoint;
        if (!endpoint) {
          throw new Error("No search service found.");
        }
        if (abort && !abort.signal.aborted) {
          abort.abort();
        }
        abort = new AbortController();
        const params = new URLSearchParams();
        if (query.q) {
          params.set("q", query.q);
        }
        if (query.motivation) {
          params.set("motivation", query.motivation);
        }
        if (query.date) {
          params.set("date", query.date);
        }
        if (query.user) {
          params.set("user", query.user);
        }
        set({
          lastQuery: query,
          loading: true
        });
        const response = await fetcher(`${endpoint}?${params.toString()}`, {
          signal: abort.signal,
          headers: options2.headers
        }).then(([json, errorMessage]) => {
          if (abort?.signal.aborted) {
            return;
          }
          if (json) {
            set({
              resources: (json.resources || []).map((result) => {
                if (result.search && !result.url) {
                  result.url = result.search;
                }
                return result;
              }),
              hits: json.hits || (json.resources || []).map((result) => {
                return {
                  "@type": "search:Hit",
                  after: "",
                  annotations: [result["@id"]],
                  before: "",
                  match: result.resource.chars
                };
              }),
              error: false,
              errorMessage: "",
              loading: false
            });
          } else {
            set({
              loading: false,
              resources: [],
              error: true,
              errorMessage: errorMessage || void 0
            });
          }
        });
        return response;
      },
      setSearchService(newService) {
        set({
          service: newService,
          endpoint: newService ? getId(newService) : void 0,
          hasSearch: !!newService,
          hasAutocomplete: newService ? !!findAutocompleteService(newService) : false,
          loading: false,
          resources: [],
          error: false,
          errorMessage: "",
          highlight: { results: null, hit: null }
        });
      },
      // Other actions?
      clearSearch() {
        set({ resources: [], error: false, errorMessage: "" });
      },
      highlightHit(index) {
        const state = get();
        const hit = state.hits[index];
        if (!hit) {
          return;
        }
        const results = state.resources.filter((r3) => hit.annotations.includes(r3["@id"]));
        set({ hitIndex: index, highlight: { results, hit } });
      },
      nextHit() {
        const state = get();
        const nextIndex = state.hitIndex + 1;
        if (nextIndex >= state.hits.length) {
          return;
        }
        state.highlightHit(nextIndex);
      },
      previousHit() {
        const state = get();
        const nextIndex = state.hitIndex - 1;
        if (nextIndex < 0) {
          return;
        }
        state.highlightHit(nextIndex);
      }
    }));
  };

  // src/nav-date.ts
  function createDateNavigation(vault, manifestOrCollection, inputType) {
    const type = inputType || "century";
    const items = [];
    const centuries = [];
    const resource = vault.get(manifestOrCollection);
    if (!resource.items) {
      return items;
    }
    for (const item of resource.items) {
      if (item.navDate) {
        const d5 = new Date(item.navDate);
        const year = d5.getFullYear();
        const month = d5.getMonth();
        const day = d5.getDate();
        const decade = Math.floor(year / 10) * 10;
        const century = Math.floor(year / 100) * 100;
        let centuryItem = centuries.find((i3) => i3.yearStart === century);
        if (!centuryItem) {
          centuryItem = {
            id: `${resource.id}/century/${century}`,
            label: { en: [`${century} - ${century + 99}`] },
            type: "century",
            yearStart: century,
            yearEnd: century + 99,
            count: 1,
            items: []
          };
          if (type === "century") {
            items.push(centuryItem);
          }
          centuries.push(centuryItem);
        } else {
          centuryItem.count++;
        }
        let decadeItem = centuryItem.items.find((i3) => i3.yearStart === decade);
        if (!decadeItem) {
          decadeItem = {
            id: `${resource.id}/decade/${decade}`,
            label: { en: [`${decade} - ${decade + 9}`] },
            type: "decade",
            yearStart: decade,
            yearEnd: decade + 9,
            count: 1,
            items: []
          };
          centuryItem.items.push(decadeItem);
          if (type === "decade") {
            items.push(decadeItem);
          }
        } else {
          decadeItem.count++;
        }
        let yearItem = decadeItem.items.find((i3) => i3.year === year);
        if (!yearItem) {
          yearItem = {
            id: `${resource.id}/year/${year}`,
            label: { en: [`${year}`] },
            type: "year",
            year,
            count: 1,
            items: []
          };
          decadeItem.items.push(yearItem);
          if (type === "year") {
            items.push(yearItem);
          }
        } else {
          yearItem.count++;
        }
        let monthItem = yearItem.items.find((i3) => i3.month === month);
        if (!monthItem) {
          monthItem = {
            id: `${resource.id}/month/${year}/${month + 1}`,
            // Month as string
            label: {
              en: [
                type === "month" ? `${d5.toLocaleString("default", { month: "long" })} ${year}` : `${d5.toLocaleString("default", { month: "long" })}`
              ]
            },
            type: "month",
            month,
            count: 1,
            items: []
          };
          yearItem.items.push(monthItem);
          if (type === "month") {
            items.push(monthItem);
          }
        } else {
          monthItem.count++;
        }
        let dayItem = monthItem.items.find((i3) => i3.day === day);
        if (!dayItem) {
          dayItem = {
            id: `${resource.id}/day/${year}/${month + 1}/${day}`,
            label: { en: [`${d5.toDateString()}`] },
            type: "day",
            day,
            count: 1,
            items: []
          };
          monthItem.items.push(dayItem);
          if (type === "day") {
            items.push(dayItem);
          }
        } else {
          dayItem.count++;
        }
        dayItem.items.push({
          id: item.id,
          type: item.type,
          label: item.label || { en: [`${year}-${month + 1}-${day}`] },
          navDate: item.navDate
        });
      }
    }
    if (!inputType) {
      let autoItem = items;
      while (autoItem.length === 1) {
        autoItem = autoItem[0].items;
      }
      return autoItem;
    }
    return items;
  }
  return __toCommonJS(src_exports);
})();
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
