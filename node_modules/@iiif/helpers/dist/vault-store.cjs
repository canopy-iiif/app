"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/vault-store.ts
var vault_store_exports = {};
__export(vault_store_exports, {
  createStore: () => createStore2,
  reducers: () => reducers
});
module.exports = __toCommonJS(vault_store_exports);

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs
var import_meta2 = {};
var reduxImpl = (reducer, initial) => (set, _get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action), false, action);
    return action;
  };
  api.dispatchFromDevtools = true;
  return { dispatch: (...a) => api.dispatch(...a), ...initial };
};
var redux = reduxImpl;
var trackedConnections = /* @__PURE__ */ new Map();
var getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api)
    return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
var extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
var devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording)
      return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState)
              return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
var devtools = devtoolsImpl;
var parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0)
    f(parsed);
};
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;

// src/vault/utility/typesafe-actions-runtime.ts
var createAction = function createAction2(type) {
  return function() {
    const base = { type, getType: () => type, toString: () => type };
    return (payload2, meta) => ({
      ...base,
      ...payload2 !== void 0 && { payload: payload2 },
      ...meta !== void 0 && { meta }
    });
  };
};

// src/vault/actions/entity-actions.ts
var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
var UPDATE_REFERENCE = "@iiif/UPDATE_REFERENCE";
var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
var ADD_METADATA = "@iiif/ADD_METADATA";
var REMOVE_METADATA = "@iiif/REMOVE_METADATA";
var UPDATE_METADATA = "@iiif/UPDATE_METADATA";
var REORDER_METADATA = "@iiif/REORDER_METADATA";
var importEntities = createAction(IMPORT_ENTITIES)();
var modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
var reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
var addReference = createAction(ADD_REFERENCE)();
var removeReference = createAction(REMOVE_REFERENCE)();
var updateReference = createAction(UPDATE_REFERENCE)();
var addMetadata = createAction(ADD_METADATA)();
var updateMetadata = createAction(UPDATE_METADATA)();
var removeMetadata = createAction(REMOVE_METADATA)();
var reorderMetadata = createAction(REORDER_METADATA)();

// src/vault/actions/mapping-actions.ts
var ADD_MAPPING = "@iiif/ADD_MAPPING";
var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
var addMapping = createAction(ADD_MAPPING)();
var addMappings = createAction(ADD_MAPPINGS)();

// src/vault/actions/meta-actions.ts
var SET_META_VALUE = "@iiif/SET_META_VALUE";
var SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
var UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
var setMetaValue = createAction(SET_META_VALUE)();
var setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)();
var unsetMetaValue = createAction(UNSET_META_VALUE)();

// src/vault/actions/request-actions.ts
var RESOURCE_ERROR = "RESOURCE_ERROR";
var RESOURCE_LOADING = "RESOURCE_LOADING";
var RESOURCE_READY = "RESOURCE_READY";
var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
var requestResource = createAction(REQUEST_RESOURCE)();
var requestError = createAction(REQUEST_ERROR)();
var requestMismatch = createAction(REQUEST_MISMATCH)();
var requestComplete = createAction(REQUEST_COMPLETE)();
var requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)();

// src/vault/actions/batch-actions.ts
var BATCH_ACTIONS = "@iiif/BATCH";
var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
var batchActions = createAction(BATCH_ACTIONS)();
var batchImport = createAction(BATCH_IMPORT)();

// src/vault/store/reducers/mapping-reducer.ts
var mappingReducer = (state = {}, action) => {
  switch (action.type) {
    case ADD_MAPPING:
      return {
        ...state,
        [action.payload.id]: action.payload.type
      };
    case ADD_MAPPINGS:
      return {
        ...state,
        ...action.payload.mapping
      };
    default:
      return state;
  }
};

// src/vault/utility/get-default-entities.ts
function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

// src/vault/utility/is-reference-list.ts
function isReferenceList(state, id, type, key) {
  return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
}

// src/vault/utility/quick-merge.ts
function quickMerge(a, b) {
  const newResource = {};
  const added = [];
  for (const [key, value] of Object.entries(a || {})) {
    added.push(key);
    const bValue = (b || {})[key];
    if (!bValue || bValue.length === 0) {
      newResource[key] = value;
      continue;
    }
    newResource[key] = bValue;
  }
  for (const [key, value] of Object.entries(b || {})) {
    if (added.indexOf(key) !== -1) {
      continue;
    }
    newResource[key] = value;
  }
  return newResource;
}

// src/vault/store/reducers/entities-reducer.ts
function payload(action) {
  return action.payload;
}
function numberOr(a, b) {
  return typeof a === "undefined" ? b : a;
}
var entitiesReducer = (state = getDefaultEntities(), action) => {
  const updateField = (entity, values) => {
    return {
      ...state,
      [payload(action).type]: {
        ...state[payload(action).type],
        [payload(action).id]: {
          ...entity,
          ...values
        }
      }
    };
  };
  switch (action.type) {
    case MODIFY_ENTITY_FIELD: {
      if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      return updateField(entity, { [payload(action).key]: payload(action).value });
    }
    case REORDER_ENTITY_FIELD: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      const result = Array.from(entity[payload(action).key]);
      const [removed] = result.splice(payload(action).startIndex, 1);
      result.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { [payload(action).key]: result });
    }
    case IMPORT_ENTITIES: {
      const keys = Object.keys(payload(action).entities);
      const toReturn = { ...state };
      for (const key of keys) {
        const entities = payload(action).entities[key];
        const newEntities = { ...state[key] || {} };
        let changed = false;
        const ids = Object.keys(entities || {}) || [];
        if (entities && ids) {
          for (const id of ids) {
            changed = true;
            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
          }
          if (changed) {
            toReturn[key] = newEntities;
          }
        }
      }
      return toReturn;
    }
    case ADD_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);
      return updateField(entity, { [payload(action).key]: result });
    }
    case UPDATE_REFERENCE:
    case REMOVE_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      const indexToRemove = numberOr(
        payload(action).index,
        result.findIndex((e) => e && e.id === payload(action).reference.id)
      );
      if (indexToRemove === -1 || result[indexToRemove]?.id !== payload(action).reference.id) {
        return state;
      }
      if (action.type === UPDATE_REFERENCE) {
        result.splice(indexToRemove, 1, payload(action).reference);
      } else {
        result.splice(indexToRemove, 1);
      }
      return updateField(entity, { [payload(action).key]: result });
    }
    case ADD_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (!entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const actionPayload = payload(action);
      metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {
        label: actionPayload.label,
        value: actionPayload.label
      });
      return updateField(entity, { metadata });
    }
    case REORDER_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string" || !entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const [removed] = metadata.splice(payload(action).startIndex, 1);
      metadata.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { metadata });
    }
    case UPDATE_METADATA:
    case REMOVE_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      const metadata = Array.from(entity.metadata || []);
      const indexToRemove = payload(action).atIndex;
      if (typeof indexToRemove === "undefined" || indexToRemove === -1 || !metadata[indexToRemove]) {
        return state;
      }
      if (action.type === UPDATE_METADATA) {
        metadata.splice(indexToRemove, 1, { label: payload(action).label, value: payload(action).value });
      } else {
        metadata.splice(indexToRemove, 1);
      }
      return updateField(entity, { metadata });
    }
    default:
      return state;
  }
};

// src/vault/store/reducers/request-reducer.ts
var requestReducer = (state = {}, action) => {
  switch (action.type) {
    case REQUEST_RESOURCE:
    case REQUEST_OFFLINE_RESOURCE:
      return {
        ...state,
        [action.payload.id]: {
          requestUri: action.payload.id,
          loadingState: RESOURCE_LOADING,
          uriMismatch: false,
          resourceUri: action.payload.id
        }
      };
    case REQUEST_MISMATCH:
      return {
        ...state,
        [action.payload.requestId]: {
          ...state[action.payload.requestId] || {},
          uriMismatch: true,
          resourceUri: action.payload.actualId
        },
        [action.payload.actualId]: {
          requestUri: action.payload.requestId,
          loadingState: state[action.payload.requestId].loadingState,
          uriMismatch: true,
          resourceUri: action.payload.actualId
        }
      };
    case REQUEST_ERROR:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_ERROR,
          error: action.payload.message
        }
      };
    case REQUEST_COMPLETE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_READY,
          error: void 0
        }
      };
  }
  return state;
};

// src/vault/store/reducers/meta-reducer.ts
var metaReducer = (state = {}, action) => {
  const { id, updateValue, value, meta, key } = action && action.payload || {};
  switch (action.type) {
    case SET_META_VALUE: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: value
          }
        }
      };
    }
    case SET_META_VALUE_DYNAMIC: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
          }
        }
      };
    }
    case UNSET_META_VALUE: {
      if (state[id] && state[id][meta] && state[id][meta][key]) {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: void 0
            }
          }
        };
      }
      return state;
    }
    default:
      return state;
  }
};

// src/vault/utility/combine-reducers.ts
function combineReducers(reducers2 = {}) {
  const reducerKeys = Object.keys(reducers2);
  return function combination(state = {}, action) {
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      nextState[key] = reducers2[key](state[key], action);
      hasChanged = hasChanged || nextState[key] !== state[key];
    }
    return hasChanged ? nextState : state;
  };
}

// src/vault/store/reducers/batch-reducer.ts
function createBatchReducer(rootReducer) {
  return (state, action) => {
    if (action && action.type === BATCH_ACTIONS) {
      return action.payload.actions.reduce(rootReducer, state);
    }
    if (action && action.type === BATCH_IMPORT) {
      return {
        ...state,
        iiif: {
          ...state.iiif,
          ...action.payload.state
        }
      };
    }
    return rootReducer(state, action);
  };
}

// src/vault/store/index.ts
var reducers = combineReducers({
  mapping: mappingReducer,
  entities: entitiesReducer,
  requests: requestReducer,
  meta: metaReducer
});
function getDefaultState() {
  return {
    iiif: {
      entities: getDefaultEntities(),
      meta: {},
      mapping: {},
      requests: {}
    }
  };
}
function createStore2(options = {}) {
  const {
    enableDevtools = false,
    iiifStoreName = "iiif",
    defaultState = getDefaultState(),
    customReducers = {}
  } = options;
  const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));
  const enabled = Boolean(typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__);
  const dv = !enabled || false ? (a, r) => a : devtools;
  return createStore(
    //
    subscribeWithSelector(
      //
      dv(
        //
        redux(rootReducer, defaultState),
        { enabled: enableDevtools }
      )
    )
  );
}
