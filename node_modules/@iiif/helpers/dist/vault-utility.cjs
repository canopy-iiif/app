"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/vault-utility.ts
var vault_utility_exports = {};
__export(vault_utility_exports, {
  actionListFromResource: () => actionListFromResource,
  areInputsEqual: () => areInputsEqual,
  createFetchHelper: () => createFetchHelper,
  getDefaultEntities: () => getDefaultEntities,
  resolveIfExists: () => resolveIfExists,
  resolveList: () => resolveList
});
module.exports = __toCommonJS(vault_utility_exports);

// src/vault/utility/action-list-from-resource.ts
var import_parser = require("@iiif/parser");

// src/vault/utility/typesafe-actions-runtime.ts
var createAction = function createAction2(type) {
  return function() {
    const base = { type, getType: () => type, toString: () => type };
    return (payload, meta) => ({
      ...base,
      ...payload !== void 0 && { payload },
      ...meta !== void 0 && { meta }
    });
  };
};

// src/vault/actions/entity-actions.ts
var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
var UPDATE_REFERENCE = "@iiif/UPDATE_REFERENCE";
var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
var ADD_METADATA = "@iiif/ADD_METADATA";
var REMOVE_METADATA = "@iiif/REMOVE_METADATA";
var UPDATE_METADATA = "@iiif/UPDATE_METADATA";
var REORDER_METADATA = "@iiif/REORDER_METADATA";
var importEntities = createAction(IMPORT_ENTITIES)();
var modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
var reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
var addReference = createAction(ADD_REFERENCE)();
var removeReference = createAction(REMOVE_REFERENCE)();
var updateReference = createAction(UPDATE_REFERENCE)();
var addMetadata = createAction(ADD_METADATA)();
var updateMetadata = createAction(UPDATE_METADATA)();
var removeMetadata = createAction(REMOVE_METADATA)();
var reorderMetadata = createAction(REORDER_METADATA)();

// src/vault/actions/mapping-actions.ts
var ADD_MAPPING = "@iiif/ADD_MAPPING";
var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
var addMapping = createAction(ADD_MAPPING)();
var addMappings = createAction(ADD_MAPPINGS)();

// src/vault/actions/request-actions.ts
var RESOURCE_ERROR = "RESOURCE_ERROR";
var RESOURCE_LOADING = "RESOURCE_LOADING";
var RESOURCE_READY = "RESOURCE_READY";
var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
var requestResource = createAction(REQUEST_RESOURCE)();
var requestError = createAction(REQUEST_ERROR)();
var requestMismatch = createAction(REQUEST_MISMATCH)();
var requestComplete = createAction(REQUEST_COMPLETE)();
var requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)();

// src/vault/actions/batch-actions.ts
var BATCH_ACTIONS = "@iiif/BATCH";
var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
var batchActions = createAction(BATCH_ACTIONS)();
var batchImport = createAction(BATCH_IMPORT)();

// src/vault/utility/action-list-from-resource.ts
var actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = (0, import_parser.normalize)(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

// src/vault/utility/are-inputs-equal.ts
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

// src/vault/utility/resolve-if-exists.ts
var import_parser2 = require("@iiif/parser");
function resolveIfExists(state, url, parent) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  const fullEntity = state.iiif.entities[resourceType][request.resourceUri];
  if (fullEntity && fullEntity[import_parser2.HAS_PART]) {
    const framing = fullEntity[import_parser2.HAS_PART].find((t) => {
      return parent ? t[import_parser2.PART_OF] === parent.id : t[import_parser2.PART_OF] === fullEntity.id;
    });
    return (0, import_parser2.frameResource)(fullEntity, framing);
  }
  return fullEntity;
}

// src/vault/utility/is-promise.ts
function isPromise(value) {
  return value && typeof value.then === "function";
}

// src/vault/utility/create-fetch-helper.ts
function createFetchHelper(vault, fetcher, { waitTimeout = 30 } = {}) {
  return (url, options, mapper) => {
    const store = vault.getStore();
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      if (request.loadingState === RESOURCE_READY) {
        const resolvedEntity = resolveIfExists(state, url);
        if (resolvedEntity) {
          return resolvedEntity;
        }
      }
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          return (async () => {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise(
                  (resolve, reject) => setTimeout(
                    () => {
                      didContinue = true;
                      reject();
                    },
                    waitTimeout * 60 * 1e3
                  )
                )
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
            }
          })();
        }
      }
    }
    vault.dispatch(requestResource({ id: url }));
    const importResource = (resource) => {
      if (!resource) {
        return void 0;
      }
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      vault.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    };
    try {
      const resourceOrPromise = fetcher(url, options);
      if (isPromise(resourceOrPromise)) {
        return (async () => {
          try {
            let data = await resourceOrPromise;
            if (mapper) {
              data = mapper(data);
            }
            return importResource(data);
          } catch (err) {
            vault.dispatch(requestError({ id: url, message: err.toString() }));
            throw err;
          }
        })();
      }
      return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);
    } catch (err) {
      vault.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

// src/vault/utility/get-default-entities.ts
function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

// src/vault/utility/resolve-list.ts
function resolveList(state, items) {
  const returnItems = [];
  for (const ref of items) {
    if (state.iiif.entities[ref.type] && state.iiif.entities[ref.type][ref.id]) {
      returnItems.push(state.iiif.entities[ref.type][ref.id]);
    }
  }
  return returnItems;
}
