import { f as ImageCandidateRequest, e as ImageCandidate, F as FixedSizeImage, c as ImageServiceLoader, d as FixedSizeImageService } from './image-service-loader-D7YX4Vxb.js';
export { I as ImageServer, b as ImageServiceLoaderConfig, a as ImageServiceRequest, U as UnknownSizeImage, V as VariableSizeImage } from './image-service-loader-D7YX4Vxb.js';
import { ImageTile, ImageService, ContentResource, Service, ImageSize } from '@iiif/presentation-3';
import * as zustand_vanilla from 'zustand/vanilla';
import { Emitter } from 'mitt';

/**
 * Get image server from ID.
 *
 * Normalises image service URLs to extract identity of the image server.
 *
 * @param url
 */
declare function getImageServerFromId(url: string): string;

declare function sampledTilesToTiles(width: number, height: number, sampledTiles: ImageTile[]): ImageTile[];

/**
 * Pick best from candidates
 *
 * Takes in a list of candidate lists. The order should be in preference. This algorithm will try to pick
 * from the first list, with a best fit size. If not it will fallback to the other lists. It may come back
 * around to the first list and provide a fallback.
 *
 * @param inputRequest
 * @param candidates
 */
declare function pickBestFromCandidates(inputRequest: ImageCandidateRequest, candidates: Array<() => ImageCandidate[]>): {
    best: ImageCandidate | null;
    fallback: ImageCandidate[];
    log: string[];
};

declare function isBestMatch(request: Required<ImageCandidateRequest>, current: FixedSizeImage | null, candidate: FixedSizeImage): boolean;

type LoadImageServiceDetail = {
    width: number;
    height: number;
    force?: boolean;
};
interface ImageServiceStore {
    loaded: Record<string, {
        status: 'loading' | 'done' | 'error';
        service: ImageService | null;
        error?: boolean;
        errorMesage?: string;
        real?: boolean;
    }>;
    loadServiceSync: (service: ImageService, detail?: LoadImageServiceDetail, backgroundRequest?: boolean) => ImageService | null;
    loadService: (service: ImageService, detail?: LoadImageServiceDetail) => Promise<ImageService | null>;
}
interface ImageServiceStoreOptions {
    loader?: ImageServiceLoader;
    events?: Emitter<ImageServiceStoreEvents>;
}
type ImageServiceStoreEvents = {
    'image-service.loaded': {
        id: string;
        service: ImageService | null;
    };
    'image-service.loading': {
        id: string;
    };
    'image-service.error': {
        id: string;
        error: Error;
    };
};
declare function createImageServiceStore(options?: ImageServiceStoreOptions): {
    store: zustand_vanilla.StoreApi<ImageServiceStore>;
    events: Emitter<ImageServiceStoreEvents>;
};
declare const imageServices: {
    store: zustand_vanilla.StoreApi<ImageServiceStore>;
    events: Emitter<ImageServiceStoreEvents>;
};

declare function getImageFromTileSource(image: FixedSizeImageService, targetWidth: number, targetHeight?: number): FixedSizeImage;

/**
 * Get image candidates
 *
 * Given an unknown resource, and optionally an image service loader, it will
 * try to get all of the possible options for images at a specific size.
 *
 * Note: if you are wanting to depend on external web resources, then you have
 * to either preload these, or prepare the image loader for predicting them.
 *
 * @param unknownResource
 * @param dereference
 * @param loader
 */
declare function getImageCandidates(unknownResource: ContentResource, dereference: boolean | undefined, loader: ImageServiceLoader): ImageCandidate[];

declare function getImageCandidatesFromService(service: ImageService[]): ImageCandidate[];

/**
 * Get fixed sizes from service.
 *
 * Given an image service, this will extract the images from the sizes field of
 * the service. These are usually cached and great options for thumbnails.
 *
 * @param service
 */
declare function getFixedSizesFromService(service: Service): FixedSizeImageService[];

declare function isImage3(service: any): boolean;

/**
 * Get custom size from service
 *
 * Given an image service – usually a full one, de-referenced or embedded – this
 * will return a list of available image sizes (min and max width and height) that
 * can be used to construct a IIIF query to get an image at any size within those
 * bounds. This is only supported by some image services. If unsupported, this will
 * return an empty list.
 *
 * @param service
 */
declare function getCustomSizeFromService(service: ImageService): ImageCandidate[];

/**
 * Get fixed size from image
 *
 * Given a content resource, usually the body of a painting annotation, this will
 * return the URL to the image, and the height and width. The resource may also
 * be a string / direct link to the image. The height and width may be inferred from
 * a IIIF Image API endpoint, otherwise the return image candidate will have a type
 * of unknown.
 *
 * @param contentResource
 */
declare function getFixedSizeFromImage(contentResource: ContentResource | string): ImageCandidate | null;

/**
 * Extracts the height and width from an image URL
 *
 * @param image
 */
declare function inferImageSizeFromUrl(image: string): ImageCandidate;

declare function imageSizesMatch(sizesA: ImageSize[], sizesB: ImageSize[]): boolean;

/**
 * Returns a fixed size image using the tile using the largest available size,
 * or the smallest scale factor.
 *
 * @param service
 */
declare function getSmallestScaleFactorAsSingleImage(service: ImageService): FixedSizeImageService | null;

export { FixedSizeImage, FixedSizeImageService, ImageCandidate, ImageCandidateRequest, ImageServiceLoader, type ImageServiceStore, type ImageServiceStoreEvents, type ImageServiceStoreOptions, type LoadImageServiceDetail, createImageServiceStore, getCustomSizeFromService, getFixedSizeFromImage, getFixedSizesFromService, getImageCandidates, getImageCandidatesFromService, getImageFromTileSource, getImageServerFromId, getSmallestScaleFactorAsSingleImage, imageServices, imageSizesMatch, inferImageSizeFromUrl, isBestMatch, isImage3, pickBestFromCandidates, sampledTilesToTiles };
