import "./chunk-IL6ECOVI.js";
import {
  expandTarget
} from "./chunk-MGQKBQDS.js";
import "./chunk-G7A32JAG.js";

// src/transcriptions.ts
function canvasHasTranscriptionSync(vault, canvasRef, annotationPages) {
  if (typeof canvasRef === "string")
    canvasRef = { id: canvasRef, type: "Canvas" };
  const canvas = vault.get(canvasRef);
  if (canvas.rendering) {
    for (const renderingRef of canvas.rendering) {
      const rendering = vault.get(renderingRef);
      if ("format" in rendering) {
        if (rendering.format === "text/plain")
          return true;
        if (rendering.format === "application/xml" && rendering?.profile === "http://www.loc.gov/standards/alto/")
          return true;
      }
    }
  }
  if (canvas.annotations) {
    for (const annotationPageRef of canvas.annotations) {
      const annotationPage = vault.get(annotationPageRef);
      for (const annotationRef of annotationPage.items || []) {
        const annotation = vault.get(annotationRef);
        if (annotation.motivation?.includes("supplementing")) {
          if (annotation.body) {
            const bodies = vault.get(annotation.body);
            const allBodies = Array.isArray(bodies) ? bodies : [bodies];
            for (const body of allBodies) {
              if (body.format === "text/vtt")
                return true;
              if (body.format === "text/plain")
                return true;
              if (body.type === "TextualBody")
                return true;
            }
          }
        }
      }
    }
  }
  if (annotationPages) {
    for (const annotationPage of annotationPages) {
      for (const annotationRef of annotationPage.items || []) {
        const annotation = vault.get(annotationRef);
        if (annotation.motivation?.includes("supplementing")) {
          if (annotation.body) {
            const bodies = vault.get(annotation.body);
            const allBodies = Array.isArray(bodies) ? bodies : [bodies];
            for (const body of allBodies) {
              if (body.format === "text/vtt")
                return true;
              if (body.format === "text/plain")
                return true;
              if (body.type === "TextualBody")
                return true;
            }
          }
        }
      }
    }
  }
  return false;
}
async function canvasLoadExternalAnnotationPages(vault, canvasRef) {
  if (typeof canvasRef === "string")
    canvasRef = { id: canvasRef, type: "Canvas" };
  const canvas = vault.get(canvasRef);
  const annotationPages = [];
  if (canvas.annotations) {
    for (const annotationPageRef of canvas.annotations) {
      const annotationPage = vault.get(annotationPageRef);
      const requestStatus = vault.requestStatus(annotationPage.id);
      if (!requestStatus && (!annotationPage.items || annotationPage["iiif-parser:isExternal"])) {
        try {
          annotationPages.push(await vault.load(annotationPage.id));
        } catch (e) {
        }
      } else {
        annotationPages.push(annotationPage);
      }
    }
  }
  return annotationPages;
}
var vttRegex = /^(\d{2}:\d{2}:\d{2}[.,]\d{3})\s-->\s(\d{2}:\d{2}:\d{2}[.,]\d{3})(.*)\r?\n(.*(?:\r?\n(?!\r?\n).*)*)/gm;
function timeStampToSeconds(time) {
  const [hours, minutes, seconds] = time.split(":").map((t) => parseFloat(t || "0"));
  return hours * 3600 + minutes * 60 + seconds;
}
async function vttToTranscription(vtt, id) {
  const segments = [];
  let match;
  while (match = vttRegex.exec(vtt)) {
    const start = match[1];
    const end = match[2];
    const text = match[4].trim();
    const selector = {
      type: "TemporalSelector",
      temporal: {
        startTime: timeStampToSeconds(start),
        endTime: timeStampToSeconds(end)
      }
    };
    segments.push({
      startRaw: start,
      endRaw: end,
      text: text.replace(/(<([^>]+)>)/gi, ""),
      textRaw: text,
      selector: {
        selector,
        selectors: [selector]
      }
    });
  }
  if (!segments.length)
    return null;
  return {
    id,
    source: { id, type: "Text", format: "text/vtt" },
    plaintext: segments.map((s) => s.text).join("\n"),
    segments
  };
}
async function altoToTranscription(alto) {
  return null;
}
async function annotationPageToTranscription(vault, annotationPage) {
  const transcription = {
    id: annotationPage.id,
    source: { id: annotationPage.id, type: "AnnotationPage" },
    plaintext: "",
    segments: []
  };
  if (!annotationPage.items)
    return null;
  for (const annotationRef of annotationPage.items) {
    const annotation = vault.get(annotationRef);
    if (annotation.motivation?.includes("supplementing")) {
      if (annotation.body) {
        const bodies = vault.get(annotation.body);
        const body = Array.isArray(bodies) ? bodies[0] : bodies;
        if (body.format === "text/plain" || body.type === "TextualBody") {
          if (body.value && typeof body.value === "string") {
            let segmentText = body.value;
            let granularity = annotation.textGranularity;
            if (!granularity) {
              granularity = segmentText.includes(" ") ? "line" : "word";
            }
            if (granularity === "line" || granularity === "paragraph" || granularity === "block" || granularity === "page") {
              segmentText += "\n";
            } else {
              segmentText += " ";
            }
            const segment = {
              text: segmentText,
              textRaw: body.value,
              granularity
            };
            transcription.plaintext += segmentText;
            if (annotation.target) {
              try {
                segment.selector = expandTarget(annotation.target);
              } catch (e) {
              }
            } else {
            }
            transcription.segments.push(segment);
          }
        }
      }
    }
  }
  transcription.plaintext = transcription.plaintext.trim();
  if (transcription.plaintext === "" && transcription.segments.length === 0)
    return null;
  return transcription;
}
async function getCanvasTranscription(vault, canvasRef, networkCache = {}) {
  const canvas = vault.get(canvasRef);
  const annotationPages = await canvasLoadExternalAnnotationPages(vault, canvas);
  if (!canvasHasTranscriptionSync(vault, canvasRef, annotationPages))
    return null;
  const transcription = {
    id: canvas.id,
    source: canvas,
    plaintext: "",
    segments: []
  };
  if (canvas.duration) {
    for (const annotationPage of annotationPages) {
      for (const annotationRef of annotationPage.items || []) {
        const annotation = vault.get(annotationRef);
        if (annotation.motivation?.includes("supplementing")) {
          if (annotation.body) {
            const bodyRaw = vault.get(annotation.body);
            const bodies = Array.isArray(bodyRaw) ? bodyRaw : [bodyRaw];
            for (const body of bodies) {
              if (body.format === "text/vtt") {
                if (body.id) {
                  const vtt = networkCache[body.id] || await fetch(body.id, { method: "GET" }).then((r) => r.text());
                  const transcription2 = await vttToTranscription(vtt, body.id);
                  if (transcription2) {
                    return transcription2;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  pageLabel:
    for (const annotationPage of annotationPages) {
      for (const annotationRef of annotationPage.items || []) {
        const annotation = vault.get(annotationRef);
        if (annotation.motivation?.includes("supplementing")) {
          if (annotation.body) {
            const bodyRaw = vault.get(annotation.body);
            const bodies = Array.isArray(bodyRaw) ? bodyRaw : [bodyRaw];
            for (const body of bodies) {
              if (body.format === "text/plain" || body.type === "TextualBody") {
                const plaintext = await annotationPageToTranscription(vault, annotationPage);
                if (plaintext) {
                  return plaintext;
                }
                continue pageLabel;
              }
            }
          }
        }
      }
    }
  if (canvas.rendering) {
    for (const renderingRef of canvas.rendering) {
      const rendering = vault.get(renderingRef);
      if (rendering.format === "text/plain") {
        const plaintext = networkCache[rendering.id] || await fetch(rendering.id, { method: "GET" }).then((r) => r.text());
        return { ...transcription, plaintext };
      }
    }
  }
  if (canvas.rendering) {
    for (const renderingRef of canvas.rendering) {
      const rendering = vault.get(renderingRef);
      if (rendering.format === "application/xml" && rendering.profile === "http://www.loc.gov/standards/alto/") {
        const transcription2 = await altoToTranscription(rendering.id);
        if (transcription2) {
          return transcription2;
        }
        return null;
      }
    }
  }
  return null;
}
async function manifestHasTranscriptions(vault, manifest, pagesToCheck = 5) {
  const canvases = vault.get(manifest)?.items || [];
  let hasTranscription = false;
  for (const canvas of canvases) {
    const fullCanvas = vault.get(canvas);
    const canvasHasTranscription = canvasHasTranscriptionSync(vault, fullCanvas);
    if (canvasHasTranscription) {
      hasTranscription = true;
      break;
    }
    if (pagesToCheck > 0) {
      pagesToCheck--;
      const annotationPages = await canvasLoadExternalAnnotationPages(vault, fullCanvas);
      const canvasHasTranscription2 = canvasHasTranscriptionSync(vault, fullCanvas, annotationPages);
      if (canvasHasTranscription2) {
        hasTranscription = true;
        break;
      }
    }
  }
  return hasTranscription;
}
export {
  annotationPageToTranscription,
  canvasHasTranscriptionSync,
  canvasLoadExternalAnnotationPages,
  getCanvasTranscription,
  manifestHasTranscriptions,
  timeStampToSeconds,
  vttToTranscription
};
