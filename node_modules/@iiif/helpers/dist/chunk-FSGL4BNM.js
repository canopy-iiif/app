import {
  createStore
} from "./chunk-2I7FN7JX.js";

// src/search1.ts
var getId = (idOrAtId) => idOrAtId.id || idOrAtId["@id"];
function findSearch1Service(manifest) {
  if (!manifest || !manifest.service) {
    return null;
  }
  return manifest ? manifest.service.find(
    (service) => service.profile === "SearchService1" || service.profile === "http://iiif.io/api/search/1/search"
  ) : null;
}
function findAutocompleteService(service) {
  if (!service || !service.service)
    return;
  const services = Array.isArray(service.service) ? service.service : [service.service];
  return services.find(
    (s) => s.profile === "http://iiif.io/api/search/0/autocomplete" || s.profile === "http://iiif.io/api/search/1/autocomplete" || s.profile === "AutoCompleteService1"
  );
}
var createSearch1AutocompleteStore = (service, options) => {
  const fetcher = options?.fetcher || defaultFetcher;
  const autocomplete = service ? findAutocompleteService(service) : void 0;
  const autocompleteEndpoint = autocomplete ? getId(autocomplete) : void 0;
  let abort = null;
  return createStore((set, get) => ({
    results: [],
    lastQuery: {},
    hasAutocomplete: !!autocomplete,
    endpoint: autocompleteEndpoint,
    loading: false,
    error: false,
    errorMessage: "",
    ignored: [],
    setSearchService(newService) {
      const autocomplete2 = findAutocompleteService(newService);
      if (autocomplete2) {
        set({
          endpoint: getId(autocomplete2),
          hasAutocomplete: true,
          results: [],
          loading: false,
          lastQuery: null,
          error: false,
          errorMessage: ""
        });
      }
    },
    clearSearch() {
      set({ results: [], loading: false, lastQuery: null });
    },
    async search(query, options2 = {}) {
      const endpoint = get().endpoint;
      if (get().hasAutocomplete === false) {
        return;
      }
      if (abort && !abort.signal.aborted) {
        abort.abort();
      }
      abort = new AbortController();
      const params = new URLSearchParams();
      params.set("q", query);
      if (options2.motivation) {
        params.set("motivation", options2.motivation);
      }
      if (options2.date) {
        params.set("date", options2.date);
      }
      if (options2.user) {
        params.set("user", options2.user);
      }
      let shouldLoad = true;
      if ((!query || query.length < 3) && !options2.motivation && !options2.date && !options2.user) {
        shouldLoad = false;
      }
      set({
        loading: shouldLoad,
        lastQuery: {
          q: query,
          motivation: options2.motivation,
          date: options2.date,
          user: options2.user
        }
      });
      if (!shouldLoad) {
        return;
      }
      return fetcher(`${endpoint}?${params.toString()}`, {
        signal: abort.signal,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...options2.headers || {}
        }
      }).then(async ([json, error]) => {
        if (abort?.signal.aborted) {
          return;
        }
        if (json) {
          set({
            loading: false,
            ignored: json.ignored || [],
            results: json.terms,
            error: false,
            errorMessage: ""
          });
        } else {
          set({ results: [], error: true, errorMessage: error || void 0 });
        }
      });
    }
  }));
};
function defaultFetcher(query, { signal, headers }) {
  return fetch(query, {
    signal,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...headers || {}
    }
  }).then(async (response) => {
    if (response.ok) {
      return [await response.json(), null];
    }
    return [null, response.statusText];
  });
}
var createSearch1Store = (service, options) => {
  const fetcher = options?.fetcher || defaultFetcher;
  let searchService;
  if (typeof service === "string") {
    searchService = {
      "@context": "http://iiif.io/api/search/1/context.json",
      profile: "http://iiif.io/api/search/1/search",
      "@id": service,
      id: service,
      service: []
    };
  } else {
    searchService = service;
  }
  let abort = null;
  return createStore((set, get) => ({
    endpoint: searchService ? getId(searchService) : void 0,
    service: searchService,
    resources: [],
    hits: [],
    lastQuery: {},
    loading: false,
    error: false,
    highlight: {
      results: null,
      hit: null
    },
    hitIndex: -1,
    hasSearch: !!searchService,
    hasAutocomplete: searchService ? !!findAutocompleteService(searchService) : false,
    errorMessage: "",
    async search(query, options2 = {}) {
      const endpoint = get().endpoint;
      if (!endpoint) {
        throw new Error("No search service found.");
      }
      if (abort && !abort.signal.aborted) {
        abort.abort();
      }
      abort = new AbortController();
      const params = new URLSearchParams();
      if (query.q) {
        params.set("q", query.q);
      }
      if (query.motivation) {
        params.set("motivation", query.motivation);
      }
      if (query.date) {
        params.set("date", query.date);
      }
      if (query.user) {
        params.set("user", query.user);
      }
      set({
        lastQuery: query,
        loading: true
      });
      const response = await fetcher(`${endpoint}?${params.toString()}`, {
        signal: abort.signal,
        headers: options2.headers
      }).then(([json, errorMessage]) => {
        if (abort?.signal.aborted) {
          return;
        }
        if (json) {
          set({
            resources: (json.resources || []).map((result) => {
              if (result.search && !result.url) {
                result.url = result.search;
              }
              return result;
            }),
            hits: json.hits || (json.resources || []).map((result) => {
              return {
                "@type": "search:Hit",
                after: "",
                annotations: [result["@id"]],
                before: "",
                match: result.resource.chars
              };
            }),
            error: false,
            errorMessage: "",
            loading: false
          });
        } else {
          set({
            loading: false,
            resources: [],
            error: true,
            errorMessage: errorMessage || void 0
          });
        }
      });
      return response;
    },
    setSearchService(newService) {
      set({
        service: newService,
        endpoint: newService ? getId(newService) : void 0,
        hasSearch: !!newService,
        hasAutocomplete: newService ? !!findAutocompleteService(newService) : false,
        loading: false,
        resources: [],
        error: false,
        errorMessage: "",
        highlight: { results: null, hit: null }
      });
    },
    // Other actions?
    clearSearch() {
      set({ resources: [], error: false, errorMessage: "" });
    },
    highlightHit(index) {
      const state = get();
      const hit = state.hits[index];
      if (!hit) {
        return;
      }
      const results = state.resources.filter((r) => hit.annotations.includes(r["@id"]));
      set({ hitIndex: index, highlight: { results, hit } });
    },
    nextHit() {
      const state = get();
      const nextIndex = state.hitIndex + 1;
      if (nextIndex >= state.hits.length) {
        return;
      }
      state.highlightHit(nextIndex);
    },
    previousHit() {
      const state = get();
      const nextIndex = state.hitIndex - 1;
      if (nextIndex < 0) {
        return;
      }
      state.highlightHit(nextIndex);
    }
  }));
};

export {
  findSearch1Service,
  findAutocompleteService,
  createSearch1AutocompleteStore,
  createSearch1Store
};
