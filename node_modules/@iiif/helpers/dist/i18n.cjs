"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/i18n.ts
var i18n_exports = {};
__export(i18n_exports, {
  buildLocaleString: () => buildLocaleString,
  createStringHelper: () => createStringHelper,
  getAvailableLanguagesFromResource: () => getAvailableLanguagesFromResource,
  getClosestLanguage: () => getClosestLanguage,
  getValue: () => getValue,
  iiifString: () => iiifString
});
module.exports = __toCommonJS(i18n_exports);
var import_parser = require("@iiif/parser");
function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false, skipLanguages = []) {
  if (skipLanguages.length) {
    languages = languages.filter((l) => skipLanguages.indexOf(l) === -1);
  }
  if (!languages || languages.length === 0) {
    return void 0;
  }
  if (languages.length === 1) {
    return languages[0];
  }
  if (!i18nLanguage) {
    if (languages.indexOf("none") !== -1) {
      return "none";
    }
    return languages[0];
  }
  if (languages.indexOf(i18nLanguage) !== -1) {
    return i18nLanguage;
  }
  const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
  if (root && languages.indexOf(root) !== -1) {
    return root;
  }
  for (const lang of i18nLanguages) {
    if (languages.indexOf(lang) !== -1) {
      return lang;
    }
  }
  if (!strictFallback && i18nLanguage) {
    const inverseRoot = languages.map((l) => l.indexOf("-") !== -1 ? l.slice(0, l.indexOf("-")) : null);
    const inverseIdx = inverseRoot.indexOf(i18nLanguage);
    if (inverseIdx !== -1) {
      return languages[inverseIdx];
    }
    for (const lang of i18nLanguages) {
      const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
      const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
      if (inverseIdx2 !== -1) {
        return languages[inverseIdx2];
      }
    }
  }
  if (languages.indexOf("none") !== -1) {
    return "none";
  }
  if (languages.indexOf("@none") !== -1) {
    return "@none";
  }
  return languages[0];
}
function buildLocaleString(inputText, i18nLanguage, options = {}) {
  const {
    strictFallback = false,
    defaultText = "",
    separator = "\n",
    fallbackLanguages = [],
    closest,
    skipLanguages
  } = options;
  const languages = Object.keys(inputText || {});
  const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback, skipLanguages);
  if (!inputText) {
    return defaultText;
  }
  if (typeof inputText === "string") {
    return inputText;
  }
  const candidateText = language ? inputText[language] : void 0;
  if (candidateText && language) {
    if (typeof candidateText === "string") {
      return candidateText;
    }
    if (candidateText.length === 1 && candidateText[0] === "") {
      const skip = options.skipLanguages || [];
      return buildLocaleString(inputText, i18nLanguage, {
        ...options,
        skipLanguages: [...skip, language]
      });
    }
    return candidateText.join(separator);
  }
  return "";
}
function getValue(inputText, options = {}) {
  return buildLocaleString(
    inputText,
    options.language || (typeof navigator !== "undefined" ? navigator.language : "en"),
    options
  );
}
function getLanguagesFromLanguageMap(languageMap) {
  if (!languageMap)
    return [];
  if (typeof languageMap === "string")
    return [];
  if (Array.isArray(languageMap))
    return [];
  return Object.keys(languageMap).filter((l) => l !== "none");
}
function getAvailableLanguagesFromResource(item) {
  const foundLanguages = /* @__PURE__ */ new Set();
  const findLanguages = import_parser.Traverse.all((resource) => {
    if ("label" in resource) {
      const languages = getLanguagesFromLanguageMap(resource.label);
      languages.forEach((l) => foundLanguages.add(l));
    }
    if ("summary" in resource) {
      const languages = getLanguagesFromLanguageMap(resource.summary);
      languages.forEach((l) => foundLanguages.add(l));
    }
    if ("language" in resource) {
      if (typeof resource.language === "string") {
        foundLanguages.add(resource.language);
      }
    }
    if ("requiredStatement" in resource) {
      if (resource.requiredStatement && !Array.isArray(resource.requiredStatement)) {
        if ("label" in resource.requiredStatement) {
          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.label);
          languages.forEach((l) => foundLanguages.add(l));
        }
        if ("value" in resource.requiredStatement) {
          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.value);
          languages.forEach((l) => foundLanguages.add(l));
        }
      }
    }
    if ("metadata" in resource) {
      if (Array.isArray(resource.metadata)) {
        resource.metadata.forEach((m) => {
          if ("label" in m) {
            const languages = getLanguagesFromLanguageMap(m.label);
            languages.forEach((l) => foundLanguages.add(l));
          }
          if ("value" in m) {
            const languages = getLanguagesFromLanguageMap(m.value);
            languages.forEach((l) => foundLanguages.add(l));
          }
        });
      }
    }
  });
  findLanguages.traverseUnknown(item);
  return Array.from(foundLanguages);
}
var iiifString = createStringHelper();
function createStringHelper(options = {}) {
  return (template, ...params) => {
    let result = "";
    for (let i = 0; i < template.length; i++) {
      result += template[i];
      if (i < params.length) {
        const param = params[i];
        if (param === null || param === void 0) {
          continue;
        } else if (typeof param === "string") {
          result += param;
        } else {
          result += getValue(param, options);
        }
      }
    }
    return result;
  };
}
