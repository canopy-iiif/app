"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js"(exports, module2) {
    "use strict";
    module2.exports = parse;
    var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse(path) {
      var data = [];
      path.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length[type]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length[type])
            throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length[type])));
        }
      });
      return data;
    }
    var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js"(exports, module2) {
    "use strict";
    module2.exports = absolutize;
    function absolutize(path) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y = 0;
      return path.map(function(seg) {
        seg = seg.slice();
        var type = seg[0];
        var command = type.toUpperCase();
        if (type != command) {
          seg[0] = command;
          switch (type) {
            case "a":
              seg[6] += x;
              seg[7] += y;
              break;
            case "v":
              seg[1] += y;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i = 1; i < seg.length; ) {
                seg[i++] += x;
                seg[i++] += y;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ImageServiceLoader: () => ImageServiceLoader,
  Vault: () => Vault,
  buildLocaleString: () => buildLocaleString,
  createDateNavigation: () => createDateNavigation,
  createEventsHelper: () => createEventsHelper,
  createImageServiceStore: () => createImageServiceStore,
  createPaintingAnnotationsHelper: () => createPaintingAnnotationsHelper,
  createRangeHelper: () => createRangeHelper,
  createSearch1AutocompleteStore: () => createSearch1AutocompleteStore,
  createSearch1Store: () => createSearch1Store,
  createSequenceHelper: () => createSequenceHelper,
  createStringHelper: () => createStringHelper,
  createStylesHelper: () => createStylesHelper,
  createThumbnailHelper: () => createThumbnailHelper,
  decodeContentState: () => decodeContentState,
  encodeContentState: () => encodeContentState,
  expandTarget: () => expandTarget,
  fetch: () => fetchAndUpgrade,
  findAllCanvasesInRange: () => findAllCanvasesInRange,
  findAutocompleteService: () => findAutocompleteService,
  findFirstCanvasFromRange: () => findFirstCanvasFromRange,
  findFirstCanvasFromRangeWithSelector: () => findFirstCanvasFromRangeWithSelector,
  findManifestSelectedRange: () => findManifestSelectedRange,
  findSearch1Service: () => findSearch1Service,
  findSelectedRange: () => findSelectedRange,
  getAvailableLanguagesFromResource: () => getAvailableLanguagesFromResource,
  getClosestLanguage: () => getClosestLanguage,
  getCustomSizeFromService: () => getCustomSizeFromService,
  getFixedSizeFromImage: () => getFixedSizeFromImage,
  getFixedSizesFromService: () => getFixedSizesFromService,
  getImageCandidates: () => getImageCandidates,
  getImageCandidatesFromService: () => getImageCandidatesFromService,
  getImageFromTileSource: () => getImageFromTileSource,
  getImageServerFromId: () => getImageServerFromId,
  getManifestSequence: () => getManifestSequence,
  getSmallestScaleFactorAsSingleImage: () => getSmallestScaleFactorAsSingleImage,
  getThumbnail: () => getThumbnail,
  getValue: () => getValue,
  getVisibleCanvasesFromCanvasId: () => getVisibleCanvasesFromCanvasId,
  globalVault: () => globalVault,
  iiifString: () => iiifString,
  imageServiceLoader: () => imageServiceLoader,
  imageServices: () => imageServices,
  imageSizesMatch: () => imageSizesMatch,
  inferImageSizeFromUrl: () => inferImageSizeFromUrl,
  isBestMatch: () => isBestMatch,
  isImage3: () => isImage3,
  isImageApiSelector: () => isImageApiSelector,
  normaliseContentState: () => normaliseContentState,
  parseContentState: () => parseContentState,
  parseRotation: () => parseRotation,
  parseSelector: () => parseSelector,
  parseSpecificResource: () => parseSpecificResource,
  pickBestFromCandidates: () => pickBestFromCandidates,
  rangeToTableOfContentsTree: () => rangeToTableOfContentsTree,
  rangesToTableOfContentsTree: () => rangesToTableOfContentsTree,
  sampledTilesToTiles: () => sampledTilesToTiles,
  serialiseContentState: () => serialiseContentState,
  validateContentState: () => validateContentState
});
module.exports = __toCommonJS(src_exports);

// src/compat.ts
var metaState = {};
var compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  },
  async load(id) {
    const idToLoad = typeof id === "string" ? id : id.id;
    return fetch(idToLoad).then((response) => response.json());
  },
  requestStatus(id) {
    return void 0;
  }
};

// src/events.ts
function createEventsHelper(vault = compatVault) {
  return {
    addEventListener(resource, event, listener, scope) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          const callbacks = registeredCallbacks || [];
          for (const registered of callbacks) {
            if (registered.callback === listener) {
              return callbacks;
            }
          }
          return [...callbacks, { callback: listener, scope }];
        }
      );
      return listener;
    },
    removeEventListener(resource, event, listener) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
        }
      );
    },
    getListenersAsProps(resourceOrId, scope) {
      const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
      if (!resource || !resource.id) {
        return {};
      }
      const hooks = vault.getResourceMeta(resource.id, "eventManager");
      const props = {};
      if (hooks && resource) {
        for (const hook of Object.keys(hooks)) {
          props[hook] = (e) => {
            const fullResource = vault.get(resource);
            for (const { callback, scope: _scope } of hooks[hook] || []) {
              if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                callback(e, fullResource);
              }
            }
          };
        }
      }
      return props;
    }
  };
}

// src/styles.ts
function createStylesHelper(vault = compatVault) {
  return {
    applyStyles(resource, scope, styles) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.setMetaValue([id, "styles", scope], styles);
    },
    getAppliedStyles(resource) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.getResourceMeta(id, "styles");
    }
  };
}

// src/image-service/image-service-loader.ts
var import_image_36 = require("@iiif/parser/image-3");

// src/image-service/get-image-server-from-id.ts
function getImageServerFromId(url) {
  const id = url.replace(/(https?:\/\/)?(www.)?/i, "");
  if (id.indexOf("/") !== -1) {
    return id.split("/")[0];
  }
  return id;
}

// src/image-service/sampled-tiles-to-tiles.ts
function sampledTilesToTiles(width, height, sampledTiles) {
  const maxDim = width > height ? width : height;
  const len = sampledTiles.length;
  const newTiles = [];
  for (let i = 0; i < len; i++) {
    const tile = sampledTiles[i];
    if (!tile)
      continue;
    if (tile.scaleFactors.length === 0)
      continue;
    let lastSize = tile.scaleFactors[0];
    if (!lastSize)
      continue;
    let curWidth = maxDim / lastSize;
    const scaleFactors = [lastSize];
    while (curWidth >= tile.width) {
      lastSize = lastSize * 2;
      scaleFactors.push(lastSize);
      curWidth = curWidth / 2;
    }
    newTiles.push({
      ...tile,
      scaleFactors
    });
  }
  return newTiles;
}

// src/image-service/get-image-from-tile-source.ts
var import_image_3 = require("@iiif/parser/image-3");
function getImageFromTileSource(image, targetWidth, targetHeight) {
  const req = (0, import_image_3.createImageServiceRequest)({
    "@context": image.version === 3 ? "http://iiif.io/api/image/3/context.json" : "http://iiif.io/api/image/2/context.json",
    id: (0, import_image_3.canonicalServiceUrl)((0, import_image_3.getId)(image)),
    profile: image.level === null || typeof image.level === "undefined" ? "level0" : `level${image.level}`,
    type: image.version === 3 ? "ImageService3" : "ImageService2"
  });
  if (req.type !== "image") {
    throw new Error("Invalid service");
  }
  req.size.max = false;
  req.size.width = targetWidth;
  req.size.height = targetHeight;
  const url = (0, import_image_3.imageServiceRequestToString)(req);
  return {
    id: url,
    type: "fixed",
    width: targetWidth,
    height: targetHeight || image.height / (image.width || 1) * targetWidth,
    unsafe: image.width > targetWidth
  };
}

// src/image-service/is-best-match.ts
function isBestMatch(request, current, candidate) {
  const width = !request.width ? request.maxWidth : request.width;
  return candidate.height <= request.maxHeight && candidate.width <= request.maxWidth && candidate.height >= request.minHeight && candidate.width >= request.minWidth && (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width));
}

// src/image-service/pick-best-from-candidates.ts
function pickBestFromCandidates(inputRequest, candidates) {
  const log = [];
  const request = Object.assign(
    {
      unsafeImageService: false,
      atAnyCost: true,
      fallback: true,
      minHeight: 64,
      minWidth: 64,
      maxHeight: Infinity,
      maxWidth: Infinity,
      returnAllOptions: false,
      preferFixedSize: false,
      allowUnsafe: false,
      explain: false,
      height: 0,
      width: 0
    },
    inputRequest
  );
  const explain = (text, indent = 0) => request.explain ? log.push(
    new Array(indent).fill(0).map((e) => "    ").join("") + text().trim()
  ) : void 0;
  const lastResorts = [];
  const fallback = [];
  let currentChoice = null;
  explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);
  const swapChoice = (candidate, current) => {
    explain(() => "Swapping choice", 3);
    if (isBestMatch(request, current, candidate)) {
      if (request.preferFixedSize && candidate.unsafe) {
        explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);
        fallback.push(candidate);
        return;
      }
      if (request.returnAllOptions && current) {
        fallback.push(current);
      }
      explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);
      currentChoice = candidate;
    } else if (request.returnAllOptions) {
      fallback.push(candidate);
    }
  };
  explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);
  const candidateGroups = candidates.length;
  for (let x = 0; x < candidateGroups; x++) {
    const group = candidates[x]();
    explain(() => `Candidate group ${x}: ${JSON.stringify(group, null, 2)}`, 1);
    const candidatesLength = group.length;
    explain(
      () => `Checking candidate list number ${x} and found ${candidatesLength} potential ways of creating image(s)`,
      1
    );
    for (let y = 0; y < candidatesLength; y++) {
      const candidate = group[y];
      explain(() => `-> Checking candidate ${y}`, 1);
      if (candidate.type === "unknown" && request.atAnyCost) {
        explain(() => `We've found an unknown image type, adding this to the "last resort" list`, 2);
        lastResorts.push(candidate);
      }
      if (candidate.type === "fixed") {
        if (candidate.unsafe) {
          explain(() => `We've found an unsafe fixed image type, adding this to the "last resort" list`, 2);
          lastResorts.push(candidate);
        } else {
          explain(() => `We've found a fixed size image, checking if it matches the request`, 2);
          swapChoice(candidate, currentChoice);
        }
      }
      if (candidate.type === "fixed-service") {
        if (request.unsafeImageService) {
          explain(
            () => `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,
            2
          );
          const choice = getImageFromTileSource(candidate, request.width, request.height);
          swapChoice(choice, currentChoice);
        } else {
          explain(() => `Checking for an image from the tile source 3`, 2);
          const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);
          swapChoice(choice, currentChoice);
        }
      }
      if (candidate.type === "variable") {
        if (candidate.maxWidth) {
          const choice = getImageFromTileSource(
            {
              id: candidate.id,
              type: "fixed-service",
              width: candidate.maxWidth,
              height: candidate.maxWidth,
              level: candidate.level,
              version: candidate.version
            },
            candidate.maxWidth
          );
          swapChoice(choice, currentChoice);
        }
      }
    }
    if (currentChoice && !request.returnAllOptions) {
      if (currentChoice.unsafe || request.allowUnsafe) {
        continue;
      }
      explain(() => `We found a match in choice list number ${x}, no searching any more`);
      break;
    }
  }
  if (request.atAnyCost && fallback.length === 0) {
    explain(
      () => currentChoice ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}` : `We found no images, but "atAnyCost" is set, so returning that`
    );
    return {
      best: currentChoice || lastResorts[0] || null,
      fallback: lastResorts.slice(1),
      log
    };
  }
  if (request.returnAllOptions) {
    explain(() => `Returning all options that we have found`);
    return {
      best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,
      fallback: [...fallback, ...lastResorts],
      log
    };
  }
  explain(() => `Returning the best image that we found, and a fallback`);
  return {
    best: currentChoice || fallback[0] || null,
    fallback: currentChoice ? fallback : fallback.slice(1),
    log
  };
}

// src/image-service/get-fixed-sizes-from-service.ts
var import_image_32 = require("@iiif/parser/image-3");

// src/image-service/is-image-3.ts
function isImage3(service) {
  const context = service["@context"] ? Array.isArray(service["@context"]) ? service["@context"] : [service["@context"]] : [];
  return context.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
}

// src/image-service/get-fixed-sizes-from-service.ts
function getFixedSizesFromService(service) {
  if (!(0, import_image_32.isImageService)(service)) {
    return [];
  }
  return (service && service.sizes ? service.sizes : []).map((size) => {
    return {
      id: (0, import_image_32.getId)(service),
      type: "fixed-service",
      height: size.height,
      width: size.width,
      level: (0, import_image_32.getImageServiceLevel)(service),
      version: isImage3(service) ? 3 : 2
    };
  });
}

// src/image-service/get-custom-size-from-service.ts
var import_image_33 = require("@iiif/parser/image-3");
function getCustomSizeFromService(service) {
  if (!(0, import_image_33.supportsCustomSizes)(service)) {
    return [];
  }
  const imagesSizes = [];
  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];
  const pLen = profiles.length;
  for (let x = 0; x < pLen; x++) {
    const profile = profiles[x];
    if (profile && typeof profile !== "string") {
      if (profile.maxHeight || profile.maxWidth) {
        return [
          {
            id: (0, import_image_33.getId)(service),
            type: "variable",
            minWidth: 0,
            minHeight: 0,
            maxHeight: profile.maxHeight || profile.maxWidth,
            maxWidth: profile.maxWidth || profile.maxHeight,
            level: (0, import_image_33.getImageServiceLevel)(service),
            version: service["@context"] === "http://iiif.io/api/image/3/context.json" ? 3 : 2
          }
        ];
      }
    }
  }
  if (service.tiles) {
    const len = service.tiles.length;
    for (let y = 0; y < len; y++) {
      const tile = service.tiles[y];
      if (tile && (tile.height || tile.width)) {
        imagesSizes.push({
          id: (0, import_image_33.getId)(service),
          type: "variable",
          minHeight: 0,
          minWidth: 0,
          maxHeight: tile.height || tile.width,
          maxWidth: tile.width,
          level: (0, import_image_33.getImageServiceLevel)(service),
          version: isImage3(service) ? 3 : 2
        });
      }
    }
  }
  return imagesSizes;
}

// src/image-service/get-image-candidates-from-service.ts
function getImageCandidatesFromService(service) {
  const candidates = [];
  const totalServices = service.length;
  for (let s = 0; s < totalServices; s++) {
    const single = service[s];
    if (!single)
      continue;
    const fixedSizes = getFixedSizesFromService(single);
    if (fixedSizes.length) {
      candidates.push(...fixedSizes);
    }
    const customSizes = getCustomSizeFromService(single);
    if (customSizes.length) {
      candidates.push(...customSizes);
    }
  }
  return candidates;
}

// src/image-service/infer-size-from-url.ts
function inferImageSizeFromUrl(image) {
  const regex = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/;
  const match = image.match(regex);
  if (match && match[4] && match[5]) {
    const region = match[1];
    const width = parseInt(match[4], 10);
    const height = parseInt(match[5], 10);
    const format = match[7];
    if ((region === "max" || region === "full") && width && height && format) {
      return {
        type: "fixed",
        id: image,
        height,
        width
      };
    }
  }
  return { type: "unknown", id: image };
}

// src/image-service/get-fixed-size-from-image.ts
var import_image_34 = require("@iiif/parser/image-3");
function getFixedSizeFromImage(contentResource) {
  if (typeof contentResource === "string") {
    return inferImageSizeFromUrl(contentResource);
  }
  const type = (0, import_image_34.getType)(contentResource);
  if (type !== "Image" && type !== "sc:Image") {
    return null;
  }
  const image = contentResource;
  const id = (0, import_image_34.getId)(image);
  if (!id) {
    return null;
  }
  if (id && image.width && image.height) {
    return {
      id,
      type: "fixed",
      width: image.width,
      height: image.height,
      unsafe: true
    };
  }
  return inferImageSizeFromUrl(id);
}

// src/image-service/get-image-candidates.ts
var import_image_35 = require("@iiif/parser/image-3");
function getImageCandidates(unknownResource, dereference = true, loader) {
  const candidates = [];
  const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);
  if (fixedSizeFromImage === null) {
    return candidates;
  }
  const resource = unknownResource;
  candidates.push(fixedSizeFromImage);
  if (dereference && resource && resource.width && resource.height) {
    const refCandidates = [];
    const imageServices2 = (0, import_image_35.getImageServices)(resource);
    for (const service of imageServices2) {
      const request = {
        id: (0, import_image_35.getId)(service),
        width: resource.width,
        height: resource.height
      };
      if (loader.canLoadSync(request)) {
        const externalService = loader.loadServiceSync(request);
        if (externalService) {
          if (!externalService.height) {
            externalService.height = resource.height;
          }
          if (!externalService.width) {
            externalService.width = resource.width;
          }
          refCandidates.push(...getImageCandidatesFromService([externalService]));
        }
      }
    }
    if (refCandidates.length) {
      candidates.push(...refCandidates);
      return candidates;
    }
  }
  if (resource.service) {
    candidates.push(...getImageCandidatesFromService(resource.service));
  }
  return candidates;
}

// src/image-service/image-sizes-match.ts
function imageSizesMatch(sizesA, sizesB) {
  if (sizesA.length !== sizesB.length) {
    return false;
  }
  if (sizesA.length === 0 && sizesB.length === 0) {
    return true;
  }
  const len = sizesA.length;
  let matchOrder = true;
  for (let i = 0; i < len; i++) {
    const a = sizesA[i];
    const b = sizesB[i];
    if (a.width !== b.width || a.height !== b.height) {
      matchOrder = false;
      break;
    }
  }
  if (matchOrder) {
    return true;
  }
  let matching = 0;
  for (let a = 0; a < len; a++) {
    for (let b = 0; b < len; b++) {
      if (sizesA[a].width === sizesB[b].width && sizesA[a].height === sizesB[b].height) {
        matching++;
        break;
      }
    }
  }
  return matching === len;
}

// src/image-service/image-service-loader.ts
var ImageServiceLoader = class {
  constructor(options = {}) {
    __publicField(this, "config", {
      verificationsRequired: 1,
      approximateServices: false,
      enableFetching: true,
      disableThrottling: false
    });
    __publicField(this, "fetchingCount", 0);
    __publicField(this, "imageServices", {});
    __publicField(this, "knownImageServers", {});
    this.config = Object.assign(this.config, options);
  }
  /**
   * Preload image service
   *
   * This will preload an image service, fetching details and recording the image server that served
   * the request. Based on this it will make a template for predicting other image sources from this
   * server. You can optionally pass in other ids to verify that the prediction is accurate.
   *
   */
  // async preload(id: string, verify?: string[]): Promise<void> {}
  setConfig(config) {
    Object.assign(this.config, config);
  }
  /**
   * Sample pre-fetched service
   *
   * If you have already fetched an image service, or are creating a viewer that only talks to a single
   * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
   * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
   *
   * @param service
   * @param preLoaded Mark this as being pre-loaded (default: true)
   */
  sample(service, imageServiceRequest, preLoaded = true) {
    const server = getImageServerFromId((0, import_image_36.getId)(service));
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(service));
    const existing = this.knownImageServers[server];
    this.imageServices[serviceUrl] = Object.assign(service, { real: true });
    if (!existing && service.tiles && !(0, import_image_36.isLevel0)(service)) {
      this.knownImageServers[server] = {
        verifications: 0,
        malformed: false,
        root: server,
        preLoaded,
        sampledId: (0, import_image_36.getId)(service),
        verified: false,
        server: null,
        result: {
          context: service["@context"] || [],
          sampledProfile: service.profile,
          resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,
          sampledSizes: service.sizes || [],
          sizeRatios: (0, import_image_36.extractFixedSizeScales)(service.width, service.height, service.sizes || []),
          sampledTiles: service.tiles || []
        }
      };
      return true;
    }
    return this.verify(service);
  }
  /**
   * Preload an image server
   *
   * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
   * allowing you to correct mistakes this implementation might have made.
   *
   * @param server
   * @param forceVerify
   */
  preLoad(server, forceVerify = true) {
    this.knownImageServers[server.root] = server;
    if (forceVerify) {
      this.knownImageServers[server.root].malformed = false;
      this.knownImageServers[server.root].verifications = this.config.verificationsRequired;
    }
  }
  /**
   * Predict
   *
   * Predicts what the image service will be for a content resource.
   *
   * @param resource
   * @param verify
   * @param force
   */
  predict(resource, verify = false, force = false) {
    const source = resource?.source;
    const serverId = getImageServerFromId((0, import_image_36.getId)(resource));
    const imageServer = this.knownImageServers[serverId];
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(resource));
    if (this.imageServices[serviceUrl]) {
      return this.imageServices[serviceUrl] || null;
    }
    if (!this.config.approximateServices) {
      return null;
    }
    if (!imageServer || !imageServer.result || !(source?.height || resource.height) || !(source?.width || resource.width) || !force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired) || resource.source && (0, import_image_36.isLevel0)(resource.source)) {
      return null;
    }
    if (!this.imageServices[serviceUrl]) {
      this.imageServices[serviceUrl] = {
        "@context": imageServer.result.context,
        "@id": (0, import_image_36.getId)(resource),
        id: (0, import_image_36.getId)(resource),
        protocol: "http://iiif.io/api/image",
        tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),
        sizes: source?.sizes || (0, import_image_36.fixedSizesFromScales)(
          Math.round(resource.width / imageServer.result.resourceServiceRatio),
          Math.round(resource.height / imageServer.result.resourceServiceRatio),
          imageServer.result.sizeRatios
        ),
        profile: source?.profile || imageServer.result.sampledProfile,
        height: source?.height || resource.height,
        width: source?.width || resource.width,
        real: false
      };
    }
    return this.imageServices[serviceUrl] || null;
  }
  async getThumbnailFromResource(unknownResource, request, dereference = true, otherCandidates = []) {
    const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];
    return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);
  }
  async getImageCandidates(unknownResource, dereference = true) {
    const resource = unknownResource;
    if (dereference && resource && resource.height && resource.width) {
      const imageServices2 = (0, import_image_36.getImageServices)(resource);
      for (const service of imageServices2) {
        const request = {
          id: (0, import_image_36.getId)(service),
          width: service.width ? service.width : resource.width,
          height: service.height ? service.height : resource.height,
          source: service
        };
        await this.loadService(request);
      }
    }
    return getImageCandidates(unknownResource, dereference, this);
  }
  /**
   * Verify approximation
   *
   * Given an image service, it will dereference that image service and compare the result with what
   * would have been generated if we used internal guessing.
   *
   * @param resource
   * @return Promise<boolean>
   */
  async verify(resource) {
    const prediction = this.predict(resource, false, true);
    const imageService = await this.fetchService((0, import_image_36.getId)(resource));
    if (!prediction) {
      return false;
    }
    const isValid = prediction.height === imageService.height && prediction.width === imageService.width && prediction["@context"] === imageService["@context"] && imageSizesMatch(prediction.sizes || [], imageService.sizes || []);
    if (isValid) {
      const serverId = getImageServerFromId((0, import_image_36.getId)(resource));
      const server = this.knownImageServers[serverId];
      if (server) {
        server.verifications += 1;
        if (server.verifications >= this.config.verificationsRequired) {
          server.verified = true;
        }
      }
    }
    return isValid;
  }
  canLoadSync(service) {
    const serviceId = typeof service === "string" ? service : (0, import_image_36.getId)(service);
    const canonical = (0, import_image_36.canonicalServiceUrl)(serviceId);
    if (this.imageServices[canonical]) {
      return true;
    }
    const server = this.knownImageServers[getImageServerFromId(serviceId)];
    return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);
  }
  /**
   * Mark image service as malformed
   *
   * If you run into issues requesting images, you can mark an image service as malformed, and it will
   * return you a new one. Future image services will also be requested fresh, and the system will have
   * failed. Report a bug if this happens.
   *
   * @param resource
   */
  async markAsMalformed(resource) {
    this.knownImageServers[getImageServerFromId((0, import_image_36.getId)(resource))].malformed = true;
    return this.loadService(resource, true);
  }
  /**
   * Fetch an image service (use loadService instead)
   *
   * @param serviceId
   * @param forceFresh
   */
  async fetchService(serviceId, forceFresh = false) {
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)(serviceId);
    const service = this.imageServices[serviceUrl];
    if (service && (!forceFresh || service.real)) {
      return service;
    }
    if (!this.config.enableFetching) {
      throw new Error("Fetching is not enabled");
    }
    const json = await this.fetch(serviceUrl).then((service2) => service2.json());
    if (!json.id && json["@id"]) {
      json.id = json["@id"];
    }
    if (json.id !== serviceId) {
      json.id = serviceId;
      if (json["@id"]) {
        json["@id"] = serviceId;
      }
    }
    this.imageServices[serviceUrl] = Object.assign(json, { real: true });
    return this.imageServices[serviceUrl];
  }
  async fetch(input, init) {
    return fetch(input, init);
  }
  /**
   * Load an image service
   *
   * @param resource
   * @param forceFresh
   *
   * @todo make this batched, so only the maximum required can be done at once, to allow
   *       for the prediction engine to kick in.
   */
  async loadService(resource, forceFresh = false) {
    if (!this.config.disableThrottling) {
      let running = true;
      while (running) {
        if (this.fetchingCount >= this.config.verificationsRequired) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        } else {
          running = false;
          break;
        }
      }
    }
    const imageServer = this.knownImageServers[getImageServerFromId((0, import_image_36.getId)(resource))];
    if (imageServer && !imageServer.malformed && !forceFresh) {
      await imageServer.result;
      const service = this.loadServiceSync(resource);
      if (service) {
        return service;
      }
    }
    this.fetchingCount++;
    const serviceJson = await this.fetchService((0, import_image_36.getId)(resource), forceFresh);
    this.fetchingCount--;
    if (serviceJson.real) {
      this.sample(serviceJson, resource);
    }
    return serviceJson;
  }
  /**
   * Load service synchronously
   *
   * If you know that the image service you are
   * @param resource
   */
  loadServiceSync(resource) {
    const serviceId = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(resource));
    if (this.imageServices[serviceId]) {
      return this.imageServices[serviceId];
    }
    if (!this.config.approximateServices) {
      return null;
    }
    return this.predict(resource);
  }
};

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// src/image-service/image-service-store.ts
var import_image_37 = require("@iiif/parser/image-3");
function createImageServiceStore(options = {}) {
  const events = options.events || mitt_default();
  const loader = options.loader || new ImageServiceLoader();
  const store = createStore((set, get) => ({
    loaded: {},
    loadServiceSync: (service, detail, backgroundRequest) => {
      const id = service.id || service["@id"];
      const existing = get().loaded[id];
      if (existing && existing.status === "done") {
        return existing.service;
      }
      if (existing && existing.status === "loading") {
        return null;
      }
      if (existing && existing.status === "error") {
        throw new Error("Failed to load image service");
      }
      const request = {
        id: (0, import_image_37.getId)(service),
        width: service.width || detail?.width || 0,
        height: service.height || detail?.height || 0,
        source: service
      };
      const loaded = loader.loadServiceSync(request);
      if (loaded) {
        set((state) => ({
          loaded: {
            ...state.loaded,
            [id]: {
              status: "done",
              service: loaded,
              real: true
            }
          }
        }));
        events.emit("image-service.loaded", { id, service: loaded });
      } else {
        if (backgroundRequest) {
          get().loadService(service, detail).then(() => {
          });
        }
      }
      return loaded;
    },
    loadService: async (service, detail) => {
      const id = service.id || service["@id"];
      const existing = get().loaded[id];
      if (existing && existing.status === "done") {
        return existing.service;
      }
      if (existing && existing.status === "loading") {
        return new Promise((resolve, reject) => {
          const handler = (e) => {
            if (e.id === id) {
              events.off("image-service.loaded", handler);
              resolve(e.service || service);
            }
          };
          events.on("image-service.loaded", handler);
        });
      }
      if (existing && existing.status === "error" && !detail?.force) {
        throw new Error("Failed to load image service");
      }
      events.emit("image-service.loading", { id });
      try {
        const request = {
          id: (0, import_image_37.getId)(service),
          width: service.width || 0,
          height: service.height || 0,
          source: service
        };
        const loaded = await loader.loadService(request, detail?.force);
        set((state) => ({
          loaded: {
            ...state.loaded,
            [id]: {
              status: "done",
              service: loaded,
              real: loaded.real
            }
          }
        }));
        events.emit("image-service.loaded", { id, service: loaded });
        return loaded;
      } catch (error) {
        events.emit("image-service.error", { id, error });
        throw error;
      }
    }
  }));
  return {
    store,
    events
  };
}
var imageServices = createImageServiceStore();

// src/image-service/get-smallest-scale-factor-as-single-image.ts
var import_image_38 = require("@iiif/parser/image-3");
function getSmallestScaleFactorAsSingleImage(service) {
  if (!service.width || !service.height) {
    return null;
  }
  if (service.tiles) {
    const tiles = service.tiles.sort((a, b) => {
      return Math.max(...b.scaleFactors) - Math.max(...a.scaleFactors);
    });
    const len = tiles.length;
    for (let i = 0; i < len; i++) {
      const tile = tiles[i];
      if (!tile)
        continue;
      const targetSize = tile.width;
      if (!targetSize) {
        continue;
      }
      const sizeLen = tile.scaleFactors.length;
      const sortedScales = tile.scaleFactors.sort();
      for (let j = 0; j < sizeLen; j++) {
        const size = sortedScales[j];
        if (!size)
          continue;
        if (service.width / size <= targetSize && service.height / size <= targetSize) {
          return {
            id: (0, import_image_38.getId)(service),
            type: "fixed-service",
            width: service.width / size | 0,
            height: service.height / size | 0,
            level: (0, import_image_38.getImageServiceLevel)(service),
            version: isImage3(service) ? 3 : 2
          };
        }
      }
    }
  }
  return null;
}

// src/thumbnail.ts
var imageServiceLoader = new ImageServiceLoader();
var helpers = /* @__PURE__ */ new Map();
function getThumbnail(input, {
  vault = compatVault,
  dereference = false,
  ...options
} = {}) {
  let helper = helpers.get(vault);
  if (!helper) {
    helper = createThumbnailHelper(vault);
    helpers.set(vault, helper);
  }
  return helper.getBestThumbnailAtSize(input, options, dereference);
}
function createThumbnailHelper(vault = compatVault, dependencies = {}) {
  const loader = dependencies.imageServiceLoader || imageServiceLoader;
  async function getBestThumbnailAtSize(input, request, dereference = false, candidates = [], dimensions) {
    const thumbnailNotFound = () => loader.getThumbnailFromResource(void 0, request, dereference, candidates);
    if (!input) {
      return await loader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    if (typeof input === "string") {
      const fixed = getFixedSizeFromImage(input);
      if (fixed) {
        candidates.push(fixed);
      }
      return await loader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    const fullInput = vault.get(input, { skipSelfReturn: false });
    if (typeof fullInput === "string") {
      return { best: getFixedSizeFromImage(fullInput), fallback: [], log: [] };
    }
    if (!fullInput) {
      return await thumbnailNotFound();
    }
    const parseThumbnail = async (resource) => {
      if (resource && resource.thumbnail && resource.thumbnail.length) {
        const thumbnail = vault.get(resource.thumbnail[0]);
        const potentialThumbnails = await loader.getImageCandidates(thumbnail, dereference);
        if (potentialThumbnails && potentialThumbnails.length) {
          candidates.push(...potentialThumbnails);
        }
      }
    };
    await parseThumbnail(fullInput);
    switch (fullInput.type) {
      case "Annotation": {
        const contentResources = Array.isArray(fullInput.body) ? fullInput.body : [fullInput.body];
        const firstContentResources = vault.get(contentResources[0]);
        if (dimensions && !firstContentResources.width) {
          firstContentResources.width = dimensions.width;
          firstContentResources.height = dimensions.height;
        }
        return await loader.getThumbnailFromResource(firstContentResources, request, dereference, candidates);
      }
      case "Canvas": {
        const canvas = fullInput;
        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
          width: canvas.width,
          height: canvas.height
        });
      }
      case "AnnotationPage": {
        const annotationPage = fullInput;
        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
      }
      case "Choice": {
        const choice = fullInput;
        if (!choice.items || choice.items[0]) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
      }
      case "Collection": {
        const collection = fullInput;
        const firstManifest = collection.items[0];
        if (!firstManifest) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
      }
      case "Manifest": {
        const manifest = fullInput;
        const firstCanvas = manifest.items[0];
        if (!firstCanvas) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
      }
      case "SpecificResource":
      case "Image":
      case "Dataset":
      case "Sound":
      case "Text":
      case "TextualBody":
      case "Video":
        if (dimensions && !fullInput.width) {
          fullInput.width = dimensions.width;
          fullInput.height = dimensions.height;
        }
        return loader.getThumbnailFromResource(fullInput, request, dereference, candidates);
    }
    return await thumbnailNotFound();
  }
  return {
    getBestThumbnailAtSize
  };
}

// src/i18n.ts
var import_parser = require("@iiif/parser");
function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false, skipLanguages = []) {
  if (skipLanguages.length) {
    languages = languages.filter((l) => skipLanguages.indexOf(l) === -1);
  }
  if (!languages || languages.length === 0) {
    return void 0;
  }
  if (languages.length === 1) {
    return languages[0];
  }
  if (!i18nLanguage) {
    if (languages.indexOf("none") !== -1) {
      return "none";
    }
    return languages[0];
  }
  if (languages.indexOf(i18nLanguage) !== -1) {
    return i18nLanguage;
  }
  const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
  if (root && languages.indexOf(root) !== -1) {
    return root;
  }
  for (const lang of i18nLanguages) {
    if (languages.indexOf(lang) !== -1) {
      return lang;
    }
  }
  if (!strictFallback && i18nLanguage) {
    const inverseRoot = languages.map((l) => l.indexOf("-") !== -1 ? l.slice(0, l.indexOf("-")) : null);
    const inverseIdx = inverseRoot.indexOf(i18nLanguage);
    if (inverseIdx !== -1) {
      return languages[inverseIdx];
    }
    for (const lang of i18nLanguages) {
      const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
      const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
      if (inverseIdx2 !== -1) {
        return languages[inverseIdx2];
      }
    }
  }
  if (languages.indexOf("none") !== -1) {
    return "none";
  }
  if (languages.indexOf("@none") !== -1) {
    return "@none";
  }
  return languages[0];
}
function buildLocaleString(inputText, i18nLanguage, options = {}) {
  const {
    strictFallback = false,
    defaultText = "",
    separator = "\n",
    fallbackLanguages = [],
    closest,
    skipLanguages
  } = options;
  const languages = Object.keys(inputText || {});
  const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback, skipLanguages);
  if (!inputText) {
    return defaultText;
  }
  if (typeof inputText === "string") {
    return inputText;
  }
  const candidateText = language ? inputText[language] : void 0;
  if (candidateText && language) {
    if (typeof candidateText === "string") {
      return candidateText;
    }
    if (candidateText.length === 1 && candidateText[0] === "") {
      const skip = options.skipLanguages || [];
      return buildLocaleString(inputText, i18nLanguage, {
        ...options,
        skipLanguages: [...skip, language]
      });
    }
    return candidateText.join(separator);
  }
  return "";
}
function getValue(inputText, options = {}) {
  return buildLocaleString(
    inputText,
    options.language || (typeof navigator !== "undefined" ? navigator.language : "en"),
    options
  );
}
function getLanguagesFromLanguageMap(languageMap) {
  if (!languageMap)
    return [];
  if (typeof languageMap === "string")
    return [];
  if (Array.isArray(languageMap))
    return [];
  return Object.keys(languageMap).filter((l) => l !== "none");
}
function getAvailableLanguagesFromResource(item) {
  const foundLanguages = /* @__PURE__ */ new Set();
  const findLanguages = import_parser.Traverse.all((resource) => {
    if ("label" in resource) {
      const languages = getLanguagesFromLanguageMap(resource.label);
      languages.forEach((l) => foundLanguages.add(l));
    }
    if ("summary" in resource) {
      const languages = getLanguagesFromLanguageMap(resource.summary);
      languages.forEach((l) => foundLanguages.add(l));
    }
    if ("language" in resource) {
      if (typeof resource.language === "string") {
        foundLanguages.add(resource.language);
      }
    }
    if ("requiredStatement" in resource) {
      if (resource.requiredStatement && !Array.isArray(resource.requiredStatement)) {
        if ("label" in resource.requiredStatement) {
          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.label);
          languages.forEach((l) => foundLanguages.add(l));
        }
        if ("value" in resource.requiredStatement) {
          const languages = getLanguagesFromLanguageMap(resource.requiredStatement.value);
          languages.forEach((l) => foundLanguages.add(l));
        }
      }
    }
    if ("metadata" in resource) {
      if (Array.isArray(resource.metadata)) {
        resource.metadata.forEach((m) => {
          if ("label" in m) {
            const languages = getLanguagesFromLanguageMap(m.label);
            languages.forEach((l) => foundLanguages.add(l));
          }
          if ("value" in m) {
            const languages = getLanguagesFromLanguageMap(m.value);
            languages.forEach((l) => foundLanguages.add(l));
          }
        });
      }
    }
  });
  findLanguages.traverseUnknown(item);
  return Array.from(foundLanguages);
}
var iiifString = createStringHelper();
function createStringHelper(options = {}) {
  return (template, ...params) => {
    let result = "";
    for (let i = 0; i < template.length; i++) {
      result += template[i];
      if (i < params.length) {
        const param = params[i];
        if (param === null || param === void 0) {
          continue;
        } else if (typeof param === "string") {
          result += param;
        } else {
          result += getValue(param, options);
        }
      }
    }
    return result;
  };
}

// node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = /* @__PURE__ */ function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
var modules_default = arcToBezier;

// src/annotation-targets/normalize-svg.ts
var import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
var import_abs_svg_path = __toESM(require_abs_svg_path(), 1);
function parseAndNormalizeSvgPath(path) {
  const parsed = (0, import_parse_svg_path.default)(path);
  const absolute = (0, import_abs_svg_path.default)(parsed);
  let prevCmd;
  let startX = 0;
  let startY = 0;
  let bezierX = 0;
  let bezierY = 0;
  let quadX;
  let quadY;
  let x = 0;
  let y = 0;
  const out = [];
  for (let i = 0; i < absolute.length; i++) {
    let seg = absolute[i];
    const cmd = seg[0];
    switch (cmd) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "H":
        seg = ["L", seg[1], startY];
        break;
      case "V":
        seg = ["L", startX, seg[1]];
        break;
      case "S":
        {
          let cx = x;
          let cy = y;
          if (prevCmd === "C" || prevCmd == "S") {
            cx += cx - bezierX;
            cy += cy - bezierY;
          }
          seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
        }
        break;
      case "T":
        if (prevCmd === "Q" || prevCmd == "T") {
          quadX = x * 2 - quadX;
          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }
        seg = ["Q", quadX, quadY, seg[1], seg[2]];
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        break;
      case "A":
        {
          const curves = modules_default({
            px: x,
            py: y,
            cx: seg[6],
            cy: seg[7],
            rx: seg[1],
            ry: seg[2],
            xAxisRotation: seg[3],
            largeArcFlag: seg[4],
            sweepFlag: seg[5]
          });
          if (!curves.length) {
            continue;
          }
          for (const [j, curve] of curves.entries()) {
            seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
            if (j < curves.length - 1) {
              out.push(seg);
            }
          }
          seg = seg;
        }
        break;
      case "Z":
        seg = ["L", startX, startY];
        break;
    }
    prevCmd = cmd;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];
    if (["C", "Q", "A"].indexOf(cmd) > -1) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }
    out.push(seg);
  }
  return out;
}

// src/annotation-targets/bezier.ts
function flattenQuadraticBezier(start, control, end, tolerance = 1) {
  return new QuadraticBezier(start, control, end).subdivide(tolerance);
}
function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
  return new CubicBezier(
    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
  ).subdivide(tolerance);
}
function hypot2(p) {
  return p.x * p.x + p.y * p.y;
}
function approx_myint(x) {
  const d = 0.67;
  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));
}
function approx_inv_myint(x) {
  const b = 0.39;
  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));
}
var QuadraticBezier = class {
  constructor(start, control, end) {
    __publicField(this, "start");
    __publicField(this, "control");
    __publicField(this, "end");
    this.start = start;
    this.control = control;
    this.end = end;
  }
  eval(t) {
    const mt = 1 - t;
    return {
      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,
      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t
    };
  }
  mapToBasic() {
    const { x: x0, y: y0 } = this.start;
    const { x: x1, y: y1 } = this.control;
    const { x: x2, y: y2 } = this.end;
    const ddx = 2 * x1 - x0 - x2;
    const ddy = 2 * y1 - y0 - y2;
    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;
    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;
    const paramX0 = u0 / cross;
    const paramX2 = u2 / cross;
    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
    return { x0, x2, scale, cross };
  }
  subdivide(tolerance) {
    const params = this.mapToBasic();
    const a0 = approx_myint(params.x0);
    const a2 = approx_myint(params.x2);
    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);
    const n = Math.ceil(count);
    const u0 = approx_inv_myint(a0);
    const u2 = approx_inv_myint(a2);
    const tValues = [0];
    for (let i = 1; i < n; i++) {
      const u = approx_inv_myint(a0 + (a2 - a0) * i / n);
      const t = (u - u0) / (u2 - u0);
      tValues.push(t);
    }
    tValues.push(1);
    return tValues.map((t) => this.eval(t));
  }
};
var CubicBezier = class _CubicBezier {
  /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].
  constructor(coords) {
    __publicField(this, "c");
    this.c = coords;
  }
  weightsum(c0, c1, c2, c3) {
    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
    return { x, y };
  }
  eval(t) {
    const mt = 1 - t;
    const c0 = mt * mt * mt;
    const c1 = 3 * mt * mt * t;
    const c2 = 3 * mt * t * t;
    const c3 = t * t * t;
    return this.weightsum(c0, c1, c2, c3);
  }
  deriv(t) {
    const mt = 1 - t;
    const c0 = -3 * mt * mt;
    const c3 = 3 * t * t;
    const c1 = -6 * t * mt - c0;
    const c2 = 6 * t * mt - c3;
    return this.weightsum(c0, c1, c2, c3);
  }
  // quadratic bezier with matching endpoints and minimum max vector error
  midpoint_quadbez() {
    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
  }
  subsegment(t0, t1) {
    const c = new Float64Array(8);
    const p0 = this.eval(t0);
    const p3 = this.eval(t1);
    c[0] = p0.x;
    c[1] = p0.y;
    const scale = (t1 - t0) / 3;
    const d1 = this.deriv(t0);
    c[2] = p0.x + scale * d1.x;
    c[3] = p0.y + scale * d1.y;
    const d2 = this.deriv(t1);
    c[4] = p3.x - scale * d2.x;
    c[5] = p3.y - scale * d2.y;
    c[6] = p3.x;
    c[7] = p3.y;
    return new _CubicBezier(c);
  }
  // Very fancy subdivision scheme
  subdivide(tol) {
    const tol1 = 0.1 * tol;
    const tol2 = tol - tol1;
    const sqrt_tol2 = Math.sqrt(tol2);
    const err2 = hypot2(this.weightsum(1, -3, 3, -1));
    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
    const quads = [];
    let sum = 0;
    for (let i2 = 0; i2 < n_quads; i2++) {
      const t0 = i2 / n_quads;
      const t1 = (i2 + 1) / n_quads;
      const quad = this.subsegment(t0, t1).midpoint_quadbez();
      const params = quad.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a2 = approx_myint(params.x2);
      const scale = Math.sqrt(params.scale);
      let val2 = Math.abs(a2 - a0) * scale;
      if (Math.sign(params.x0) != Math.sign(params.x2)) {
        const xmin = sqrt_tol2 / scale;
        const cusp_val = sqrt_tol2 * Math.abs(a2 - a0) / approx_myint(xmin);
        val2 = Math.max(val2, cusp_val);
      }
      quads.push({
        quad,
        a0,
        a2,
        val: val2
      });
      sum += val2;
    }
    const count = 0.5 * sum / sqrt_tol2;
    const n = Math.ceil(count);
    const result = [{ x: this.c[0], y: this.c[1] }];
    let val = 0;
    let i = 0;
    for (let j = 1; j < n; j++) {
      const target = sum * j / n;
      while (val + quads[i].val < target) {
        val += quads[i].val;
        i++;
      }
      const a0 = quads[i].a0;
      const a2 = quads[i].a2;
      const u0 = approx_inv_myint(a0);
      const u2 = approx_inv_myint(a2);
      const a = a0 + (a2 - a0) * (target - val) / quads[i].val;
      const u = approx_inv_myint(a);
      const t = (u - u0) / (u2 - u0);
      result.push(quads[i].quad.eval(t));
    }
    result.push({ x: this.c[6], y: this.c[7] });
    return result;
  }
};

// src/annotation-targets/parse-selector.ts
var BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
var TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(\.[0-9]+)?)?(,([0-9]+(\.[0-9]+)?))?/;
var RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
function parseSelector(source, {
  domParser,
  svgPreprocessor,
  iiifRenderingHints
} = {}) {
  if (Array.isArray(source)) {
    return resolveHints(
      source.reduce(
        (data, nextSource) => {
          const {
            selector,
            selectors,
            iiifRenderingHints: newIiifRenderingHints
          } = parseSelector(nextSource, { domParser, svgPreprocessor, iiifRenderingHints });
          if (selector) {
            if (!data.selector) {
              data.selector = selector;
            }
            data.selectors.push(...selectors);
          }
          if (newIiifRenderingHints) {
            data.iiifRenderingHints = data.iiifRenderingHints || { type: "ImageApiSelector" };
            Object.assign(data.iiifRenderingHints, newIiifRenderingHints);
          }
          return data;
        },
        {
          selector: null,
          selectors: [],
          iiifRenderingHints
        }
      )
    );
  }
  if (!source) {
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  if (typeof source === "string") {
    const [id, fragment] = source.split("#");
    if (!fragment) {
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    return parseSelector(
      { type: "FragmentSelector", value: fragment },
      { svgPreprocessor, iiifRenderingHints, domParser }
    );
  }
  if (source.type) {
    if (source.type === "PointSelector" && (source.t || source.t === 0)) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: source.t
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
    if (source.type === "PointSelector" && source.x && source.y) {
      const selector = {
        type: "PointSelector",
        spatial: {
          x: source.x,
          y: source.y
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
  }
  if (isImageApiSelector(source)) {
    const selectors = [];
    if (source.region) {
      const parsedRegion = parseSelector(
        { type: "FragmentSelector", value: "xywh=" + source.region },
        { domParser, svgPreprocessor, iiifRenderingHints }
      );
      selectors.push(...parsedRegion.selectors);
    }
    return resolveHints({
      selector: selectors[0],
      selectors,
      iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source
    });
  }
  if (source.type === "FragmentSelector") {
    const matchBoxSelector = BOX_SELECTOR.exec(source.value);
    if (matchBoxSelector) {
      let selector = {
        type: "BoxSelector",
        spatial: {
          unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
          x: Number.parseFloat(matchBoxSelector[3]),
          y: Number.parseFloat(matchBoxSelector[4]),
          width: Number.parseFloat(matchBoxSelector[5]),
          height: Number.parseFloat(matchBoxSelector[6])
        }
      };
      const matchBoxTimeSelector = source.value.match(TEMPORAL_SELECTOR);
      if (matchBoxTimeSelector) {
        selector = {
          type: "TemporalBoxSelector",
          spatial: selector.spatial,
          temporal: {
            startTime: matchBoxTimeSelector[3] ? Number.parseFloat(matchBoxTimeSelector[3]) : 0,
            endTime: matchBoxTimeSelector[6] ? Number.parseFloat(matchBoxTimeSelector[6]) : void 0
          }
        };
      }
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
    if (matchTimeSelector) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: matchTimeSelector[3] ? Number.parseFloat(matchTimeSelector[3]) : 0,
          endTime: matchTimeSelector[6] ? Number.parseFloat(matchTimeSelector[6]) : void 0
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  if (source.type === "SvgSelector" && "value" in source) {
    if (!domParser) {
      if (typeof window !== "undefined") {
        domParser = new window.DOMParser();
      } else {
        console.warn(
          "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
        );
      }
    }
    let points = [];
    let rect;
    let style;
    let svg = svgPreprocessor?.(source.value) ?? source.value;
    let svgShape;
    if (domParser) {
      const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
      if (!svgElement) {
        console.warn(`Illegal SVG selector: ${source.value}`);
        return resolveHints({
          selector: null,
          selectors: [],
          iiifRenderingHints
        });
      }
      const selectorElem = getSelectorElement(svgElement);
      if (selectorElem) {
        points = selectorElem.points;
        svgShape = selectorElem.shapeType;
        rect = [
          Math.min(...points.map((p) => p[0])),
          // llx
          Math.min(...points.map((p) => p[1])),
          // lly
          Math.max(...points.map((p) => p[0])),
          // urx
          Math.max(...points.map((p) => p[1]))
          // ury
        ];
        ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });
      }
    }
    const sel = {
      type: "SvgSelector",
      svg,
      svgShape,
      style,
      points: points.length ? points : void 0,
      spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
    };
    return resolveHints({
      selector: sel,
      selectors: [sel],
      iiifRenderingHints
    });
  }
  return resolveHints({
    selector: null,
    selectors: [],
    iiifRenderingHints
  });
}
function getShapeTypeFromPath(svgPath) {
  const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
    (acc, cmd) => {
      acc[cmd] += 1;
      return acc;
    },
    { C: 0, Q: 0, L: 0, M: 0 }
  );
  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
    return "path";
  }
  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
    if (cmdFrequencies.L === 4) {
      return "rect";
    }
    const lastSeg = svgPath.slice(-1)[0];
    if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
      return "polygon";
    } else {
      return "polyline";
    }
  }
  return "path";
}
function getSelectorElement(svgElem) {
  for (const element of Array.from(svgElem.children)) {
    switch (element?.tagName.toLowerCase()) {
      case "g":
        {
          const res = getSelectorElement(element);
          if (res) {
            return res;
          }
        }
        continue;
      case "path": {
        const p = element.getAttribute("d");
        if (!p) {
          continue;
        }
        const normalized = parseAndNormalizeSvgPath(p);
        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
      }
      case "circle": {
        const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
        const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
        const r = Number.parseFloat(element.getAttribute("r") ?? "0");
        if (!r) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const rad = angle * Math.PI / 180;
          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);
        }
        return { element, points, shapeType: "circle" };
      }
      case "ellipse": {
        const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
        const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
        const rx = Number.parseFloat(element.getAttribute("rx") ?? "0");
        const ry = Number.parseFloat(element.getAttribute("ry") ?? "0");
        if (!rx && !ry) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const t = Math.tan(angle / 360 * Math.PI);
          const px = rx * (1 - t ** 2) / (1 + t ** 2);
          const py = ry * 2 * t / (1 + t ** 2);
          points.push([cx + px, cy + py]);
        }
        return { element, points, shapeType: "ellipse" };
      }
      case "line": {
        const x0 = Number.parseFloat(element.getAttribute("x0") ?? "0");
        const y0 = Number.parseFloat(element.getAttribute("y0") ?? "0");
        const x1 = Number.parseFloat(element.getAttribute("x1") ?? "0");
        const y1 = Number.parseFloat(element.getAttribute("y1") ?? "0");
        if (x0 === x1 && y0 === y1) {
          continue;
        }
        return {
          element,
          points: [
            [x0, y0],
            [x1, y1]
          ],
          shapeType: "polyline"
        };
      }
      case "polygon":
      case "polyline": {
        const points = element.getAttribute("points")?.split(" ").map((ps) => ps.split(",").map(Number.parseFloat)) ?? [];
        if (!points.length) {
          continue;
        }
        let shapeType = "polyline";
        if (element.tagName.toLowerCase() === "polygon") {
          points.push(points[0]);
          shapeType = "polygon";
        }
        return { element, points, shapeType };
      }
      case "rect": {
        const x = Number.parseFloat(element.getAttribute("x") ?? "0");
        const y = Number.parseFloat(element.getAttribute("y") ?? "0");
        const width = Number.parseFloat(element.getAttribute("width") ?? "0");
        const height = Number.parseFloat(element.getAttribute("height") ?? "0");
        if (!width || !height) {
          continue;
        }
        return {
          element,
          points: [
            [x, y],
            [x + width, y],
            [x + width, y + height],
            [x, y + height],
            [x, y]
          ],
          shapeType: "rect"
        };
      }
      default:
        continue;
    }
  }
  return null;
}
function pathToPoints(normalizedPath) {
  const out = [];
  for (let i = 0; i < normalizedPath.length; i++) {
    const startPoint = out[out.length - 1] ?? [0, 0];
    const seg = normalizedPath[i];
    switch (seg[0]) {
      case "M":
      case "L":
        out.push([seg[1], seg[2]]);
        continue;
      case "C":
        out.push(
          ...flattenCubicBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] },
            { x: seg[5], y: seg[6] }
          ).map((p) => [p.x, p.y]).slice(1)
          // skip first point, already part of output
        );
        continue;
      case "Q":
        out.push(
          ...flattenQuadraticBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] }
          ).map((p) => [p.x, p.y]).slice(1)
          // skip first point, already part of output
        );
        continue;
    }
  }
  return out;
}
function extractStyles(selectorElement) {
  const style = {};
  if (selectorElement.hasAttribute("fill")) {
    style.fill = selectorElement.getAttribute("fill");
    selectorElement.removeAttribute("fill");
  } else if (selectorElement.style && selectorElement.style.fill) {
    style.fill = selectorElement.style.fill;
  }
  if (style.fill) {
    const rgbaMatch = RGBA_COLOR.exec(style.fill);
    if (rgbaMatch) {
      style.fillOpacity = Number.parseFloat(rgbaMatch[4]);
      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("fill-opacity")) {
    style.fillOpacity = Number.parseFloat(selectorElement.getAttribute("fill-opacity"));
    selectorElement.removeAttribute("fill-opacity");
  } else if (selectorElement.style && selectorElement.style.fillOpacity) {
    style.fillOpacity = Number.parseFloat(selectorElement.style.fillOpacity);
  }
  if (selectorElement.hasAttribute("stroke")) {
    style.stroke = selectorElement.getAttribute("stroke");
    selectorElement.removeAttribute("stroke");
  } else if (selectorElement.style && selectorElement.style.stroke) {
    style.stroke = selectorElement.style.stroke;
  }
  if (style.stroke) {
    const rgbaMatch = RGBA_COLOR.exec(style.stroke);
    if (rgbaMatch) {
      style.strokeOpacity = Number.parseFloat(rgbaMatch[4]);
      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("stroke-opacity")) {
    style.strokeOpacity = Number.parseFloat(selectorElement.getAttribute("stroke-opacity"));
    selectorElement.removeAttribute("stroke-opacity");
  } else if (selectorElement.style && selectorElement.style.strokeOpacity) {
    style.strokeOpacity = Number.parseFloat(selectorElement.style.strokeOpacity);
  }
  if (selectorElement.hasAttribute("stroke-width")) {
    style.strokeWidth = selectorElement.getAttribute("stroke-width");
    selectorElement.removeAttribute("stroke-width");
  } else if (selectorElement.style && selectorElement.style.strokeWidth) {
    style.strokeWidth = selectorElement.style.strokeWidth;
  }
  if (selectorElement.hasAttribute("stroke-dasharray")) {
    style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
    selectorElement.removeAttribute("stroke-dasharray");
  } else if (selectorElement.style && selectorElement.style.strokeDasharray) {
    style.strokeDasharray = selectorElement.style.strokeDasharray;
  }
  let rootElem = selectorElement;
  while (rootElem.tagName.toLowerCase() !== "svg") {
    rootElem = rootElem.parentElement;
    if (rootElem === null) {
      throw new Error("Could not find root SVG element");
    }
  }
  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
}
function isImageApiSelector(t) {
  if (!t)
    return false;
  const type = t.type || t["@type"];
  return type === "iiif:ImageApiSelector" || type === "ImageApiSelector";
}
function resolveHints(supported) {
  if (supported.iiifRenderingHints) {
    const source = supported.iiifRenderingHints;
    if (source.rotation) {
      const parsedRotation = parseRotation(`${source.rotation}`);
      if (parsedRotation) {
        if (supported.selectors.length) {
          for (const selector of supported.selectors) {
            selector.rotation = parsedRotation;
          }
        } else {
          supported.selectors.push({
            type: "RotationSelector",
            rotation: parsedRotation
          });
        }
      }
    }
  } else {
    delete supported.iiifRenderingHints;
  }
  return supported;
}
function parseRotation(input) {
  let num = Number.parseFloat(input);
  if (num && input.startsWith("!")) {
    num = 360 - num;
  }
  if (num) {
    num = num % 360;
  }
  if (num !== num) {
    return 0;
  }
  return num || 0;
}

// src/annotation-targets/expand-target.ts
function expandTarget(target, options = {}) {
  if (Array.isArray(target)) {
    return expandTarget(target[0]);
  }
  if (typeof target === "string") {
    const [id, fragment] = target.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: { id, type: "Unknown" },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
    return expandTarget(target.items[0]);
  }
  if (!target.type && "source" in target) {
    target.type = "SpecificResource";
  }
  if (target.type === "SpecificResource") {
    if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
      target.source.partOf = [
        {
          id: target.source.partOf,
          type: "Manifest"
        }
      ];
    }
    const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
    return {
      type: "SpecificResource",
      source: target.source,
      selector,
      selectors
    };
  }
  if (target.id) {
    if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
      target.partOf = [
        {
          id: target.partOf,
          type: "Manifest"
        }
      ];
    }
    const [id, fragment] = target.id.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: {
        ...target,
        id
      },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  return {
    type: "SpecificResource",
    source: target,
    selector: null,
    selectors: []
  };
}

// src/content-state.ts
function validateContentState(annotation, strict = false) {
  if (typeof annotation === "string") {
    if (annotation.startsWith("{")) {
      try {
        const parsed = JSON.parse(annotation);
        return validateContentState(parsed);
      } catch (err) {
        return [false, { reason: "Invalid JSON" }];
      }
    }
    return [true];
  }
  if (Array.isArray(annotation)) {
    for (const anno of annotation) {
      const [valid, reason] = validateContentState(anno);
      if (!valid && reason) {
        return [valid, reason];
      }
    }
    return [true];
  }
  if (annotation.type === "Annotation") {
    return [true];
  }
  if (strict && annotation.type === "Canvas" && !annotation.partOf) {
    return [false, { reason: "Canvas without partOf cannot be loaded" }];
  }
  return [true];
}
function serialiseContentState(annotation) {
  return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
}
function parseContentState(state, asyncOrFetcher) {
  state = state.trim();
  if (state[0] === "{") {
    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
  }
  if (state.startsWith("http")) {
    if (!asyncOrFetcher) {
      throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
    }
    return fetch(state).then((r) => r.json());
  }
  return parseContentState(decodeContentState(state), asyncOrFetcher);
}
function encodeContentState(state) {
  const uriEncoded = encodeURIComponent(state);
  const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
  const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
  return base64url.replace(/=/g, "");
}
function decodeContentState(encodedContentState) {
  const base64url = restorePadding(encodedContentState);
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
  return decodeURIComponent(base64Decoded).trim();
}
function restorePadding(s) {
  const pad = s.length % 4;
  if (pad === 1) {
    throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
  }
  return s + (pad ? "====".slice(0, 4 - pad) : "");
}
function normaliseContentState(state) {
  if (!state) {
    throw new Error("Content state is empty");
  }
  if (!Array.isArray(state)) {
    state = [state];
  }
  let annoId = "vault://virtual-annotation/" + (/* @__PURE__ */ new Date()).getTime();
  const motivation = ["contentState"];
  const targets = [];
  for (const source of state) {
    if (typeof source === "string") {
      throw new Error("Content state is a [String] type and cannot be inferred");
    }
    if (source.type === "Annotation") {
      annoId = source.id;
      if (Array.isArray(source.motivation)) {
        for (const singleMotivation of source.motivation) {
          if (motivation.indexOf(singleMotivation) === -1) {
            motivation.push(singleMotivation);
          }
        }
      }
      if (Array.isArray(source.target)) {
        for (const target2 of source.target) {
          const expanded = expandTarget(target2);
          targets.push(expanded);
        }
      } else {
        const expanded = expandTarget(source.target);
        targets.push(expanded);
      }
      continue;
    }
    const target = expandTarget(source);
    targets.push(target);
  }
  return {
    id: annoId,
    type: "Annotation",
    motivation: ["contentState", ...state.motivation || []],
    target: targets,
    extensions: {}
  };
}

// src/painting-annotations/parse-specific-resource.ts
function parseSpecificResource(resource) {
  if (resource.type === "SpecificResource") {
    return [resource.source, { selector: resource.selector }];
  }
  return [resource, { selector: null }];
}

// src/painting-annotations/helper.ts
function createPaintingAnnotationsHelper(vault = compatVault) {
  function getAllPaintingAnnotations(canvasOrId) {
    const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
    if (!canvas) {
      return [];
    }
    const annotationPages = vault.get(canvas.items, { parent: canvas });
    const flatAnnotations = [];
    for (const page of annotationPages) {
      flatAnnotations.push(...vault.get(page.items, { parent: page }));
    }
    return flatAnnotations;
  }
  function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
    const types = [];
    let choices = {
      items: [],
      type: "complex-choice"
    };
    const items = [];
    for (const annotation of paintingAnnotations) {
      if (annotation.type !== "Annotation") {
        throw new Error(`getPaintables() accept either a canvas or list of annotations`);
      }
      const references = Array.from(Array.isArray(annotation.body) ? annotation.body : [annotation.body]);
      for (const reference of references) {
        const [ref, { selector }] = parseSpecificResource(reference);
        const body = vault.get(ref);
        const type = (body.type || "unknown").toLowerCase();
        if (type === "choice") {
          const nestedBodies = vault.get(body.items, { parent: body.id });
          const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b) => b.id === cid)).filter(Boolean) : [nestedBodies[0]];
          if (selected.length === 0) {
            selected.push(nestedBodies[0]);
          }
          choices.items.push({
            type: "single-choice",
            items: nestedBodies.map((b) => ({
              id: b.id,
              label: b.label,
              selected: selected.indexOf(b) !== -1
            })),
            label: ref.label
          });
          references.push(...selected);
          continue;
        }
        if (types.indexOf(type) === -1) {
          types.push(type);
        }
        items.push({
          type,
          annotationId: annotation.id,
          annotation,
          resource: body,
          target: annotation.target,
          selector
        });
      }
    }
    return {
      types,
      items,
      choice: choices.items.length < 2 ? choices.items[0] || null : choices,
      allChoices: choices.items.length ? choices : null
    };
  }
  function extractChoices(paintingAnnotationsOrCanvas) {
    const { choice } = getPaintables(paintingAnnotationsOrCanvas);
    return choice;
  }
  return {
    getAllPaintingAnnotations,
    getPaintables,
    extractChoices
  };
}

// src/ranges.ts
var import_parser2 = require("@iiif/parser");

// src/shared-utilities.ts
function hash(object) {
  const text = JSON.stringify(object);
  let numHash = 5381, index = text.length;
  while (index) {
    numHash = numHash * 33 ^ text.charCodeAt(--index);
  }
  const num = numHash >>> 0;
  const hexString = num.toString(16);
  if (hexString.length % 2) {
    return "0" + hexString;
  }
  return hexString;
}

// src/ranges.ts
function createRangeHelper(vault = compatVault) {
  return {
    findFirstCanvasFromRange: (range) => findFirstCanvasFromRange(vault, range),
    findAllCanvasesInRange: (range) => findAllCanvasesInRange(vault, range),
    findManifestSelectedRange: (manifest, canvasId) => findManifestSelectedRange(vault, manifest, canvasId),
    findSelectedRange: (range, canvasId) => findSelectedRange(vault, range, canvasId),
    rangesToTableOfContentsTree: (rangeRefs, label) => rangesToTableOfContentsTree(vault, rangeRefs, label),
    rangeToTableOfContentsTree: (rangeRef) => rangeToTableOfContentsTree(vault, rangeRef)
  };
}
function findFirstCanvasFromRange(vault, range) {
  for (const inner of range.items) {
    if (typeof inner === "string") {
      return { id: inner, type: "Canvas" };
    }
    if (inner.type === "Canvas") {
      return inner;
    }
    if (inner.type === "SpecificResource") {
      if (inner.source?.type === "Canvas") {
        return inner.source;
      }
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRange(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findFirstCanvasFromRangeWithSelector(vault, range) {
  for (const inner of range.items) {
    if (typeof inner === "string") {
      return { type: "SpecificResource", source: { id: inner, type: "Canvas" } };
    }
    if (inner.type === "Canvas") {
      return { type: "SpecificResource", source: inner };
    }
    if (inner.type === "SpecificResource") {
      if (inner.source?.type === "Canvas") {
        return inner;
      }
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRangeWithSelector(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findAllCanvasesInRange(vault, range) {
  const found = [];
  for (const inner of range.items) {
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
      if (inner.source.id.indexOf("#") !== -1) {
        found.push({ id: inner.source.id.split("#")[0], type: "Canvas" });
      } else {
        found.push(inner.source);
      }
    }
    if (inner.type === "Range") {
      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
    }
    if (inner.type === "SpecificResource") {
      const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
      found.push({ id: sourceId, type: "Canvas" });
    }
  }
  return found;
}
function findManifestSelectedRange(vault, manifest, canvasId) {
  for (const range of manifest.structures) {
    const found = findSelectedRange(vault, vault.get(range), canvasId);
    if (found) {
      return found;
    }
  }
  return null;
}
function findSelectedRange(vault, range, canvasId) {
  for (const inner of range.items) {
    const parsedId = inner?.source?.id?.split("#")[0];
    if (inner.type === "SpecificResource" && inner.source === canvasId) {
      return range;
    }
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas" && canvasId === parsedId) {
      return range;
    }
    if (inner.type === "Range") {
      const found = findSelectedRange(vault, vault.get(inner), canvasId);
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function rangesToTableOfContentsTree(vault, rangeRefs, label) {
  if (rangeRefs.length === 0) {
    return null;
  }
  const ranges = vault.get(rangeRefs);
  if (ranges.length === 1) {
    return rangeToTableOfContentsTree(vault, ranges[0]);
  }
  const virtualRoot = {
    id: `vault://virtual-root/${hash(ranges)}`,
    type: "Range",
    label: label || { en: ["Table of Contents"] },
    items: ranges
  };
  return rangeToTableOfContentsTree(vault, virtualRoot);
}
function rangeToTableOfContentsTree(vault, rangeRef, seenIds = []) {
  if (!rangeRef)
    return null;
  const range = vault.get(rangeRef, { skipSelfReturn: false });
  const toc = {
    id: range.id,
    type: "Range",
    label: range.label,
    untitled: !range.label,
    isCanvasLeaf: false,
    isRangeLeaf: false,
    items: []
  };
  if (seenIds.indexOf(toc.id) !== -1) {
    toc.id = `vault://${hash(range)}`;
  }
  if (!range.items) {
    return toc;
  }
  if (range.behavior && range.behavior.includes("no-nav")) {
    return null;
  }
  for (const inner of range.items) {
    if (typeof inner === "string") {
      const maybeCanvas = vault.get({ id: inner, type: "Canvas" }, { skipSelfReturn: false });
      const foundCanvas = {
        id: inner,
        type: "Canvas",
        isCanvasLeaf: true,
        isRangeLeaf: false,
        label: maybeCanvas.label || { none: ["Untitled"] },
        untitled: !maybeCanvas.label,
        resource: {
          type: "SpecificResource",
          source: { id: inner, type: "Canvas" }
        }
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      continue;
    }
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
      const maybeCanvas = vault.get(inner.source);
      const compressed = (0, import_parser2.compressSpecificResource)(inner);
      if (!maybeCanvas) {
        continue;
      }
      const foundCanvas = {
        id: compressed.type === "Canvas" ? compressed.id : inner.source.id,
        type: "Canvas",
        isCanvasLeaf: true,
        isRangeLeaf: false,
        label: maybeCanvas.label || { none: ["Untitled"] },
        untitled: !maybeCanvas.label,
        resource: inner
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      toc.items.push(foundCanvas);
      continue;
    }
    if (inner.type === "Canvas") {
      const foundCanvas = {
        id: inner.id,
        type: "Canvas",
        label: inner.label,
        isCanvasLeaf: true,
        isRangeLeaf: false,
        resource: {
          type: "SpecificResource",
          source: inner
        }
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      continue;
    }
    if (inner.type === "Range") {
      const foundRange = rangeToTableOfContentsTree(vault, inner, seenIds);
      if (foundRange) {
        toc.items.push(foundRange);
      }
      continue;
    }
  }
  toc.firstCanvas = findFirstCanvasFromRangeWithSelector(vault, range);
  toc.isRangeLeaf = toc.items ? toc.items.filter((i) => i.type === "Range").length === 0 : true;
  return toc;
}

// src/sequences.ts
function createSequenceHelper(vault = compatVault) {
  return {
    getVisibleCanvasesFromCanvasId: (manifestOrRange, canvasId, preventPaged = false) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),
    getManifestSequence: (manifestOrRange, options = {}) => getManifestSequence(vault, manifestOrRange, options)
  };
}
function getVisibleCanvasesFromCanvasId(vault = compatVault, manifestOrRange, canvasId, preventPaged = false) {
  const behavior = manifestOrRange.behavior || [];
  const fullCanvas = canvasId ? vault.get(canvasId) : null;
  if (!fullCanvas) {
    return [];
  }
  const canvasBehavior = fullCanvas.behavior || [];
  const isPaged = preventPaged ? false : behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const isCanvasFacingPages = canvasBehavior.includes("facing-pages");
  const isCanvasNonPaged = canvasBehavior.includes("non-paged");
  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {
    return [{ id: fullCanvas.id, type: "Canvas" }];
  }
  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);
  if (isContinuous) {
    return manifestItems;
  }
  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);
  if (canvasIndex === -1) {
    return [];
  }
  for (const indexes of ordering) {
    if (indexes.includes(canvasIndex)) {
      return indexes.map((index) => manifestItems[index]);
    }
  }
  return [{ id: fullCanvas.id, type: "Canvas" }];
}
function getManifestSequence(vault = compatVault, manifestOrRange, { disablePaging, skipNonPaged } = {}) {
  const behavior = manifestOrRange.behavior || [];
  const isPaged = behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const manifestItems = manifestOrRange.type === "Manifest" ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);
  if (isContinuous) {
    return [manifestItems, [manifestItems.map((_, index) => index)]];
  }
  if (isIndividuals || !isPaged || disablePaging) {
    return [manifestItems, manifestItems.map((_, index) => [index])];
  }
  const ordering = [];
  let currentOrdering = [];
  const flush = () => {
    if (currentOrdering.length) {
      ordering.push([...currentOrdering]);
      currentOrdering = [];
    }
  };
  let offset = 0;
  let flushNextPaged = false;
  for (let i = 0; i < manifestItems.length; i++) {
    const canvas = vault.get(manifestItems[i]);
    const canvasBehavior = canvas.behavior || [];
    if (canvasBehavior.includes("non-paged")) {
      if (i === offset) {
        offset++;
      }
      if (!skipNonPaged) {
        flush();
        ordering.push([i]);
        flush();
      }
      continue;
    }
    if (i === offset || canvasBehavior.includes("facing-pages")) {
      if (currentOrdering.length) {
        flushNextPaged = true;
      }
      flush();
      ordering.push([i]);
      flush();
      continue;
    }
    currentOrdering.push(i);
    if (flushNextPaged) {
      flush();
      flushNextPaged = false;
      continue;
    }
    if (currentOrdering.length > 1) {
      flush();
    }
  }
  if (currentOrdering.length) {
    flush();
  }
  return [manifestItems, ordering];
}

// src/vault/vault.ts
var import_parser5 = require("@iiif/parser");

// src/vault/utility/typesafe-actions-runtime.ts
var createAction = function createAction2(type) {
  return function() {
    const base = { type, getType: () => type, toString: () => type };
    return (payload2, meta) => ({
      ...base,
      ...payload2 !== void 0 && { payload: payload2 },
      ...meta !== void 0 && { meta }
    });
  };
};

// src/vault/actions/entity-actions.ts
var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
var UPDATE_REFERENCE = "@iiif/UPDATE_REFERENCE";
var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
var ADD_METADATA = "@iiif/ADD_METADATA";
var REMOVE_METADATA = "@iiif/REMOVE_METADATA";
var UPDATE_METADATA = "@iiif/UPDATE_METADATA";
var REORDER_METADATA = "@iiif/REORDER_METADATA";
var importEntities = createAction(IMPORT_ENTITIES)();
var modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
var reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
var addReference = createAction(ADD_REFERENCE)();
var removeReference = createAction(REMOVE_REFERENCE)();
var updateReference = createAction(UPDATE_REFERENCE)();
var addMetadata = createAction(ADD_METADATA)();
var updateMetadata = createAction(UPDATE_METADATA)();
var removeMetadata = createAction(REMOVE_METADATA)();
var reorderMetadata = createAction(REORDER_METADATA)();
var entityActions = {
  importEntities,
  modifyEntityField,
  reorderEntityField,
  addReference,
  removeReference,
  updateReference,
  addMetadata,
  removeMetadata,
  updateMetadata,
  reorderMetadata
};

// src/vault/actions/mapping-actions.ts
var ADD_MAPPING = "@iiif/ADD_MAPPING";
var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
var addMapping = createAction(ADD_MAPPING)();
var addMappings = createAction(ADD_MAPPINGS)();

// src/vault/actions/meta-actions.ts
var SET_META_VALUE = "@iiif/SET_META_VALUE";
var SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
var UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
var setMetaValue = createAction(SET_META_VALUE)();
var setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)();
var unsetMetaValue = createAction(UNSET_META_VALUE)();
var metaActions = {
  setMetaValue,
  setMetaValueDynamic,
  unsetMetaValue
};

// src/vault/actions/request-actions.ts
var RESOURCE_ERROR = "RESOURCE_ERROR";
var RESOURCE_LOADING = "RESOURCE_LOADING";
var RESOURCE_READY = "RESOURCE_READY";
var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
var requestResource = createAction(REQUEST_RESOURCE)();
var requestError = createAction(REQUEST_ERROR)();
var requestMismatch = createAction(REQUEST_MISMATCH)();
var requestComplete = createAction(REQUEST_COMPLETE)();
var requestOfflineResource = createAction(REQUEST_OFFLINE_RESOURCE)();

// src/vault/actions/batch-actions.ts
var BATCH_ACTIONS = "@iiif/BATCH";
var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
var batchActions = createAction(BATCH_ACTIONS)();
var batchImport = createAction(BATCH_IMPORT)();

// src/vault/utility/action-list-from-resource.ts
var import_parser3 = require("@iiif/parser");
var actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = (0, import_parser3.normalize)(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

// src/vault/utility/are-inputs-equal.ts
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

// src/vault/utility/resolve-if-exists.ts
var import_parser4 = require("@iiif/parser");
function resolveIfExists(state, url, parent) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  const fullEntity = state.iiif.entities[resourceType][request.resourceUri];
  if (fullEntity && fullEntity[import_parser4.HAS_PART]) {
    const framing = fullEntity[import_parser4.HAS_PART].find((t) => {
      return parent ? t[import_parser4.PART_OF] === parent.id : t[import_parser4.PART_OF] === fullEntity.id;
    });
    return (0, import_parser4.frameResource)(fullEntity, framing);
  }
  return fullEntity;
}

// src/vault/utility/is-promise.ts
function isPromise(value) {
  return value && typeof value.then === "function";
}

// src/vault/utility/create-fetch-helper.ts
function createFetchHelper(vault, fetcher, { waitTimeout = 30 } = {}) {
  return (url, options, mapper) => {
    const store = vault.getStore();
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      if (request.loadingState === RESOURCE_READY) {
        const resolvedEntity = resolveIfExists(state, url);
        if (resolvedEntity) {
          return resolvedEntity;
        }
      }
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          return (async () => {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise(
                  (resolve, reject) => setTimeout(
                    () => {
                      didContinue = true;
                      reject();
                    },
                    waitTimeout * 60 * 1e3
                  )
                )
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
            }
          })();
        }
      }
    }
    vault.dispatch(requestResource({ id: url }));
    const importResource = (resource) => {
      if (!resource) {
        return void 0;
      }
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      vault.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    };
    try {
      const resourceOrPromise = fetcher(url, options);
      if (isPromise(resourceOrPromise)) {
        return (async () => {
          try {
            let data = await resourceOrPromise;
            if (mapper) {
              data = mapper(data);
            }
            return importResource(data);
          } catch (err) {
            vault.dispatch(requestError({ id: url, message: err.toString() }));
            throw err;
          }
        })();
      }
      return importResource(mapper ? mapper(resourceOrPromise) : resourceOrPromise);
    } catch (err) {
      vault.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

// src/vault/utility/get-default-entities.ts
function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/middleware.mjs
var import_meta2 = {};
var reduxImpl = (reducer, initial) => (set, _get, api) => {
  api.dispatch = (action) => {
    set((state) => reducer(state, action), false, action);
    return action;
  };
  api.dispatchFromDevtools = true;
  return { dispatch: (...a) => api.dispatch(...a), ...initial };
};
var redux = reduxImpl;
var trackedConnections = /* @__PURE__ */ new Map();
var getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api)
    return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
var extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
var devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording)
      return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState)
              return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
var devtools = devtoolsImpl;
var parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0)
    f(parsed);
};
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;

// src/vault/store/reducers/mapping-reducer.ts
var mappingReducer = (state = {}, action) => {
  switch (action.type) {
    case ADD_MAPPING:
      return {
        ...state,
        [action.payload.id]: action.payload.type
      };
    case ADD_MAPPINGS:
      return {
        ...state,
        ...action.payload.mapping
      };
    default:
      return state;
  }
};

// src/vault/utility/is-reference-list.ts
function isReferenceList(state, id, type, key) {
  return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
}

// src/vault/utility/quick-merge.ts
function quickMerge(a, b) {
  const newResource = {};
  const added = [];
  for (const [key, value] of Object.entries(a || {})) {
    added.push(key);
    const bValue = (b || {})[key];
    if (!bValue || bValue.length === 0) {
      newResource[key] = value;
      continue;
    }
    newResource[key] = bValue;
  }
  for (const [key, value] of Object.entries(b || {})) {
    if (added.indexOf(key) !== -1) {
      continue;
    }
    newResource[key] = value;
  }
  return newResource;
}

// src/vault/store/reducers/entities-reducer.ts
function payload(action) {
  return action.payload;
}
function numberOr(a, b) {
  return typeof a === "undefined" ? b : a;
}
var entitiesReducer = (state = getDefaultEntities(), action) => {
  const updateField = (entity, values) => {
    return {
      ...state,
      [payload(action).type]: {
        ...state[payload(action).type],
        [payload(action).id]: {
          ...entity,
          ...values
        }
      }
    };
  };
  switch (action.type) {
    case MODIFY_ENTITY_FIELD: {
      if (!state[payload(action).type] || !state[payload(action).type][payload(action).id]) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      return updateField(entity, { [payload(action).key]: payload(action).value });
    }
    case REORDER_ENTITY_FIELD: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string") {
        return state;
      }
      const result = Array.from(entity[payload(action).key]);
      const [removed] = result.splice(payload(action).startIndex, 1);
      result.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { [payload(action).key]: result });
    }
    case IMPORT_ENTITIES: {
      const keys = Object.keys(payload(action).entities);
      const toReturn = { ...state };
      for (const key of keys) {
        const entities = payload(action).entities[key];
        const newEntities = { ...state[key] || {} };
        let changed = false;
        const ids = Object.keys(entities || {}) || [];
        if (entities && ids) {
          for (const id of ids) {
            changed = true;
            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
          }
          if (changed) {
            toReturn[key] = newEntities;
          }
        }
      }
      return toReturn;
    }
    case ADD_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      result.splice(numberOr(payload(action).index, result.length + 1), 0, payload(action).reference);
      return updateField(entity, { [payload(action).key]: result });
    }
    case UPDATE_REFERENCE:
    case REMOVE_REFERENCE: {
      if (!isReferenceList(state, payload(action).id, payload(action).type, payload(action).key)) {
        return state;
      }
      const entity = state[payload(action).type][payload(action).id];
      const result = Array.from(entity[payload(action).key]);
      const indexToRemove = numberOr(
        payload(action).index,
        result.findIndex((e) => e && e.id === payload(action).reference.id)
      );
      if (indexToRemove === -1 || result[indexToRemove]?.id !== payload(action).reference.id) {
        return state;
      }
      if (action.type === UPDATE_REFERENCE) {
        result.splice(indexToRemove, 1, payload(action).reference);
      } else {
        result.splice(indexToRemove, 1);
      }
      return updateField(entity, { [payload(action).key]: result });
    }
    case ADD_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (!entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const actionPayload = payload(action);
      metadata.splice(numberOr(action.payload.beforeIndex, metadata.length + 1), 0, {
        label: actionPayload.label,
        value: actionPayload.label
      });
      return updateField(entity, { metadata });
    }
    case REORDER_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      if (typeof entity === "string" || !entity) {
        return state;
      }
      const metadata = Array.from(entity.metadata || []);
      const [removed] = metadata.splice(payload(action).startIndex, 1);
      metadata.splice(payload(action).endIndex, 0, removed);
      return updateField(entity, { metadata });
    }
    case UPDATE_METADATA:
    case REMOVE_METADATA: {
      const entity = state[payload(action).type][payload(action).id];
      const metadata = Array.from(entity.metadata || []);
      const indexToRemove = payload(action).atIndex;
      if (typeof indexToRemove === "undefined" || indexToRemove === -1 || !metadata[indexToRemove]) {
        return state;
      }
      if (action.type === UPDATE_METADATA) {
        metadata.splice(indexToRemove, 1, { label: payload(action).label, value: payload(action).value });
      } else {
        metadata.splice(indexToRemove, 1);
      }
      return updateField(entity, { metadata });
    }
    default:
      return state;
  }
};

// src/vault/store/reducers/request-reducer.ts
var requestReducer = (state = {}, action) => {
  switch (action.type) {
    case REQUEST_RESOURCE:
    case REQUEST_OFFLINE_RESOURCE:
      return {
        ...state,
        [action.payload.id]: {
          requestUri: action.payload.id,
          loadingState: RESOURCE_LOADING,
          uriMismatch: false,
          resourceUri: action.payload.id
        }
      };
    case REQUEST_MISMATCH:
      return {
        ...state,
        [action.payload.requestId]: {
          ...state[action.payload.requestId] || {},
          uriMismatch: true,
          resourceUri: action.payload.actualId
        },
        [action.payload.actualId]: {
          requestUri: action.payload.requestId,
          loadingState: state[action.payload.requestId].loadingState,
          uriMismatch: true,
          resourceUri: action.payload.actualId
        }
      };
    case REQUEST_ERROR:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_ERROR,
          error: action.payload.message
        }
      };
    case REQUEST_COMPLETE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_READY,
          error: void 0
        }
      };
  }
  return state;
};

// src/vault/store/reducers/meta-reducer.ts
var metaReducer = (state = {}, action) => {
  const { id, updateValue, value, meta, key } = action && action.payload || {};
  switch (action.type) {
    case SET_META_VALUE: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: value
          }
        }
      };
    }
    case SET_META_VALUE_DYNAMIC: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
          }
        }
      };
    }
    case UNSET_META_VALUE: {
      if (state[id] && state[id][meta] && state[id][meta][key]) {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: void 0
            }
          }
        };
      }
      return state;
    }
    default:
      return state;
  }
};

// src/vault/utility/combine-reducers.ts
function combineReducers(reducers2 = {}) {
  const reducerKeys = Object.keys(reducers2);
  return function combination(state = {}, action) {
    let hasChanged = false;
    const nextState = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      nextState[key] = reducers2[key](state[key], action);
      hasChanged = hasChanged || nextState[key] !== state[key];
    }
    return hasChanged ? nextState : state;
  };
}

// src/vault/store/reducers/batch-reducer.ts
function createBatchReducer(rootReducer) {
  return (state, action) => {
    if (action && action.type === BATCH_ACTIONS) {
      return action.payload.actions.reduce(rootReducer, state);
    }
    if (action && action.type === BATCH_IMPORT) {
      return {
        ...state,
        iiif: {
          ...state.iiif,
          ...action.payload.state
        }
      };
    }
    return rootReducer(state, action);
  };
}

// src/vault/store/index.ts
var reducers = combineReducers({
  mapping: mappingReducer,
  entities: entitiesReducer,
  requests: requestReducer,
  meta: metaReducer
});
function getDefaultState() {
  return {
    iiif: {
      entities: getDefaultEntities(),
      meta: {},
      mapping: {},
      requests: {}
    }
  };
}
function createStore2(options = {}) {
  const {
    enableDevtools = false,
    iiifStoreName = "iiif",
    defaultState = getDefaultState(),
    customReducers = {}
  } = options;
  const rootReducer = createBatchReducer(combineReducers({ [iiifStoreName]: reducers, ...customReducers }));
  const enabled = Boolean(typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__);
  const dv = !enabled || false ? (a, r) => a : devtools;
  return createStore(
    //
    subscribeWithSelector(
      //
      dv(
        //
        redux(rootReducer, defaultState),
        { enabled: enableDevtools }
      )
    )
  );
}

// src/vault/utility/objects.ts
function defineProperty(name, prototype, vault, enumerable = true) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  const cache = /* @__PURE__ */ new Map();
  Object.defineProperty(prototype, name, {
    enumerable,
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      const object = vault.get(prototype[REFS][name], {
        parent: this.id ? { id: this.id, type: this.type } : void 0
      });
      if (!cache.has(object)) {
        cache.clear();
        cache.set(object, wrapObject(object, vault));
      }
      return cache.get(object);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        if (this[REACTIVE]) {
          vault.modifyEntityField({ id: this.id, type: this.type }, name, unwrapObject(items));
        } else {
          this[REFS][name] = items;
        }
      }
    }
  });
}
var REFS = Symbol.for("_refs_");
var REACTIVE = Symbol.for("_reactive_");
var DEFINED = Symbol.for("_defined_");
var PARENT = Symbol.for("_parent_");
function createPrototype(vault, reactive = false, parent) {
  const prototype = {
    id: "",
    type: "unknown",
    [DEFINED]: [],
    [REFS]: {},
    [PARENT]: parent || null,
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      const parent2 = this[PARENT];
      return vault.get(this.id, { parent: parent2 ? { id: parent2, type: "unknown" } : void 0 });
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    valueOf() {
      return this.unwrap();
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault, false);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault, false);
  defineProperty("accompanyingCanvas", prototype, vault, false);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function isWrapped(object) {
  return !!object[DEFINED];
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false, parent) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}

// src/vault/utility/resolve-type.ts
function resolveType(type) {
  switch (type) {
    case "Image":
    case "Video":
    case "Sound":
    case "Dataset":
    case "Text":
    case "Composite":
    case "List":
    case "Independents":
    case "Audience":
      return "ContentResource";
    case "ImageService1":
    case "ImageService2":
    case "ImageService3":
      return "Service";
  }
  return type;
}

// src/vault/vault.ts
var Vault = class {
  constructor(options, store) {
    __publicField(this, "options");
    __publicField(this, "store");
    __publicField(this, "emitter");
    __publicField(this, "isBatching", false);
    __publicField(this, "batchQueue", []);
    __publicField(this, "remoteFetcher");
    __publicField(this, "staticFetcher");
    __publicField(this, "defaultFetcher", (url) => {
      return fetch(url).then((r) => {
        if (r.status === 200) {
          return r.json();
        } else {
          const err = new Error(`${r.status} ${r.statusText}`);
          err.name = `HTTPError`;
          throw err;
        }
      });
    });
    this.options = Object.assign(
      {
        reducers: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      },
      options || {}
    );
    this.store = store || createStore2({
      customReducers: this.options.reducers,
      defaultState: this.options.defaultState,
      enableDevtools: this.options.enableDevtools
    });
    this.emitter = mitt_default();
    this.remoteFetcher = createFetchHelper(this, this.options.customFetcher);
    this.staticFetcher = createFetchHelper(this, (id, json) => json);
  }
  batch(cb) {
    this.isBatching = true;
    try {
      cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  async asyncBatch(cb) {
    this.isBatching = true;
    try {
      await cb(this);
      this.isBatching = false;
      this.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
  }
  modifyEntityField(entity, key, value) {
    this.dispatch(
      entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      })
    );
  }
  dispatch(action) {
    if (!this.isBatching) {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { action: realAction, state: this.store.getState() });
        }
        this.store.dispatch(action);
        const state2 = this.getState();
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${realAction.type}`, { action: realAction, state: state2 });
        }
        return;
      }
      this.emitter.emit(action.type, { action, state: this.store.getState() });
      this.store.dispatch(action);
      const state = this.store.getState();
      this.emitter.emit(`after:${action.type}`, { action, state });
      return;
    } else {
      this.batchQueue.push(action);
    }
  }
  on(event, handler) {
    this.emitter.on(event, handler);
    return () => {
      this.emitter.off(event, handler);
    };
  }
  serialize(entity, config) {
    return (0, import_parser5.serialize)(this.getState().iiif, entity, config);
  }
  toPresentation2(entity) {
    return this.serialize(entity, import_parser5.serializeConfigPresentation2);
  }
  toPresentation3(entity) {
    return this.serialize(entity, import_parser5.serializeConfigPresentation3);
  }
  hydrate(reference, type, options = {}) {
    return this.get(reference, type, { ...options, skipSelfReturn: false });
  }
  get(reference, type, options = {}) {
    if (typeof type !== "string") {
      options = type || {};
      type = void 0;
    }
    const { skipSelfReturn = true } = options || {};
    let parent = options.parent ? typeof options.parent === "string" ? options.parent : options.parent.id : void 0;
    if (Array.isArray(reference)) {
      return reference.map((i) => this.get(i, options));
    }
    const state = this.getState();
    if ((0, import_parser5.isSpecificResource)(reference) && !options.preserveSpecificResources) {
      reference = reference.source;
    }
    if (typeof reference === "string") {
      const _type2 = resolveType(type ? type : state.iiif.mapping[reference]);
      if (!_type2) {
        if (skipSelfReturn) {
          return null;
        }
        return { id: reference, type: "unknown" };
      }
      reference = { id: reference, type: _type2 };
    }
    if (reference && reference.partOf && !parent && !options.skipPartOfCheck) {
      const first = Array.isArray(reference.partOf) ? reference.partOf[0] : reference.partOf;
      if (first) {
        if (typeof first === "string") {
          parent = first;
        }
        if (typeof first.id === "string") {
          parent = first.id;
        }
      }
    }
    const _type = resolveType(type ? type : reference?.type);
    const _id = reference?.id;
    const entities = state.iiif.entities[_type];
    if (!entities) {
      const request = state.iiif.requests[_id];
      if (request && request.resourceUri !== _id) {
        return this.get(request.resourceUri, options);
      }
      if (skipSelfReturn) {
        return null;
      }
      return reference;
    }
    const found = entities[reference.id];
    if (found && found[import_parser5.HAS_PART]) {
      const framing = found[import_parser5.HAS_PART].find((t) => {
        return parent ? t[import_parser5.PART_OF] === parent : t[import_parser5.PART_OF] === found.id;
      });
      return (0, import_parser5.frameResource)(found, framing);
    }
    return entities[reference.id] || (skipSelfReturn ? null : reference);
  }
  select(selector) {
    return selector(this.getState());
  }
  getStore() {
    return this.store;
  }
  getState() {
    return this.store.getState();
  }
  deep(input, prev) {
    if (typeof input === "undefined") {
      return this.get(prev, { skipSelfReturn: false });
    }
    if (typeof input === "function") {
      try {
        const next = input(this.get(prev, { skipSelfReturn: false }));
        const fn2 = (newInput) => this.deep(newInput, next);
        fn2.size = Array.isArray(next) ? next.length : 1;
        return fn2;
      } catch (e) {
        const fn2 = (newInput) => this.deep(newInput, void 0);
        fn2.size = 0;
        return fn2;
      }
    }
    const fn = (newInput) => this.deep(newInput, input);
    fn.size = Array.isArray(input) ? input.length : 1;
    return fn;
  }
  loadManifest(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  loadCollection(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json, mapper);
  }
  load(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    if (json) {
      return Promise.resolve(this.staticFetcher(_id, json, mapper));
    }
    return Promise.resolve(this.remoteFetcher(_id, {}, mapper));
  }
  loadSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.staticFetcher(_id, json, mapper);
  }
  loadManifestSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  loadCollectionSync(id, json, mapper) {
    const _id = typeof id === "string" ? id : id.id;
    return this.loadSync(_id, json, mapper);
  }
  areInputsEqual(newInputs, lastInputs) {
    return areInputsEqual(newInputs, lastInputs);
  }
  subscribe(selector, subscription, skipInitial) {
    if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
      skipInitial = subscription;
      subscription = selector;
      selector = (a) => a;
    }
    return this.store.subscribe(selector, (s) => subscription(s, this), {
      equalityFn: areInputsEqual,
      fireImmediately: !skipInitial
    });
  }
  async ensureLoaded(_id) {
    const id = typeof _id === "string" ? _id : _id.id;
    if (!this.requestStatus(id)) {
      await this.load(id);
    }
  }
  requestStatus(id) {
    return this.select((state) => {
      return state.iiif.requests[id];
    });
  }
  // Pagination built on "meta".
  getPaginationState(resource) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return null;
    const existing = this.getResourceMeta(id, "@vault/pagination");
    if (existing?.state) {
      return existing.state;
    }
    const fullResource = this.get(resource);
    if (fullResource.first) {
      const initialState = {
        currentPage: null,
        currentPageIndex: null,
        isFetching: false,
        isFullyLoaded: false,
        next: fullResource.first,
        page: 1,
        pages: [],
        previous: null,
        totalItems: fullResource.total,
        currentLength: 0
      };
      this.setMetaValue([id, "@vault/pagination", "state"], initialState);
      return initialState;
    }
    return null;
  }
  async loadNextPage(resource, json) {
    const id = typeof resource === "string" ? resource : resource.id;
    if (!id)
      return [null, null];
    const state = this.getPaginationState(resource);
    if (!state || state.isFullyLoaded || !state.next) {
      return [null, null];
    }
    if (state.isFetching) {
      return [state, null];
    }
    const nextPage = typeof state.next === "string" ? state.next : state.next.id;
    const previousPage = state.currentPage;
    const newState = {
      ...state,
      isFetching: true
    };
    this.setMetaValue([id, "@vault/pagination", "state"], newState);
    let collectionPage;
    try {
      collectionPage = await this.loadCollection(nextPage, json, (mapped) => {
        const { id: id2, ["@id"]: _id, ...properties } = mapped || {};
        if (_id) {
          return { ["@id"]: nextPage, ...properties };
        }
        return { id: nextPage, ...properties };
      });
    } catch (err) {
      const errState = {
        ...state,
        isFetching: false,
        error: err
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    if (!collectionPage) {
      const errState = {
        ...state,
        isFetching: false,
        error: new Error("Collection not found")
      };
      this.setMetaValue([id, "@vault/pagination", "state"], errState);
      return [errState, null];
    }
    const fullCollection = this.get(id);
    const combinedItems = [
      ...fullCollection.items || [],
      ...collectionPage.items || []
    ].map((resource2) => ({
      id: resource2.id,
      type: resource2.type
    }));
    this.modifyEntityField({ id, type: "Collection" }, "items", combinedItems);
    const latestState = this.getPaginationState(resource);
    if (!latestState)
      throw new Error("Pagination state not found");
    const successState = {
      ...latestState,
      isFetching: false,
      error: null,
      currentPage: collectionPage.id,
      next: collectionPage.next?.id || null,
      currentPageIndex: latestState.pages.length,
      currentLength: combinedItems.length,
      pages: [
        ...latestState.pages,
        {
          id: collectionPage.id,
          type: "Collection",
          startIndex: fullCollection.items.length,
          pageLength: collectionPage.items.length,
          order: typeof latestState.currentPageIndex === "number" ? latestState.currentPageIndex + 1 : 0
        }
      ],
      isFullyLoaded: !collectionPage.next,
      previous: previousPage,
      page: latestState.pages.length + 1
    };
    this.setMetaValue([id, "@vault/pagination", "state"], successState);
    return [successState, collectionPage];
  }
  getResourceMeta(resource, metaKey) {
    const resourceMeta = this.getState().iiif.meta[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
  getObject(reference, type, options = {}) {
    const { reactive, ...otherOptions } = options;
    return wrapObject(this.get(reference, type, otherOptions), this, reactive);
  }
  async loadObject(id, json) {
    return wrapObject(await this.load(id, json), this);
  }
  async loadManifestObject(id, json) {
    return wrapObject(await this.loadManifest(id, json), this);
  }
  async loadCollectionObject(id, json) {
    return wrapObject(await this.loadCollection(id, json), this);
  }
  wrapObject(objectType) {
    return wrapObject(this.get(objectType, { skipSelfReturn: false }), this);
  }
  isWrapped(object) {
    return isWrapped(object);
  }
  setMetaValue([id, meta, key], newValueOrUpdate) {
    this.dispatch(
      typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      })
    );
  }
};

// src/vault/utility/get-global.ts
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return {};
}

// src/vault/global-vault.ts
function globalVault(options) {
  const g = getGlobal();
  try {
    const gv = g["IIIF_VAULT"];
    if (gv) {
      return gv;
    }
  } catch (e) {
  }
  const newVault = new Vault(options);
  try {
    g["IIIF_VAULT"] = newVault;
  } catch (e) {
  }
  return newVault;
}

// src/fetch.ts
var import_upgrader = require("@iiif/parser/upgrader");
function fetchAndUpgrade(input, init) {
  return fetch(input, init).then((resp) => resp.json()).then(import_upgrader.upgrade);
}

// src/search1.ts
var getId9 = (idOrAtId) => idOrAtId.id || idOrAtId["@id"];
function findSearch1Service(manifest) {
  if (!manifest || !manifest.service) {
    return null;
  }
  return manifest ? manifest.service.find(
    (service) => service.profile === "SearchService1" || service.profile === "http://iiif.io/api/search/1/search"
  ) : null;
}
function findAutocompleteService(service) {
  if (!service || !service.service)
    return;
  const services = Array.isArray(service.service) ? service.service : [service.service];
  return services.find(
    (s) => s.profile === "http://iiif.io/api/search/0/autocomplete" || s.profile === "http://iiif.io/api/search/1/autocomplete" || s.profile === "AutoCompleteService1"
  );
}
var createSearch1AutocompleteStore = (service, options) => {
  const fetcher = options?.fetcher || defaultFetcher;
  const autocomplete = service ? findAutocompleteService(service) : void 0;
  const autocompleteEndpoint = autocomplete ? getId9(autocomplete) : void 0;
  let abort = null;
  return createStore((set, get) => ({
    results: [],
    lastQuery: {},
    hasAutocomplete: !!autocomplete,
    endpoint: autocompleteEndpoint,
    loading: false,
    error: false,
    errorMessage: "",
    ignored: [],
    setSearchService(newService) {
      const autocomplete2 = findAutocompleteService(newService);
      if (autocomplete2) {
        set({
          endpoint: getId9(autocomplete2),
          hasAutocomplete: true,
          results: [],
          loading: false,
          lastQuery: null,
          error: false,
          errorMessage: ""
        });
      }
    },
    clearSearch() {
      set({ results: [], loading: false, lastQuery: null });
    },
    async search(query, options2 = {}) {
      const endpoint = get().endpoint;
      if (get().hasAutocomplete === false) {
        return;
      }
      if (abort && !abort.signal.aborted) {
        abort.abort();
      }
      abort = new AbortController();
      const params = new URLSearchParams();
      params.set("q", query);
      if (options2.motivation) {
        params.set("motivation", options2.motivation);
      }
      if (options2.date) {
        params.set("date", options2.date);
      }
      if (options2.user) {
        params.set("user", options2.user);
      }
      let shouldLoad = true;
      if ((!query || query.length < 3) && !options2.motivation && !options2.date && !options2.user) {
        shouldLoad = false;
      }
      set({
        loading: shouldLoad,
        lastQuery: {
          q: query,
          motivation: options2.motivation,
          date: options2.date,
          user: options2.user
        }
      });
      if (!shouldLoad) {
        return;
      }
      return fetcher(`${endpoint}?${params.toString()}`, {
        signal: abort.signal,
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          ...options2.headers || {}
        }
      }).then(async ([json, error]) => {
        if (abort?.signal.aborted) {
          return;
        }
        if (json) {
          set({
            loading: false,
            ignored: json.ignored || [],
            results: json.terms,
            error: false,
            errorMessage: ""
          });
        } else {
          set({ results: [], error: true, errorMessage: error || void 0 });
        }
      });
    }
  }));
};
function defaultFetcher(query, { signal, headers }) {
  return fetch(query, {
    signal,
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...headers || {}
    }
  }).then(async (response) => {
    if (response.ok) {
      return [await response.json(), null];
    }
    return [null, response.statusText];
  });
}
var createSearch1Store = (service, options) => {
  const fetcher = options?.fetcher || defaultFetcher;
  let searchService;
  if (typeof service === "string") {
    searchService = {
      "@context": "http://iiif.io/api/search/1/context.json",
      profile: "http://iiif.io/api/search/1/search",
      "@id": service,
      id: service,
      service: []
    };
  } else {
    searchService = service;
  }
  let abort = null;
  return createStore((set, get) => ({
    endpoint: searchService ? getId9(searchService) : void 0,
    service: searchService,
    resources: [],
    hits: [],
    lastQuery: {},
    loading: false,
    error: false,
    highlight: {
      results: null,
      hit: null
    },
    hitIndex: -1,
    hasSearch: !!searchService,
    hasAutocomplete: searchService ? !!findAutocompleteService(searchService) : false,
    errorMessage: "",
    async search(query, options2 = {}) {
      const endpoint = get().endpoint;
      if (!endpoint) {
        throw new Error("No search service found.");
      }
      if (abort && !abort.signal.aborted) {
        abort.abort();
      }
      abort = new AbortController();
      const params = new URLSearchParams();
      if (query.q) {
        params.set("q", query.q);
      }
      if (query.motivation) {
        params.set("motivation", query.motivation);
      }
      if (query.date) {
        params.set("date", query.date);
      }
      if (query.user) {
        params.set("user", query.user);
      }
      set({
        lastQuery: query,
        loading: true
      });
      const response = await fetcher(`${endpoint}?${params.toString()}`, {
        signal: abort.signal,
        headers: options2.headers
      }).then(([json, errorMessage]) => {
        if (abort?.signal.aborted) {
          return;
        }
        if (json) {
          set({
            resources: (json.resources || []).map((result) => {
              if (result.search && !result.url) {
                result.url = result.search;
              }
              return result;
            }),
            hits: json.hits || (json.resources || []).map((result) => {
              return {
                "@type": "search:Hit",
                after: "",
                annotations: [result["@id"]],
                before: "",
                match: result.resource.chars
              };
            }),
            error: false,
            errorMessage: "",
            loading: false
          });
        } else {
          set({
            loading: false,
            resources: [],
            error: true,
            errorMessage: errorMessage || void 0
          });
        }
      });
      return response;
    },
    setSearchService(newService) {
      set({
        service: newService,
        endpoint: newService ? getId9(newService) : void 0,
        hasSearch: !!newService,
        hasAutocomplete: newService ? !!findAutocompleteService(newService) : false,
        loading: false,
        resources: [],
        error: false,
        errorMessage: "",
        highlight: { results: null, hit: null }
      });
    },
    // Other actions?
    clearSearch() {
      set({ resources: [], error: false, errorMessage: "" });
    },
    highlightHit(index) {
      const state = get();
      const hit = state.hits[index];
      if (!hit) {
        return;
      }
      const results = state.resources.filter((r) => hit.annotations.includes(r["@id"]));
      set({ hitIndex: index, highlight: { results, hit } });
    },
    nextHit() {
      const state = get();
      const nextIndex = state.hitIndex + 1;
      if (nextIndex >= state.hits.length) {
        return;
      }
      state.highlightHit(nextIndex);
    },
    previousHit() {
      const state = get();
      const nextIndex = state.hitIndex - 1;
      if (nextIndex < 0) {
        return;
      }
      state.highlightHit(nextIndex);
    }
  }));
};

// src/nav-date.ts
function createDateNavigation(vault, manifestOrCollection, inputType) {
  const type = inputType || "century";
  const items = [];
  const centuries = [];
  const resource = vault.get(manifestOrCollection);
  if (!resource.items) {
    return items;
  }
  for (const item of resource.items) {
    if (item.navDate) {
      const d = new Date(item.navDate);
      const year = d.getFullYear();
      const month = d.getMonth();
      const day = d.getDate();
      const decade = Math.floor(year / 10) * 10;
      const century = Math.floor(year / 100) * 100;
      let centuryItem = centuries.find((i) => i.yearStart === century);
      if (!centuryItem) {
        centuryItem = {
          id: `${resource.id}/century/${century}`,
          label: { en: [`${century} - ${century + 99}`] },
          type: "century",
          yearStart: century,
          yearEnd: century + 99,
          count: 1,
          items: []
        };
        if (type === "century") {
          items.push(centuryItem);
        }
        centuries.push(centuryItem);
      } else {
        centuryItem.count++;
      }
      let decadeItem = centuryItem.items.find((i) => i.yearStart === decade);
      if (!decadeItem) {
        decadeItem = {
          id: `${resource.id}/decade/${decade}`,
          label: { en: [`${decade} - ${decade + 9}`] },
          type: "decade",
          yearStart: decade,
          yearEnd: decade + 9,
          count: 1,
          items: []
        };
        centuryItem.items.push(decadeItem);
        if (type === "decade") {
          items.push(decadeItem);
        }
      } else {
        decadeItem.count++;
      }
      let yearItem = decadeItem.items.find((i) => i.year === year);
      if (!yearItem) {
        yearItem = {
          id: `${resource.id}/year/${year}`,
          label: { en: [`${year}`] },
          type: "year",
          year,
          count: 1,
          items: []
        };
        decadeItem.items.push(yearItem);
        if (type === "year") {
          items.push(yearItem);
        }
      } else {
        yearItem.count++;
      }
      let monthItem = yearItem.items.find((i) => i.month === month);
      if (!monthItem) {
        monthItem = {
          id: `${resource.id}/month/${year}/${month + 1}`,
          // Month as string
          label: {
            en: [
              type === "month" ? `${d.toLocaleString("default", { month: "long" })} ${year}` : `${d.toLocaleString("default", { month: "long" })}`
            ]
          },
          type: "month",
          month,
          count: 1,
          items: []
        };
        yearItem.items.push(monthItem);
        if (type === "month") {
          items.push(monthItem);
        }
      } else {
        monthItem.count++;
      }
      let dayItem = monthItem.items.find((i) => i.day === day);
      if (!dayItem) {
        dayItem = {
          id: `${resource.id}/day/${year}/${month + 1}/${day}`,
          label: { en: [`${d.toDateString()}`] },
          type: "day",
          day,
          count: 1,
          items: []
        };
        monthItem.items.push(dayItem);
        if (type === "day") {
          items.push(dayItem);
        }
      } else {
        dayItem.count++;
      }
      dayItem.items.push({
        id: item.id,
        type: item.type,
        label: item.label || { en: [`${year}-${month + 1}-${day}`] },
        navDate: item.navDate
      });
    }
  }
  if (!inputType) {
    let autoItem = items;
    while (autoItem.length === 1) {
      autoItem = autoItem[0].items;
    }
    return autoItem;
  }
  return items;
}
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
