"use strict";
var IIIFHelpers = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/.pnpm/parse-svg-path@0.1.2/node_modules/parse-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = parse;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse(path) {
        var data = [];
        path.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type])
              throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js
  var require_abs_svg_path = __commonJS({
    "node_modules/.pnpm/abs-svg-path@0.1.1/node_modules/abs-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = absolutize;
      function absolutize(path) {
        var startX = 0;
        var startY = 0;
        var x = 0;
        var y = 0;
        return path.map(function(seg) {
          seg = seg.slice();
          var type = seg[0];
          var command = type.toUpperCase();
          if (type != command) {
            seg[0] = command;
            switch (type) {
              case "a":
                seg[6] += x;
                seg[7] += y;
                break;
              case "v":
                seg[1] += y;
                break;
              case "h":
                seg[1] += x;
                break;
              default:
                for (var i = 1; i < seg.length; ) {
                  seg[i++] += x;
                  seg[i++] += y;
                }
            }
          }
          switch (command) {
            case "Z":
              x = startX;
              y = startY;
              break;
            case "H":
              x = seg[1];
              break;
            case "V":
              y = seg[1];
              break;
            case "M":
              x = startX = seg[1];
              y = startY = seg[2];
              break;
            default:
              x = seg[seg.length - 2];
              y = seg[seg.length - 1];
          }
          return seg;
        });
      }
    }
  });

  // src/content-state.ts
  var content_state_exports = {};
  __export(content_state_exports, {
    decodeContentState: () => decodeContentState,
    encodeContentState: () => encodeContentState,
    normaliseContentState: () => normaliseContentState,
    parseContentState: () => parseContentState,
    serialiseContentState: () => serialiseContentState,
    validateContentState: () => validateContentState
  });

  // node_modules/.pnpm/svg-arc-to-cubic-bezier@3.2.0/node_modules/svg-arc-to-cubic-bezier/modules/index.js
  var _slicedToArray = /* @__PURE__ */ function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  var TAU = Math.PI * 2;
  var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
    var x = _ref.x, y = _ref.y;
    x *= rx;
    y *= ry;
    var xp = cosphi * x - sinphi * y;
    var yp = sinphi * x + cosphi * y;
    return {
      x: xp + centerx,
      y: yp + centery
    };
  };
  var approxUnitArc = function approxUnitArc2(ang1, ang2) {
    var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
    var x1 = Math.cos(ang1);
    var y1 = Math.sin(ang1);
    var x2 = Math.cos(ang1 + ang2);
    var y2 = Math.sin(ang1 + ang2);
    return [{
      x: x1 - y1 * a,
      y: y1 + x1 * a
    }, {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    }, {
      x: x2,
      y: y2
    }];
  };
  var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
    var sign = ux * vy - uy * vx < 0 ? -1 : 1;
    var dot = ux * vx + uy * vy;
    if (dot > 1) {
      dot = 1;
    }
    if (dot < -1) {
      dot = -1;
    }
    return sign * Math.acos(dot);
  };
  var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
    var rxsq = Math.pow(rx, 2);
    var rysq = Math.pow(ry, 2);
    var pxpsq = Math.pow(pxp, 2);
    var pypsq = Math.pow(pyp, 2);
    var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
    if (radicant < 0) {
      radicant = 0;
    }
    radicant /= rxsq * pypsq + rysq * pxpsq;
    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
    var centerxp = radicant * rx / ry * pyp;
    var centeryp = radicant * -ry / rx * pxp;
    var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
    var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
    var vx1 = (pxp - centerxp) / rx;
    var vy1 = (pyp - centeryp) / ry;
    var vx2 = (-pxp - centerxp) / rx;
    var vy2 = (-pyp - centeryp) / ry;
    var ang1 = vectorAngle(1, 0, vx1, vy1);
    var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
    if (sweepFlag === 0 && ang2 > 0) {
      ang2 -= TAU;
    }
    if (sweepFlag === 1 && ang2 < 0) {
      ang2 += TAU;
    }
    return [centerx, centery, ang1, ang2];
  };
  var arcToBezier = function arcToBezier2(_ref2) {
    var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
    var curves = [];
    if (rx === 0 || ry === 0) {
      return [];
    }
    var sinphi = Math.sin(xAxisRotation * TAU / 360);
    var cosphi = Math.cos(xAxisRotation * TAU / 360);
    var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
    var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
    if (pxp === 0 && pyp === 0) {
      return [];
    }
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
    var ratio = Math.abs(ang2) / (TAU / 4);
    if (Math.abs(1 - ratio) < 1e-7) {
      ratio = 1;
    }
    var segments = Math.max(Math.ceil(ratio), 1);
    ang2 /= segments;
    for (var i = 0; i < segments; i++) {
      curves.push(approxUnitArc(ang1, ang2));
      ang1 += ang2;
    }
    return curves.map(function(curve) {
      var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
      var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
      var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
      return { x1, y1, x2, y2, x, y };
    });
  };
  var modules_default = arcToBezier;

  // src/annotation-targets/normalize-svg.ts
  var import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
  var import_abs_svg_path = __toESM(require_abs_svg_path(), 1);
  function parseAndNormalizeSvgPath(path) {
    const parsed = (0, import_parse_svg_path.default)(path);
    const absolute = (0, import_abs_svg_path.default)(parsed);
    let prevCmd;
    let startX = 0;
    let startY = 0;
    let bezierX = 0;
    let bezierY = 0;
    let quadX;
    let quadY;
    let x = 0;
    let y = 0;
    const out = [];
    for (let i = 0; i < absolute.length; i++) {
      let seg = absolute[i];
      const cmd = seg[0];
      switch (cmd) {
        case "M":
          startX = seg[1];
          startY = seg[2];
          break;
        case "H":
          seg = ["L", seg[1], startY];
          break;
        case "V":
          seg = ["L", startX, seg[1]];
          break;
        case "S":
          {
            let cx = x;
            let cy = y;
            if (prevCmd === "C" || prevCmd == "S") {
              cx += cx - bezierX;
              cy += cy - bezierY;
            }
            seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
          }
          break;
        case "T":
          if (prevCmd === "Q" || prevCmd == "T") {
            quadX = x * 2 - quadX;
            quadY = y * 2 - quadY;
          } else {
            quadX = x;
            quadY = y;
          }
          seg = ["Q", quadX, quadY, seg[1], seg[2]];
          break;
        case "Q":
          quadX = seg[1];
          quadY = seg[2];
          break;
        case "A":
          {
            const curves = modules_default({
              px: x,
              py: y,
              cx: seg[6],
              cy: seg[7],
              rx: seg[1],
              ry: seg[2],
              xAxisRotation: seg[3],
              largeArcFlag: seg[4],
              sweepFlag: seg[5]
            });
            if (!curves.length) {
              continue;
            }
            for (const [j, curve] of curves.entries()) {
              seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
              if (j < curves.length - 1) {
                out.push(seg);
              }
            }
            seg = seg;
          }
          break;
        case "Z":
          seg = ["L", startX, startY];
          break;
      }
      prevCmd = cmd;
      x = seg[seg.length - 2];
      y = seg[seg.length - 1];
      if (["C", "Q", "A"].indexOf(cmd) > -1) {
        bezierX = seg[seg.length - 4];
        bezierY = seg[seg.length - 3];
      } else {
        bezierX = x;
        bezierY = y;
      }
      out.push(seg);
    }
    return out;
  }

  // src/annotation-targets/bezier.ts
  function flattenQuadraticBezier(start, control, end, tolerance = 1) {
    return new QuadraticBezier(start, control, end).subdivide(tolerance);
  }
  function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
    return new CubicBezier(
      new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
    ).subdivide(tolerance);
  }
  function hypot2(p) {
    return p.x * p.x + p.y * p.y;
  }
  function approx_myint(x) {
    const d = 0.67;
    return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));
  }
  function approx_inv_myint(x) {
    const b = 0.39;
    return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));
  }
  var QuadraticBezier = class {
    constructor(start, control, end) {
      __publicField(this, "start");
      __publicField(this, "control");
      __publicField(this, "end");
      this.start = start;
      this.control = control;
      this.end = end;
    }
    eval(t) {
      const mt = 1 - t;
      return {
        x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,
        y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t
      };
    }
    mapToBasic() {
      const { x: x0, y: y0 } = this.start;
      const { x: x1, y: y1 } = this.control;
      const { x: x2, y: y2 } = this.end;
      const ddx = 2 * x1 - x0 - x2;
      const ddy = 2 * y1 - y0 - y2;
      const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
      const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;
      const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;
      const paramX0 = u0 / cross;
      const paramX2 = u2 / cross;
      const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
      return { x0, x2, scale, cross };
    }
    subdivide(tolerance) {
      const params = this.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a2 = approx_myint(params.x2);
      const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);
      const n = Math.ceil(count);
      const u0 = approx_inv_myint(a0);
      const u2 = approx_inv_myint(a2);
      const tValues = [0];
      for (let i = 1; i < n; i++) {
        const u = approx_inv_myint(a0 + (a2 - a0) * i / n);
        const t = (u - u0) / (u2 - u0);
        tValues.push(t);
      }
      tValues.push(1);
      return tValues.map((t) => this.eval(t));
    }
  };
  var CubicBezier = class _CubicBezier {
    /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].
    constructor(coords) {
      __publicField(this, "c");
      this.c = coords;
    }
    weightsum(c0, c1, c2, c3) {
      const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
      const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
      return { x, y };
    }
    eval(t) {
      const mt = 1 - t;
      const c0 = mt * mt * mt;
      const c1 = 3 * mt * mt * t;
      const c2 = 3 * mt * t * t;
      const c3 = t * t * t;
      return this.weightsum(c0, c1, c2, c3);
    }
    deriv(t) {
      const mt = 1 - t;
      const c0 = -3 * mt * mt;
      const c3 = 3 * t * t;
      const c1 = -6 * t * mt - c0;
      const c2 = 6 * t * mt - c3;
      return this.weightsum(c0, c1, c2, c3);
    }
    // quadratic bezier with matching endpoints and minimum max vector error
    midpoint_quadbez() {
      const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
      return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
    }
    subsegment(t0, t1) {
      const c = new Float64Array(8);
      const p0 = this.eval(t0);
      const p3 = this.eval(t1);
      c[0] = p0.x;
      c[1] = p0.y;
      const scale = (t1 - t0) / 3;
      const d1 = this.deriv(t0);
      c[2] = p0.x + scale * d1.x;
      c[3] = p0.y + scale * d1.y;
      const d2 = this.deriv(t1);
      c[4] = p3.x - scale * d2.x;
      c[5] = p3.y - scale * d2.y;
      c[6] = p3.x;
      c[7] = p3.y;
      return new _CubicBezier(c);
    }
    // Very fancy subdivision scheme
    subdivide(tol) {
      const tol1 = 0.1 * tol;
      const tol2 = tol - tol1;
      const sqrt_tol2 = Math.sqrt(tol2);
      const err2 = hypot2(this.weightsum(1, -3, 3, -1));
      const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
      const quads = [];
      let sum = 0;
      for (let i2 = 0; i2 < n_quads; i2++) {
        const t0 = i2 / n_quads;
        const t1 = (i2 + 1) / n_quads;
        const quad = this.subsegment(t0, t1).midpoint_quadbez();
        const params = quad.mapToBasic();
        const a0 = approx_myint(params.x0);
        const a2 = approx_myint(params.x2);
        const scale = Math.sqrt(params.scale);
        let val2 = Math.abs(a2 - a0) * scale;
        if (Math.sign(params.x0) != Math.sign(params.x2)) {
          const xmin = sqrt_tol2 / scale;
          const cusp_val = sqrt_tol2 * Math.abs(a2 - a0) / approx_myint(xmin);
          val2 = Math.max(val2, cusp_val);
        }
        quads.push({
          quad,
          a0,
          a2,
          val: val2
        });
        sum += val2;
      }
      const count = 0.5 * sum / sqrt_tol2;
      const n = Math.ceil(count);
      const result = [{ x: this.c[0], y: this.c[1] }];
      let val = 0;
      let i = 0;
      for (let j = 1; j < n; j++) {
        const target = sum * j / n;
        while (val + quads[i].val < target) {
          val += quads[i].val;
          i++;
        }
        const a0 = quads[i].a0;
        const a2 = quads[i].a2;
        const u0 = approx_inv_myint(a0);
        const u2 = approx_inv_myint(a2);
        const a = a0 + (a2 - a0) * (target - val) / quads[i].val;
        const u = approx_inv_myint(a);
        const t = (u - u0) / (u2 - u0);
        result.push(quads[i].quad.eval(t));
      }
      result.push({ x: this.c[6], y: this.c[7] });
      return result;
    }
  };

  // src/annotation-targets/parse-selector.ts
  var BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
  var TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(\.[0-9]+)?)?(,([0-9]+(\.[0-9]+)?))?/;
  var RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
  function parseSelector(source, {
    domParser,
    svgPreprocessor,
    iiifRenderingHints
  } = {}) {
    if (Array.isArray(source)) {
      return resolveHints(
        source.reduce(
          (data, nextSource) => {
            const {
              selector,
              selectors,
              iiifRenderingHints: newIiifRenderingHints
            } = parseSelector(nextSource, { domParser, svgPreprocessor, iiifRenderingHints });
            if (selector) {
              if (!data.selector) {
                data.selector = selector;
              }
              data.selectors.push(...selectors);
            }
            if (newIiifRenderingHints) {
              data.iiifRenderingHints = data.iiifRenderingHints || { type: "ImageApiSelector" };
              Object.assign(data.iiifRenderingHints, newIiifRenderingHints);
            }
            return data;
          },
          {
            selector: null,
            selectors: [],
            iiifRenderingHints
          }
        )
      );
    }
    if (!source) {
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    if (typeof source === "string") {
      const [id, fragment] = source.split("#");
      if (!fragment) {
        return resolveHints({
          selector: null,
          selectors: [],
          iiifRenderingHints
        });
      }
      return parseSelector(
        { type: "FragmentSelector", value: fragment },
        { svgPreprocessor, iiifRenderingHints, domParser }
      );
    }
    if (source.type) {
      if (source.type === "PointSelector" && (source.t || source.t === 0)) {
        const selector = {
          type: "TemporalSelector",
          temporal: {
            startTime: source.t
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      if (source.type === "PointSelector" && source.x && source.y) {
        const selector = {
          type: "PointSelector",
          spatial: {
            x: source.x,
            y: source.y
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
    }
    if (isImageApiSelector(source)) {
      const selectors = [];
      if (source.region) {
        const parsedRegion = parseSelector(
          { type: "FragmentSelector", value: "xywh=" + source.region },
          { domParser, svgPreprocessor, iiifRenderingHints }
        );
        selectors.push(...parsedRegion.selectors);
      }
      return resolveHints({
        selector: selectors[0],
        selectors,
        iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source
      });
    }
    if (source.type === "FragmentSelector") {
      const matchBoxSelector = BOX_SELECTOR.exec(source.value);
      if (matchBoxSelector) {
        let selector = {
          type: "BoxSelector",
          spatial: {
            unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
            x: Number.parseFloat(matchBoxSelector[3]),
            y: Number.parseFloat(matchBoxSelector[4]),
            width: Number.parseFloat(matchBoxSelector[5]),
            height: Number.parseFloat(matchBoxSelector[6])
          }
        };
        const matchBoxTimeSelector = source.value.match(TEMPORAL_SELECTOR);
        if (matchBoxTimeSelector) {
          selector = {
            type: "TemporalBoxSelector",
            spatial: selector.spatial,
            temporal: {
              startTime: matchBoxTimeSelector[3] ? Number.parseFloat(matchBoxTimeSelector[3]) : 0,
              endTime: matchBoxTimeSelector[6] ? Number.parseFloat(matchBoxTimeSelector[6]) : void 0
            }
          };
        }
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
      if (matchTimeSelector) {
        const selector = {
          type: "TemporalSelector",
          temporal: {
            startTime: matchTimeSelector[3] ? Number.parseFloat(matchTimeSelector[3]) : 0,
            endTime: matchTimeSelector[6] ? Number.parseFloat(matchTimeSelector[6]) : void 0
          }
        };
        return resolveHints({
          selector,
          selectors: [selector],
          iiifRenderingHints
        });
      }
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    if (source.type === "SvgSelector" && "value" in source) {
      if (!domParser) {
        if (typeof window !== "undefined") {
          domParser = new window.DOMParser();
        } else {
          console.warn(
            "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
          );
        }
      }
      let points = [];
      let rect;
      let style;
      let svg = svgPreprocessor?.(source.value) ?? source.value;
      let svgShape;
      if (domParser) {
        const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
        if (!svgElement) {
          console.warn(`Illegal SVG selector: ${source.value}`);
          return resolveHints({
            selector: null,
            selectors: [],
            iiifRenderingHints
          });
        }
        const selectorElem = getSelectorElement(svgElement);
        if (selectorElem) {
          points = selectorElem.points;
          svgShape = selectorElem.shapeType;
          rect = [
            Math.min(...points.map((p) => p[0])),
            // llx
            Math.min(...points.map((p) => p[1])),
            // lly
            Math.max(...points.map((p) => p[0])),
            // urx
            Math.max(...points.map((p) => p[1]))
            // ury
          ];
          ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });
        }
      }
      const sel = {
        type: "SvgSelector",
        svg,
        svgShape,
        style,
        points: points.length ? points : void 0,
        spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
      };
      return resolveHints({
        selector: sel,
        selectors: [sel],
        iiifRenderingHints
      });
    }
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  function getShapeTypeFromPath(svgPath) {
    const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
      (acc, cmd) => {
        acc[cmd] += 1;
        return acc;
      },
      { C: 0, Q: 0, L: 0, M: 0 }
    );
    const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
    if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
      return "path";
    }
    if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
      if (cmdFrequencies.L === 4) {
        return "rect";
      }
      const lastSeg = svgPath.slice(-1)[0];
      if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
        return "polygon";
      } else {
        return "polyline";
      }
    }
    return "path";
  }
  function getSelectorElement(svgElem) {
    for (const element of Array.from(svgElem.children)) {
      switch (element?.tagName.toLowerCase()) {
        case "g":
          {
            const res = getSelectorElement(element);
            if (res) {
              return res;
            }
          }
          continue;
        case "path": {
          const p = element.getAttribute("d");
          if (!p) {
            continue;
          }
          const normalized = parseAndNormalizeSvgPath(p);
          return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
        }
        case "circle": {
          const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
          const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
          const r = Number.parseFloat(element.getAttribute("r") ?? "0");
          if (!r) {
            continue;
          }
          const points = [];
          for (let angle = 0; angle <= 360; angle += 12) {
            const rad = angle * Math.PI / 180;
            points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);
          }
          return { element, points, shapeType: "circle" };
        }
        case "ellipse": {
          const cx = Number.parseFloat(element.getAttribute("cx") ?? "0");
          const cy = Number.parseFloat(element.getAttribute("cy") ?? "0");
          const rx = Number.parseFloat(element.getAttribute("rx") ?? "0");
          const ry = Number.parseFloat(element.getAttribute("ry") ?? "0");
          if (!rx && !ry) {
            continue;
          }
          const points = [];
          for (let angle = 0; angle <= 360; angle += 12) {
            const t = Math.tan(angle / 360 * Math.PI);
            const px = rx * (1 - t ** 2) / (1 + t ** 2);
            const py = ry * 2 * t / (1 + t ** 2);
            points.push([cx + px, cy + py]);
          }
          return { element, points, shapeType: "ellipse" };
        }
        case "line": {
          const x0 = Number.parseFloat(element.getAttribute("x0") ?? "0");
          const y0 = Number.parseFloat(element.getAttribute("y0") ?? "0");
          const x1 = Number.parseFloat(element.getAttribute("x1") ?? "0");
          const y1 = Number.parseFloat(element.getAttribute("y1") ?? "0");
          if (x0 === x1 && y0 === y1) {
            continue;
          }
          return {
            element,
            points: [
              [x0, y0],
              [x1, y1]
            ],
            shapeType: "polyline"
          };
        }
        case "polygon":
        case "polyline": {
          const points = element.getAttribute("points")?.split(" ").map((ps) => ps.split(",").map(Number.parseFloat)) ?? [];
          if (!points.length) {
            continue;
          }
          let shapeType = "polyline";
          if (element.tagName.toLowerCase() === "polygon") {
            points.push(points[0]);
            shapeType = "polygon";
          }
          return { element, points, shapeType };
        }
        case "rect": {
          const x = Number.parseFloat(element.getAttribute("x") ?? "0");
          const y = Number.parseFloat(element.getAttribute("y") ?? "0");
          const width = Number.parseFloat(element.getAttribute("width") ?? "0");
          const height = Number.parseFloat(element.getAttribute("height") ?? "0");
          if (!width || !height) {
            continue;
          }
          return {
            element,
            points: [
              [x, y],
              [x + width, y],
              [x + width, y + height],
              [x, y + height],
              [x, y]
            ],
            shapeType: "rect"
          };
        }
        default:
          continue;
      }
    }
    return null;
  }
  function pathToPoints(normalizedPath) {
    const out = [];
    for (let i = 0; i < normalizedPath.length; i++) {
      const startPoint = out[out.length - 1] ?? [0, 0];
      const seg = normalizedPath[i];
      switch (seg[0]) {
        case "M":
        case "L":
          out.push([seg[1], seg[2]]);
          continue;
        case "C":
          out.push(
            ...flattenCubicBezier(
              { x: startPoint[0], y: startPoint[1] },
              { x: seg[1], y: seg[2] },
              { x: seg[3], y: seg[4] },
              { x: seg[5], y: seg[6] }
            ).map((p) => [p.x, p.y]).slice(1)
            // skip first point, already part of output
          );
          continue;
        case "Q":
          out.push(
            ...flattenQuadraticBezier(
              { x: startPoint[0], y: startPoint[1] },
              { x: seg[1], y: seg[2] },
              { x: seg[3], y: seg[4] }
            ).map((p) => [p.x, p.y]).slice(1)
            // skip first point, already part of output
          );
          continue;
      }
    }
    return out;
  }
  function extractStyles(selectorElement) {
    const style = {};
    if (selectorElement.hasAttribute("fill")) {
      style.fill = selectorElement.getAttribute("fill");
      selectorElement.removeAttribute("fill");
    } else if (selectorElement.style && selectorElement.style.fill) {
      style.fill = selectorElement.style.fill;
    }
    if (style.fill) {
      const rgbaMatch = RGBA_COLOR.exec(style.fill);
      if (rgbaMatch) {
        style.fillOpacity = Number.parseFloat(rgbaMatch[4]);
        style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
      }
    }
    if (selectorElement.hasAttribute("fill-opacity")) {
      style.fillOpacity = Number.parseFloat(selectorElement.getAttribute("fill-opacity"));
      selectorElement.removeAttribute("fill-opacity");
    } else if (selectorElement.style && selectorElement.style.fillOpacity) {
      style.fillOpacity = Number.parseFloat(selectorElement.style.fillOpacity);
    }
    if (selectorElement.hasAttribute("stroke")) {
      style.stroke = selectorElement.getAttribute("stroke");
      selectorElement.removeAttribute("stroke");
    } else if (selectorElement.style && selectorElement.style.stroke) {
      style.stroke = selectorElement.style.stroke;
    }
    if (style.stroke) {
      const rgbaMatch = RGBA_COLOR.exec(style.stroke);
      if (rgbaMatch) {
        style.strokeOpacity = Number.parseFloat(rgbaMatch[4]);
        style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
      }
    }
    if (selectorElement.hasAttribute("stroke-opacity")) {
      style.strokeOpacity = Number.parseFloat(selectorElement.getAttribute("stroke-opacity"));
      selectorElement.removeAttribute("stroke-opacity");
    } else if (selectorElement.style && selectorElement.style.strokeOpacity) {
      style.strokeOpacity = Number.parseFloat(selectorElement.style.strokeOpacity);
    }
    if (selectorElement.hasAttribute("stroke-width")) {
      style.strokeWidth = selectorElement.getAttribute("stroke-width");
      selectorElement.removeAttribute("stroke-width");
    } else if (selectorElement.style && selectorElement.style.strokeWidth) {
      style.strokeWidth = selectorElement.style.strokeWidth;
    }
    if (selectorElement.hasAttribute("stroke-dasharray")) {
      style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
      selectorElement.removeAttribute("stroke-dasharray");
    } else if (selectorElement.style && selectorElement.style.strokeDasharray) {
      style.strokeDasharray = selectorElement.style.strokeDasharray;
    }
    let rootElem = selectorElement;
    while (rootElem.tagName.toLowerCase() !== "svg") {
      rootElem = rootElem.parentElement;
      if (rootElem === null) {
        throw new Error("Could not find root SVG element");
      }
    }
    return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
  }
  function isImageApiSelector(t) {
    if (!t)
      return false;
    const type = t.type || t["@type"];
    return type === "iiif:ImageApiSelector" || type === "ImageApiSelector";
  }
  function resolveHints(supported) {
    if (supported.iiifRenderingHints) {
      const source = supported.iiifRenderingHints;
      if (source.rotation) {
        const parsedRotation = parseRotation(`${source.rotation}`);
        if (parsedRotation) {
          if (supported.selectors.length) {
            for (const selector of supported.selectors) {
              selector.rotation = parsedRotation;
            }
          } else {
            supported.selectors.push({
              type: "RotationSelector",
              rotation: parsedRotation
            });
          }
        }
      }
    } else {
      delete supported.iiifRenderingHints;
    }
    return supported;
  }
  function parseRotation(input) {
    let num = Number.parseFloat(input);
    if (num && input.startsWith("!")) {
      num = 360 - num;
    }
    if (num) {
      num = num % 360;
    }
    if (num !== num) {
      return 0;
    }
    return num || 0;
  }

  // src/annotation-targets/expand-target.ts
  function expandTarget(target, options = {}) {
    if (Array.isArray(target)) {
      return expandTarget(target[0]);
    }
    if (typeof target === "string") {
      const [id, fragment] = target.split("#");
      if (!fragment) {
        return {
          type: "SpecificResource",
          source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
          selector: null,
          selectors: []
        };
      }
      return expandTarget({
        type: "SpecificResource",
        source: { id, type: "Unknown" },
        selector: {
          type: "FragmentSelector",
          value: fragment
        }
      });
    }
    if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
      return expandTarget(target.items[0]);
    }
    if (!target.type && "source" in target) {
      target.type = "SpecificResource";
    }
    if (target.type === "SpecificResource") {
      if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
        target.source.partOf = [
          {
            id: target.source.partOf,
            type: "Manifest"
          }
        ];
      }
      const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
      return {
        type: "SpecificResource",
        source: target.source,
        selector,
        selectors
      };
    }
    if (target.id) {
      if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
        target.partOf = [
          {
            id: target.partOf,
            type: "Manifest"
          }
        ];
      }
      const [id, fragment] = target.id.split("#");
      if (!fragment) {
        return {
          type: "SpecificResource",
          source: {
            ...target,
            id
          },
          selector: null,
          selectors: []
        };
      }
      return expandTarget({
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: {
          type: "FragmentSelector",
          value: fragment
        }
      });
    }
    return {
      type: "SpecificResource",
      source: target,
      selector: null,
      selectors: []
    };
  }

  // src/content-state.ts
  function validateContentState(annotation, strict = false) {
    if (typeof annotation === "string") {
      if (annotation.startsWith("{")) {
        try {
          const parsed = JSON.parse(annotation);
          return validateContentState(parsed);
        } catch (err) {
          return [false, { reason: "Invalid JSON" }];
        }
      }
      return [true];
    }
    if (Array.isArray(annotation)) {
      for (const anno of annotation) {
        const [valid, reason] = validateContentState(anno);
        if (!valid && reason) {
          return [valid, reason];
        }
      }
      return [true];
    }
    if (annotation.type === "Annotation") {
      return [true];
    }
    if (strict && annotation.type === "Canvas" && !annotation.partOf) {
      return [false, { reason: "Canvas without partOf cannot be loaded" }];
    }
    return [true];
  }
  function serialiseContentState(annotation) {
    return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
  }
  function parseContentState(state, asyncOrFetcher) {
    state = state.trim();
    if (state[0] === "{") {
      return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
    }
    if (state.startsWith("http")) {
      if (!asyncOrFetcher) {
        throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
      }
      return fetch(state).then((r) => r.json());
    }
    return parseContentState(decodeContentState(state), asyncOrFetcher);
  }
  function encodeContentState(state) {
    const uriEncoded = encodeURIComponent(state);
    const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
    const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
    return base64url.replace(/=/g, "");
  }
  function decodeContentState(encodedContentState) {
    const base64url = restorePadding(encodedContentState);
    const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
    const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
    return decodeURIComponent(base64Decoded).trim();
  }
  function restorePadding(s) {
    const pad = s.length % 4;
    if (pad === 1) {
      throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
    }
    return s + (pad ? "====".slice(0, 4 - pad) : "");
  }
  function normaliseContentState(state) {
    if (!state) {
      throw new Error("Content state is empty");
    }
    if (!Array.isArray(state)) {
      state = [state];
    }
    let annoId = "vault://virtual-annotation/" + (/* @__PURE__ */ new Date()).getTime();
    const motivation = ["contentState"];
    const targets = [];
    for (const source of state) {
      if (typeof source === "string") {
        throw new Error("Content state is a [String] type and cannot be inferred");
      }
      if (source.type === "Annotation") {
        annoId = source.id;
        if (Array.isArray(source.motivation)) {
          for (const singleMotivation of source.motivation) {
            if (motivation.indexOf(singleMotivation) === -1) {
              motivation.push(singleMotivation);
            }
          }
        }
        if (Array.isArray(source.target)) {
          for (const target2 of source.target) {
            const expanded = expandTarget(target2);
            targets.push(expanded);
          }
        } else {
          const expanded = expandTarget(source.target);
          targets.push(expanded);
        }
        continue;
      }
      const target = expandTarget(source);
      targets.push(target);
    }
    return {
      id: annoId,
      type: "Annotation",
      motivation: ["contentState", ...state.motivation || []],
      target: targets,
      extensions: {}
    };
  }
  return __toCommonJS(content_state_exports);
})();
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
