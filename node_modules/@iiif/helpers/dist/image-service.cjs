"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/image-service.ts
var image_service_exports = {};
__export(image_service_exports, {
  ImageServiceLoader: () => ImageServiceLoader,
  createImageServiceStore: () => createImageServiceStore,
  getCustomSizeFromService: () => getCustomSizeFromService,
  getFixedSizeFromImage: () => getFixedSizeFromImage,
  getFixedSizesFromService: () => getFixedSizesFromService,
  getImageCandidates: () => getImageCandidates,
  getImageCandidatesFromService: () => getImageCandidatesFromService,
  getImageFromTileSource: () => getImageFromTileSource,
  getImageServerFromId: () => getImageServerFromId,
  getSmallestScaleFactorAsSingleImage: () => getSmallestScaleFactorAsSingleImage,
  imageServices: () => imageServices,
  imageSizesMatch: () => imageSizesMatch,
  inferImageSizeFromUrl: () => inferImageSizeFromUrl,
  isBestMatch: () => isBestMatch,
  isImage3: () => isImage3,
  pickBestFromCandidates: () => pickBestFromCandidates,
  sampledTilesToTiles: () => sampledTilesToTiles
});
module.exports = __toCommonJS(image_service_exports);

// src/image-service/image-service-loader.ts
var import_image_36 = require("@iiif/parser/image-3");

// src/image-service/get-image-server-from-id.ts
function getImageServerFromId(url) {
  const id = url.replace(/(https?:\/\/)?(www.)?/i, "");
  if (id.indexOf("/") !== -1) {
    return id.split("/")[0];
  }
  return id;
}

// src/image-service/sampled-tiles-to-tiles.ts
function sampledTilesToTiles(width, height, sampledTiles) {
  const maxDim = width > height ? width : height;
  const len = sampledTiles.length;
  const newTiles = [];
  for (let i = 0; i < len; i++) {
    const tile = sampledTiles[i];
    if (!tile)
      continue;
    if (tile.scaleFactors.length === 0)
      continue;
    let lastSize = tile.scaleFactors[0];
    if (!lastSize)
      continue;
    let curWidth = maxDim / lastSize;
    const scaleFactors = [lastSize];
    while (curWidth >= tile.width) {
      lastSize = lastSize * 2;
      scaleFactors.push(lastSize);
      curWidth = curWidth / 2;
    }
    newTiles.push({
      ...tile,
      scaleFactors
    });
  }
  return newTiles;
}

// src/image-service/get-image-from-tile-source.ts
var import_image_3 = require("@iiif/parser/image-3");
function getImageFromTileSource(image, targetWidth, targetHeight) {
  const req = (0, import_image_3.createImageServiceRequest)({
    "@context": image.version === 3 ? "http://iiif.io/api/image/3/context.json" : "http://iiif.io/api/image/2/context.json",
    id: (0, import_image_3.canonicalServiceUrl)((0, import_image_3.getId)(image)),
    profile: image.level === null || typeof image.level === "undefined" ? "level0" : `level${image.level}`,
    type: image.version === 3 ? "ImageService3" : "ImageService2"
  });
  if (req.type !== "image") {
    throw new Error("Invalid service");
  }
  req.size.max = false;
  req.size.width = targetWidth;
  req.size.height = targetHeight;
  const url = (0, import_image_3.imageServiceRequestToString)(req);
  return {
    id: url,
    type: "fixed",
    width: targetWidth,
    height: targetHeight || image.height / (image.width || 1) * targetWidth,
    unsafe: image.width > targetWidth
  };
}

// src/image-service/is-best-match.ts
function isBestMatch(request, current, candidate) {
  const width = !request.width ? request.maxWidth : request.width;
  return candidate.height <= request.maxHeight && candidate.width <= request.maxWidth && candidate.height >= request.minHeight && candidate.width >= request.minWidth && (!current || Math.abs(candidate.width - width) < Math.abs(current.width - width));
}

// src/image-service/pick-best-from-candidates.ts
function pickBestFromCandidates(inputRequest, candidates) {
  const log = [];
  const request = Object.assign(
    {
      unsafeImageService: false,
      atAnyCost: true,
      fallback: true,
      minHeight: 64,
      minWidth: 64,
      maxHeight: Infinity,
      maxWidth: Infinity,
      returnAllOptions: false,
      preferFixedSize: false,
      allowUnsafe: false,
      explain: false,
      height: 0,
      width: 0
    },
    inputRequest
  );
  const explain = (text, indent = 0) => request.explain ? log.push(
    new Array(indent).fill(0).map((e) => "    ").join("") + text().trim()
  ) : void 0;
  const lastResorts = [];
  const fallback = [];
  let currentChoice = null;
  explain(() => `Using configuration: ${JSON.stringify(request, null, 2)}`);
  const swapChoice = (candidate, current) => {
    explain(() => "Swapping choice", 3);
    if (isBestMatch(request, current, candidate)) {
      if (request.preferFixedSize && candidate.unsafe) {
        explain(() => `We found an image that was marked as unsafe, but it was the best size. (${candidate.id})`, 4);
        fallback.push(candidate);
        return;
      }
      if (request.returnAllOptions && current) {
        fallback.push(current);
      }
      explain(() => `We found a new image that was the best size. (${candidate.id})`, 4);
      currentChoice = candidate;
    } else if (request.returnAllOptions) {
      fallback.push(candidate);
    }
  };
  explain(() => `The input shows we have ${candidates.length} list(s) of candidates to choose from.`);
  const candidateGroups = candidates.length;
  for (let x = 0; x < candidateGroups; x++) {
    const group = candidates[x]();
    explain(() => `Candidate group ${x}: ${JSON.stringify(group, null, 2)}`, 1);
    const candidatesLength = group.length;
    explain(
      () => `Checking candidate list number ${x} and found ${candidatesLength} potential ways of creating image(s)`,
      1
    );
    for (let y = 0; y < candidatesLength; y++) {
      const candidate = group[y];
      explain(() => `-> Checking candidate ${y}`, 1);
      if (candidate.type === "unknown" && request.atAnyCost) {
        explain(() => `We've found an unknown image type, adding this to the "last resort" list`, 2);
        lastResorts.push(candidate);
      }
      if (candidate.type === "fixed") {
        if (candidate.unsafe) {
          explain(() => `We've found an unsafe fixed image type, adding this to the "last resort" list`, 2);
          lastResorts.push(candidate);
        } else {
          explain(() => `We've found a fixed size image, checking if it matches the request`, 2);
          swapChoice(candidate, currentChoice);
        }
      }
      if (candidate.type === "fixed-service") {
        if (request.unsafeImageService) {
          explain(
            () => `Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)`,
            2
          );
          const choice = getImageFromTileSource(candidate, request.width, request.height);
          swapChoice(choice, currentChoice);
        } else {
          explain(() => `Checking for an image from the tile source 3`, 2);
          const choice = getImageFromTileSource(candidate, candidate.width, candidate.height);
          swapChoice(choice, currentChoice);
        }
      }
      if (candidate.type === "variable") {
        if (candidate.maxWidth) {
          const choice = getImageFromTileSource(
            {
              id: candidate.id,
              type: "fixed-service",
              width: candidate.maxWidth,
              height: candidate.maxWidth,
              level: candidate.level,
              version: candidate.version
            },
            candidate.maxWidth
          );
          swapChoice(choice, currentChoice);
        }
      }
    }
    if (currentChoice && !request.returnAllOptions) {
      if (currentChoice.unsafe || request.allowUnsafe) {
        continue;
      }
      explain(() => `We found a match in choice list number ${x}, no searching any more`);
      break;
    }
  }
  if (request.atAnyCost && fallback.length === 0) {
    explain(
      () => currentChoice ? `We found an image! ${currentChoice.id} of type ${currentChoice.type}` : `We found no images, but "atAnyCost" is set, so returning that`
    );
    return {
      best: currentChoice || lastResorts[0] || null,
      fallback: lastResorts.slice(1),
      log
    };
  }
  if (request.returnAllOptions) {
    explain(() => `Returning all options that we have found`);
    return {
      best: (request.atAnyCost ? currentChoice || fallback[0] || lastResorts[0] : currentChoice || fallback[0]) || null,
      fallback: [...fallback, ...lastResorts],
      log
    };
  }
  explain(() => `Returning the best image that we found, and a fallback`);
  return {
    best: currentChoice || fallback[0] || null,
    fallback: currentChoice ? fallback : fallback.slice(1),
    log
  };
}

// src/image-service/get-fixed-sizes-from-service.ts
var import_image_32 = require("@iiif/parser/image-3");

// src/image-service/is-image-3.ts
function isImage3(service) {
  const context = service["@context"] ? Array.isArray(service["@context"]) ? service["@context"] : [service["@context"]] : [];
  return context.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
}

// src/image-service/get-fixed-sizes-from-service.ts
function getFixedSizesFromService(service) {
  if (!(0, import_image_32.isImageService)(service)) {
    return [];
  }
  return (service && service.sizes ? service.sizes : []).map((size) => {
    return {
      id: (0, import_image_32.getId)(service),
      type: "fixed-service",
      height: size.height,
      width: size.width,
      level: (0, import_image_32.getImageServiceLevel)(service),
      version: isImage3(service) ? 3 : 2
    };
  });
}

// src/image-service/get-custom-size-from-service.ts
var import_image_33 = require("@iiif/parser/image-3");
function getCustomSizeFromService(service) {
  if (!(0, import_image_33.supportsCustomSizes)(service)) {
    return [];
  }
  const imagesSizes = [];
  const profiles = Array.isArray(service.profile) ? service.profile : [service.profile];
  const pLen = profiles.length;
  for (let x = 0; x < pLen; x++) {
    const profile = profiles[x];
    if (profile && typeof profile !== "string") {
      if (profile.maxHeight || profile.maxWidth) {
        return [
          {
            id: (0, import_image_33.getId)(service),
            type: "variable",
            minWidth: 0,
            minHeight: 0,
            maxHeight: profile.maxHeight || profile.maxWidth,
            maxWidth: profile.maxWidth || profile.maxHeight,
            level: (0, import_image_33.getImageServiceLevel)(service),
            version: service["@context"] === "http://iiif.io/api/image/3/context.json" ? 3 : 2
          }
        ];
      }
    }
  }
  if (service.tiles) {
    const len = service.tiles.length;
    for (let y = 0; y < len; y++) {
      const tile = service.tiles[y];
      if (tile && (tile.height || tile.width)) {
        imagesSizes.push({
          id: (0, import_image_33.getId)(service),
          type: "variable",
          minHeight: 0,
          minWidth: 0,
          maxHeight: tile.height || tile.width,
          maxWidth: tile.width,
          level: (0, import_image_33.getImageServiceLevel)(service),
          version: isImage3(service) ? 3 : 2
        });
      }
    }
  }
  return imagesSizes;
}

// src/image-service/get-image-candidates-from-service.ts
function getImageCandidatesFromService(service) {
  const candidates = [];
  const totalServices = service.length;
  for (let s = 0; s < totalServices; s++) {
    const single = service[s];
    if (!single)
      continue;
    const fixedSizes = getFixedSizesFromService(single);
    if (fixedSizes.length) {
      candidates.push(...fixedSizes);
    }
    const customSizes = getCustomSizeFromService(single);
    if (customSizes.length) {
      candidates.push(...customSizes);
    }
  }
  return candidates;
}

// src/image-service/infer-size-from-url.ts
function inferImageSizeFromUrl(image) {
  const regex = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/;
  const match = image.match(regex);
  if (match && match[4] && match[5]) {
    const region = match[1];
    const width = parseInt(match[4], 10);
    const height = parseInt(match[5], 10);
    const format = match[7];
    if ((region === "max" || region === "full") && width && height && format) {
      return {
        type: "fixed",
        id: image,
        height,
        width
      };
    }
  }
  return { type: "unknown", id: image };
}

// src/image-service/get-fixed-size-from-image.ts
var import_image_34 = require("@iiif/parser/image-3");
function getFixedSizeFromImage(contentResource) {
  if (typeof contentResource === "string") {
    return inferImageSizeFromUrl(contentResource);
  }
  const type = (0, import_image_34.getType)(contentResource);
  if (type !== "Image" && type !== "sc:Image") {
    return null;
  }
  const image = contentResource;
  const id = (0, import_image_34.getId)(image);
  if (!id) {
    return null;
  }
  if (id && image.width && image.height) {
    return {
      id,
      type: "fixed",
      width: image.width,
      height: image.height,
      unsafe: true
    };
  }
  return inferImageSizeFromUrl(id);
}

// src/image-service/get-image-candidates.ts
var import_image_35 = require("@iiif/parser/image-3");
function getImageCandidates(unknownResource, dereference = true, loader) {
  const candidates = [];
  const fixedSizeFromImage = getFixedSizeFromImage(unknownResource);
  if (fixedSizeFromImage === null) {
    return candidates;
  }
  const resource = unknownResource;
  candidates.push(fixedSizeFromImage);
  if (dereference && resource && resource.width && resource.height) {
    const refCandidates = [];
    const imageServices2 = (0, import_image_35.getImageServices)(resource);
    for (const service of imageServices2) {
      const request = {
        id: (0, import_image_35.getId)(service),
        width: resource.width,
        height: resource.height
      };
      if (loader.canLoadSync(request)) {
        const externalService = loader.loadServiceSync(request);
        if (externalService) {
          if (!externalService.height) {
            externalService.height = resource.height;
          }
          if (!externalService.width) {
            externalService.width = resource.width;
          }
          refCandidates.push(...getImageCandidatesFromService([externalService]));
        }
      }
    }
    if (refCandidates.length) {
      candidates.push(...refCandidates);
      return candidates;
    }
  }
  if (resource.service) {
    candidates.push(...getImageCandidatesFromService(resource.service));
  }
  return candidates;
}

// src/image-service/image-sizes-match.ts
function imageSizesMatch(sizesA, sizesB) {
  if (sizesA.length !== sizesB.length) {
    return false;
  }
  if (sizesA.length === 0 && sizesB.length === 0) {
    return true;
  }
  const len = sizesA.length;
  let matchOrder = true;
  for (let i = 0; i < len; i++) {
    const a = sizesA[i];
    const b = sizesB[i];
    if (a.width !== b.width || a.height !== b.height) {
      matchOrder = false;
      break;
    }
  }
  if (matchOrder) {
    return true;
  }
  let matching = 0;
  for (let a = 0; a < len; a++) {
    for (let b = 0; b < len; b++) {
      if (sizesA[a].width === sizesB[b].width && sizesA[a].height === sizesB[b].height) {
        matching++;
        break;
      }
    }
  }
  return matching === len;
}

// src/image-service/image-service-loader.ts
var ImageServiceLoader = class {
  constructor(options = {}) {
    __publicField(this, "config", {
      verificationsRequired: 1,
      approximateServices: false,
      enableFetching: true,
      disableThrottling: false
    });
    __publicField(this, "fetchingCount", 0);
    __publicField(this, "imageServices", {});
    __publicField(this, "knownImageServers", {});
    this.config = Object.assign(this.config, options);
  }
  /**
   * Preload image service
   *
   * This will preload an image service, fetching details and recording the image server that served
   * the request. Based on this it will make a template for predicting other image sources from this
   * server. You can optionally pass in other ids to verify that the prediction is accurate.
   *
   */
  // async preload(id: string, verify?: string[]): Promise<void> {}
  setConfig(config) {
    Object.assign(this.config, config);
  }
  /**
   * Sample pre-fetched service
   *
   * If you have already fetched an image service, or are creating a viewer that only talks to a single
   * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
   * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
   *
   * @param service
   * @param preLoaded Mark this as being pre-loaded (default: true)
   */
  sample(service, imageServiceRequest, preLoaded = true) {
    const server = getImageServerFromId((0, import_image_36.getId)(service));
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(service));
    const existing = this.knownImageServers[server];
    this.imageServices[serviceUrl] = Object.assign(service, { real: true });
    if (!existing && service.tiles && !(0, import_image_36.isLevel0)(service)) {
      this.knownImageServers[server] = {
        verifications: 0,
        malformed: false,
        root: server,
        preLoaded,
        sampledId: (0, import_image_36.getId)(service),
        verified: false,
        server: null,
        result: {
          context: service["@context"] || [],
          sampledProfile: service.profile,
          resourceServiceRatio: imageServiceRequest && service.height ? imageServiceRequest.height / service.height : 1,
          sampledSizes: service.sizes || [],
          sizeRatios: (0, import_image_36.extractFixedSizeScales)(service.width, service.height, service.sizes || []),
          sampledTiles: service.tiles || []
        }
      };
      return true;
    }
    return this.verify(service);
  }
  /**
   * Preload an image server
   *
   * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
   * allowing you to correct mistakes this implementation might have made.
   *
   * @param server
   * @param forceVerify
   */
  preLoad(server, forceVerify = true) {
    this.knownImageServers[server.root] = server;
    if (forceVerify) {
      this.knownImageServers[server.root].malformed = false;
      this.knownImageServers[server.root].verifications = this.config.verificationsRequired;
    }
  }
  /**
   * Predict
   *
   * Predicts what the image service will be for a content resource.
   *
   * @param resource
   * @param verify
   * @param force
   */
  predict(resource, verify = false, force = false) {
    const source = resource?.source;
    const serverId = getImageServerFromId((0, import_image_36.getId)(resource));
    const imageServer = this.knownImageServers[serverId];
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(resource));
    if (this.imageServices[serviceUrl]) {
      return this.imageServices[serviceUrl] || null;
    }
    if (!this.config.approximateServices) {
      return null;
    }
    if (!imageServer || !imageServer.result || !(source?.height || resource.height) || !(source?.width || resource.width) || !force && (imageServer.malformed || imageServer.verifications < this.config.verificationsRequired) || resource.source && (0, import_image_36.isLevel0)(resource.source)) {
      return null;
    }
    if (!this.imageServices[serviceUrl]) {
      this.imageServices[serviceUrl] = {
        "@context": imageServer.result.context,
        "@id": (0, import_image_36.getId)(resource),
        id: (0, import_image_36.getId)(resource),
        protocol: "http://iiif.io/api/image",
        tiles: source?.tiles || sampledTilesToTiles(resource.width, resource.height, imageServer.result.sampledTiles),
        sizes: source?.sizes || (0, import_image_36.fixedSizesFromScales)(
          Math.round(resource.width / imageServer.result.resourceServiceRatio),
          Math.round(resource.height / imageServer.result.resourceServiceRatio),
          imageServer.result.sizeRatios
        ),
        profile: source?.profile || imageServer.result.sampledProfile,
        height: source?.height || resource.height,
        width: source?.width || resource.width,
        real: false
      };
    }
    return this.imageServices[serviceUrl] || null;
  }
  async getThumbnailFromResource(unknownResource, request, dereference = true, otherCandidates = []) {
    const candidates = unknownResource ? await this.getImageCandidates(unknownResource, dereference) : [];
    return pickBestFromCandidates(request, [() => otherCandidates, () => candidates]);
  }
  async getImageCandidates(unknownResource, dereference = true) {
    const resource = unknownResource;
    if (dereference && resource && resource.height && resource.width) {
      const imageServices2 = (0, import_image_36.getImageServices)(resource);
      for (const service of imageServices2) {
        const request = {
          id: (0, import_image_36.getId)(service),
          width: service.width ? service.width : resource.width,
          height: service.height ? service.height : resource.height,
          source: service
        };
        await this.loadService(request);
      }
    }
    return getImageCandidates(unknownResource, dereference, this);
  }
  /**
   * Verify approximation
   *
   * Given an image service, it will dereference that image service and compare the result with what
   * would have been generated if we used internal guessing.
   *
   * @param resource
   * @return Promise<boolean>
   */
  async verify(resource) {
    const prediction = this.predict(resource, false, true);
    const imageService = await this.fetchService((0, import_image_36.getId)(resource));
    if (!prediction) {
      return false;
    }
    const isValid = prediction.height === imageService.height && prediction.width === imageService.width && prediction["@context"] === imageService["@context"] && imageSizesMatch(prediction.sizes || [], imageService.sizes || []);
    if (isValid) {
      const serverId = getImageServerFromId((0, import_image_36.getId)(resource));
      const server = this.knownImageServers[serverId];
      if (server) {
        server.verifications += 1;
        if (server.verifications >= this.config.verificationsRequired) {
          server.verified = true;
        }
      }
    }
    return isValid;
  }
  canLoadSync(service) {
    const serviceId = typeof service === "string" ? service : (0, import_image_36.getId)(service);
    const canonical = (0, import_image_36.canonicalServiceUrl)(serviceId);
    if (this.imageServices[canonical]) {
      return true;
    }
    const server = this.knownImageServers[getImageServerFromId(serviceId)];
    return !!(server && !server.malformed && server.verifications >= this.config.verificationsRequired);
  }
  /**
   * Mark image service as malformed
   *
   * If you run into issues requesting images, you can mark an image service as malformed, and it will
   * return you a new one. Future image services will also be requested fresh, and the system will have
   * failed. Report a bug if this happens.
   *
   * @param resource
   */
  async markAsMalformed(resource) {
    this.knownImageServers[getImageServerFromId((0, import_image_36.getId)(resource))].malformed = true;
    return this.loadService(resource, true);
  }
  /**
   * Fetch an image service (use loadService instead)
   *
   * @param serviceId
   * @param forceFresh
   */
  async fetchService(serviceId, forceFresh = false) {
    const serviceUrl = (0, import_image_36.canonicalServiceUrl)(serviceId);
    const service = this.imageServices[serviceUrl];
    if (service && (!forceFresh || service.real)) {
      return service;
    }
    if (!this.config.enableFetching) {
      throw new Error("Fetching is not enabled");
    }
    const json = await this.fetch(serviceUrl).then((service2) => service2.json());
    if (!json.id && json["@id"]) {
      json.id = json["@id"];
    }
    if (json.id !== serviceId) {
      json.id = serviceId;
      if (json["@id"]) {
        json["@id"] = serviceId;
      }
    }
    this.imageServices[serviceUrl] = Object.assign(json, { real: true });
    return this.imageServices[serviceUrl];
  }
  async fetch(input, init) {
    return fetch(input, init);
  }
  /**
   * Load an image service
   *
   * @param resource
   * @param forceFresh
   *
   * @todo make this batched, so only the maximum required can be done at once, to allow
   *       for the prediction engine to kick in.
   */
  async loadService(resource, forceFresh = false) {
    if (!this.config.disableThrottling) {
      let running = true;
      while (running) {
        if (this.fetchingCount >= this.config.verificationsRequired) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        } else {
          running = false;
          break;
        }
      }
    }
    const imageServer = this.knownImageServers[getImageServerFromId((0, import_image_36.getId)(resource))];
    if (imageServer && !imageServer.malformed && !forceFresh) {
      await imageServer.result;
      const service = this.loadServiceSync(resource);
      if (service) {
        return service;
      }
    }
    this.fetchingCount++;
    const serviceJson = await this.fetchService((0, import_image_36.getId)(resource), forceFresh);
    this.fetchingCount--;
    if (serviceJson.real) {
      this.sample(serviceJson, resource);
    }
    return serviceJson;
  }
  /**
   * Load service synchronously
   *
   * If you know that the image service you are
   * @param resource
   */
  loadServiceSync(resource) {
    const serviceId = (0, import_image_36.canonicalServiceUrl)((0, import_image_36.getId)(resource));
    if (this.imageServices[serviceId]) {
      return this.imageServices[serviceId];
    }
    if (!this.config.approximateServices) {
      return null;
    }
    return this.predict(resource);
  }
};

// node_modules/.pnpm/zustand@4.5.2_react@18.2.0/node_modules/zustand/esm/vanilla.mjs
var import_meta = {};
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}

// src/image-service/image-service-store.ts
var import_image_37 = require("@iiif/parser/image-3");
function createImageServiceStore(options = {}) {
  const events = options.events || mitt_default();
  const loader = options.loader || new ImageServiceLoader();
  const store = createStore((set, get) => ({
    loaded: {},
    loadServiceSync: (service, detail, backgroundRequest) => {
      const id = service.id || service["@id"];
      const existing = get().loaded[id];
      if (existing && existing.status === "done") {
        return existing.service;
      }
      if (existing && existing.status === "loading") {
        return null;
      }
      if (existing && existing.status === "error") {
        throw new Error("Failed to load image service");
      }
      const request = {
        id: (0, import_image_37.getId)(service),
        width: service.width || detail?.width || 0,
        height: service.height || detail?.height || 0,
        source: service
      };
      const loaded = loader.loadServiceSync(request);
      if (loaded) {
        set((state) => ({
          loaded: {
            ...state.loaded,
            [id]: {
              status: "done",
              service: loaded,
              real: true
            }
          }
        }));
        events.emit("image-service.loaded", { id, service: loaded });
      } else {
        if (backgroundRequest) {
          get().loadService(service, detail).then(() => {
          });
        }
      }
      return loaded;
    },
    loadService: async (service, detail) => {
      const id = service.id || service["@id"];
      const existing = get().loaded[id];
      if (existing && existing.status === "done") {
        return existing.service;
      }
      if (existing && existing.status === "loading") {
        return new Promise((resolve, reject) => {
          const handler = (e) => {
            if (e.id === id) {
              events.off("image-service.loaded", handler);
              resolve(e.service || service);
            }
          };
          events.on("image-service.loaded", handler);
        });
      }
      if (existing && existing.status === "error" && !detail?.force) {
        throw new Error("Failed to load image service");
      }
      events.emit("image-service.loading", { id });
      try {
        const request = {
          id: (0, import_image_37.getId)(service),
          width: service.width || 0,
          height: service.height || 0,
          source: service
        };
        const loaded = await loader.loadService(request, detail?.force);
        set((state) => ({
          loaded: {
            ...state.loaded,
            [id]: {
              status: "done",
              service: loaded,
              real: loaded.real
            }
          }
        }));
        events.emit("image-service.loaded", { id, service: loaded });
        return loaded;
      } catch (error) {
        events.emit("image-service.error", { id, error });
        throw error;
      }
    }
  }));
  return {
    store,
    events
  };
}
var imageServices = createImageServiceStore();

// src/image-service/get-smallest-scale-factor-as-single-image.ts
var import_image_38 = require("@iiif/parser/image-3");
function getSmallestScaleFactorAsSingleImage(service) {
  if (!service.width || !service.height) {
    return null;
  }
  if (service.tiles) {
    const tiles = service.tiles.sort((a, b) => {
      return Math.max(...b.scaleFactors) - Math.max(...a.scaleFactors);
    });
    const len = tiles.length;
    for (let i = 0; i < len; i++) {
      const tile = tiles[i];
      if (!tile)
        continue;
      const targetSize = tile.width;
      if (!targetSize) {
        continue;
      }
      const sizeLen = tile.scaleFactors.length;
      const sortedScales = tile.scaleFactors.sort();
      for (let j = 0; j < sizeLen; j++) {
        const size = sortedScales[j];
        if (!size)
          continue;
        if (service.width / size <= targetSize && service.height / size <= targetSize) {
          return {
            id: (0, import_image_38.getId)(service),
            type: "fixed-service",
            width: service.width / size | 0,
            height: service.height / size | 0,
            level: (0, import_image_38.getImageServiceLevel)(service),
            version: isImage3(service) ? 3 : 2
          };
        }
      }
    }
  }
  return null;
}
