import { ImageSize, ImageTile, ImageProfile, ImageService, ContentResource } from '@iiif/presentation-3';

type FixedSizeImage = {
    id: string;
    type: 'fixed';
    width: number;
    height: number;
    unsafe?: boolean;
};
type FixedSizeImageService = {
    id: string;
    type: 'fixed-service';
    width: number;
    height: number;
    level?: number | null;
    version?: number;
};
type VariableSizeImage = {
    id: string;
    type: 'variable';
    minWidth: number;
    maxWidth: number;
    minHeight: number;
    maxHeight: number;
    level?: number | null;
    version?: number;
};
type UnknownSizeImage = {
    id: string;
    type: 'unknown';
};
type ImageCandidate = FixedSizeImage | VariableSizeImage | UnknownSizeImage | FixedSizeImageService;
type ImageCandidateRequest = {
    width?: number;
    height?: number;
    maxWidth?: number;
    maxHeight?: number;
    minWidth?: number;
    minHeight?: number;
    fallback?: boolean;
    atAnyCost?: boolean;
    unsafeImageService?: boolean;
    returnAllOptions?: boolean;
    allowUnsafe?: boolean;
    preferFixedSize?: boolean;
    explain?: boolean;
};

type ImageServer = {
    root: string;
    server: string | null;
    sampledId: string;
    verifications: number;
    verified: boolean;
    preLoaded: boolean;
    malformed: boolean;
    result: {
        context: string | string[];
        resourceServiceRatio: number;
        sampledSizes: ImageSize[];
        sizeRatios: number[];
        sampledTiles: ImageTile[];
        sampledProfile: ImageProfile | ImageProfile[];
    };
};
type ImageServiceRequest = {
    id: string;
    width: number;
    height: number;
    source?: ImageService;
};
type LoadedImageService = ImageService & {
    real: boolean;
};
type ImageServiceLoaderConfig = {
    verificationsRequired: number;
    approximateServices: boolean;
    enableFetching: boolean;
    disableThrottling: boolean;
};
declare class ImageServiceLoader {
    constructor(options?: Partial<ImageServiceLoaderConfig>);
    config: ImageServiceLoaderConfig;
    fetchingCount: number;
    imageServices: {
        [k: string]: LoadedImageService;
    };
    knownImageServers: {
        [k: string]: ImageServer;
    };
    /**
     * Preload image service
     *
     * This will preload an image service, fetching details and recording the image server that served
     * the request. Based on this it will make a template for predicting other image sources from this
     * server. You can optionally pass in other ids to verify that the prediction is accurate.
     *
     */
    setConfig(config: Partial<ImageServiceLoaderConfig>): void;
    /**
     * Sample pre-fetched service
     *
     * If you have already fetched an image service, or are creating a viewer that only talks to a single
     * image server and want to avoid calls, you can sample a service up-front. This will allow you to make
     * completely synchronous calls to `loadServiceSync` and avoid any network calls for image services.
     *
     * @param service
     * @param preLoaded Mark this as being pre-loaded (default: true)
     */
    sample(service: ImageService, imageServiceRequest?: ImageServiceRequest, preLoaded?: boolean): true | Promise<boolean>;
    /**
     * Preload an image server
     *
     * Similar to sample, but faster. This will bypass any checks and the logic contained in this implementation
     * allowing you to correct mistakes this implementation might have made.
     *
     * @param server
     * @param forceVerify
     */
    preLoad(server: ImageServer, forceVerify?: boolean): void;
    /**
     * Predict
     *
     * Predicts what the image service will be for a content resource.
     *
     * @param resource
     * @param verify
     * @param force
     */
    predict(resource: ImageServiceRequest, verify?: boolean, force?: boolean): ImageService | null;
    getThumbnailFromResource(unknownResource: ContentResource | undefined, request: ImageCandidateRequest, dereference?: boolean, otherCandidates?: ImageCandidate[]): Promise<{
        best: ImageCandidate | null;
        fallback: ImageCandidate[];
        log: string[];
    }>;
    getImageCandidates(unknownResource: ContentResource, dereference?: boolean): Promise<ImageCandidate[]>;
    /**
     * Verify approximation
     *
     * Given an image service, it will dereference that image service and compare the result with what
     * would have been generated if we used internal guessing.
     *
     * @param resource
     * @return Promise<boolean>
     */
    verify(resource: ImageServiceRequest): Promise<boolean>;
    canLoadSync(service: ImageServiceRequest | ImageService | string): boolean;
    /**
     * Mark image service as malformed
     *
     * If you run into issues requesting images, you can mark an image service as malformed, and it will
     * return you a new one. Future image services will also be requested fresh, and the system will have
     * failed. Report a bug if this happens.
     *
     * @param resource
     */
    markAsMalformed(resource: ImageServiceRequest): Promise<ImageService>;
    /**
     * Fetch an image service (use loadService instead)
     *
     * @param serviceId
     * @param forceFresh
     */
    fetchService(serviceId: string, forceFresh?: boolean): Promise<ImageService & {
        real: boolean;
    }>;
    fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;
    /**
     * Load an image service
     *
     * @param resource
     * @param forceFresh
     *
     * @todo make this batched, so only the maximum required can be done at once, to allow
     *       for the prediction engine to kick in.
     */
    loadService(resource: ImageServiceRequest, forceFresh?: boolean): Promise<ImageService>;
    /**
     * Load service synchronously
     *
     * If you know that the image service you are
     * @param resource
     */
    loadServiceSync(resource: ImageServiceRequest): ImageService | null;
}

export { type FixedSizeImage as F, type ImageServer as I, type UnknownSizeImage as U, type VariableSizeImage as V, type ImageServiceRequest as a, type ImageServiceLoaderConfig as b, ImageServiceLoader as c, type FixedSizeImageService as d, type ImageCandidate as e, type ImageCandidateRequest as f };
