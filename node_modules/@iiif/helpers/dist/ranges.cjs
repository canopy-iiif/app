"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ranges.ts
var ranges_exports = {};
__export(ranges_exports, {
  createRangeHelper: () => createRangeHelper,
  findAllCanvasesInRange: () => findAllCanvasesInRange,
  findFirstCanvasFromRange: () => findFirstCanvasFromRange,
  findFirstCanvasFromRangeWithSelector: () => findFirstCanvasFromRangeWithSelector,
  findManifestSelectedRange: () => findManifestSelectedRange,
  findSelectedRange: () => findSelectedRange,
  rangeToTableOfContentsTree: () => rangeToTableOfContentsTree,
  rangesToTableOfContentsTree: () => rangesToTableOfContentsTree
});
module.exports = __toCommonJS(ranges_exports);

// src/compat.ts
var metaState = {};
var compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  },
  async load(id) {
    const idToLoad = typeof id === "string" ? id : id.id;
    return fetch(idToLoad).then((response) => response.json());
  },
  requestStatus(id) {
    return void 0;
  }
};

// src/ranges.ts
var import_parser = require("@iiif/parser");

// src/shared-utilities.ts
function hash(object) {
  const text = JSON.stringify(object);
  let numHash = 5381, index = text.length;
  while (index) {
    numHash = numHash * 33 ^ text.charCodeAt(--index);
  }
  const num = numHash >>> 0;
  const hexString = num.toString(16);
  if (hexString.length % 2) {
    return "0" + hexString;
  }
  return hexString;
}

// src/ranges.ts
function createRangeHelper(vault = compatVault) {
  return {
    findFirstCanvasFromRange: (range) => findFirstCanvasFromRange(vault, range),
    findAllCanvasesInRange: (range) => findAllCanvasesInRange(vault, range),
    findManifestSelectedRange: (manifest, canvasId) => findManifestSelectedRange(vault, manifest, canvasId),
    findSelectedRange: (range, canvasId) => findSelectedRange(vault, range, canvasId),
    rangesToTableOfContentsTree: (rangeRefs, label) => rangesToTableOfContentsTree(vault, rangeRefs, label),
    rangeToTableOfContentsTree: (rangeRef) => rangeToTableOfContentsTree(vault, rangeRef)
  };
}
function findFirstCanvasFromRange(vault, range) {
  for (const inner of range.items) {
    if (typeof inner === "string") {
      return { id: inner, type: "Canvas" };
    }
    if (inner.type === "Canvas") {
      return inner;
    }
    if (inner.type === "SpecificResource") {
      if (inner.source?.type === "Canvas") {
        return inner.source;
      }
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRange(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findFirstCanvasFromRangeWithSelector(vault, range) {
  for (const inner of range.items) {
    if (typeof inner === "string") {
      return { type: "SpecificResource", source: { id: inner, type: "Canvas" } };
    }
    if (inner.type === "Canvas") {
      return { type: "SpecificResource", source: inner };
    }
    if (inner.type === "SpecificResource") {
      if (inner.source?.type === "Canvas") {
        return inner;
      }
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRangeWithSelector(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findAllCanvasesInRange(vault, range) {
  const found = [];
  for (const inner of range.items) {
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
      if (inner.source.id.indexOf("#") !== -1) {
        found.push({ id: inner.source.id.split("#")[0], type: "Canvas" });
      } else {
        found.push(inner.source);
      }
    }
    if (inner.type === "Range") {
      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
    }
    if (inner.type === "SpecificResource") {
      const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
      found.push({ id: sourceId, type: "Canvas" });
    }
  }
  return found;
}
function findManifestSelectedRange(vault, manifest, canvasId) {
  for (const range of manifest.structures) {
    const found = findSelectedRange(vault, vault.get(range), canvasId);
    if (found) {
      return found;
    }
  }
  return null;
}
function findSelectedRange(vault, range, canvasId) {
  for (const inner of range.items) {
    const parsedId = inner?.source?.id?.split("#")[0];
    if (inner.type === "SpecificResource" && inner.source === canvasId) {
      return range;
    }
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas" && canvasId === parsedId) {
      return range;
    }
    if (inner.type === "Range") {
      const found = findSelectedRange(vault, vault.get(inner), canvasId);
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function rangesToTableOfContentsTree(vault, rangeRefs, label) {
  if (rangeRefs.length === 0) {
    return null;
  }
  const ranges = vault.get(rangeRefs);
  if (ranges.length === 1) {
    return rangeToTableOfContentsTree(vault, ranges[0]);
  }
  const virtualRoot = {
    id: `vault://virtual-root/${hash(ranges)}`,
    type: "Range",
    label: label || { en: ["Table of Contents"] },
    items: ranges
  };
  return rangeToTableOfContentsTree(vault, virtualRoot);
}
function rangeToTableOfContentsTree(vault, rangeRef, seenIds = []) {
  if (!rangeRef)
    return null;
  const range = vault.get(rangeRef, { skipSelfReturn: false });
  const toc = {
    id: range.id,
    type: "Range",
    label: range.label,
    untitled: !range.label,
    isCanvasLeaf: false,
    isRangeLeaf: false,
    items: []
  };
  if (seenIds.indexOf(toc.id) !== -1) {
    toc.id = `vault://${hash(range)}`;
  }
  if (!range.items) {
    return toc;
  }
  if (range.behavior && range.behavior.includes("no-nav")) {
    return null;
  }
  for (const inner of range.items) {
    if (typeof inner === "string") {
      const maybeCanvas = vault.get({ id: inner, type: "Canvas" }, { skipSelfReturn: false });
      const foundCanvas = {
        id: inner,
        type: "Canvas",
        isCanvasLeaf: true,
        isRangeLeaf: false,
        label: maybeCanvas.label || { none: ["Untitled"] },
        untitled: !maybeCanvas.label,
        resource: {
          type: "SpecificResource",
          source: { id: inner, type: "Canvas" }
        }
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      continue;
    }
    if (inner.type === "SpecificResource" && inner.source?.type === "Canvas") {
      const maybeCanvas = vault.get(inner.source);
      const compressed = (0, import_parser.compressSpecificResource)(inner);
      if (!maybeCanvas) {
        continue;
      }
      const foundCanvas = {
        id: compressed.type === "Canvas" ? compressed.id : inner.source.id,
        type: "Canvas",
        isCanvasLeaf: true,
        isRangeLeaf: false,
        label: maybeCanvas.label || { none: ["Untitled"] },
        untitled: !maybeCanvas.label,
        resource: inner
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      toc.items.push(foundCanvas);
      continue;
    }
    if (inner.type === "Canvas") {
      const foundCanvas = {
        id: inner.id,
        type: "Canvas",
        label: inner.label,
        isCanvasLeaf: true,
        isRangeLeaf: false,
        resource: {
          type: "SpecificResource",
          source: inner
        }
      };
      if (seenIds.indexOf(foundCanvas.id) !== -1) {
        foundCanvas.id = `vault://${hash(inner)}`;
      }
      seenIds.push(foundCanvas.id);
      continue;
    }
    if (inner.type === "Range") {
      const foundRange = rangeToTableOfContentsTree(vault, inner, seenIds);
      if (foundRange) {
        toc.items.push(foundRange);
      }
      continue;
    }
  }
  toc.firstCanvas = findFirstCanvasFromRangeWithSelector(vault, range);
  toc.isRangeLeaf = toc.items ? toc.items.filter((i) => i.type === "Range").length === 0 : true;
  return toc;
}
