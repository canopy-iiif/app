"use strict";
var IIIFHelpers = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/i18n.ts
  var i18n_exports = {};
  __export(i18n_exports, {
    buildLocaleString: () => buildLocaleString,
    createStringHelper: () => createStringHelper,
    getAvailableLanguagesFromResource: () => getAvailableLanguagesFromResource,
    getClosestLanguage: () => getClosestLanguage,
    getValue: () => getValue,
    iiifString: () => iiifString
  });

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-NJNTZ6QT.js
  function i(e2) {
    return Array.isArray(e2) ? e2 : e2 ? [e2] : [];
  }

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-D22QKJZO.js
  var d = Object.defineProperty;
  var e = (b, a2, c) => a2 in b ? d(b, a2, { enumerable: true, configurable: true, writable: true, value: c }) : b[a2] = c;
  var f = (b, a2, c) => (e(b, typeof a2 != "symbol" ? a2 + "" : a2, c), c);

  // node_modules/.pnpm/@iiif+parser@2.2.0/node_modules/@iiif/parser/dist/chunk-ERHCHADU.js
  function v(a2) {
    return typeof a2 == "string" ? false : a2 && !a2.type && "source" in a2 ? (a2.type = "SpecificResource", true) : !!a2 && a2.type === "SpecificResource";
  }
  function o(...a2) {
    return (e2) => a2.reduce((t, n) => n(t), e2);
  }
  var p = ["Collection", "Manifest", "Canvas", "AnnotationPage", "AnnotationCollection", "Annotation", "ContentResource", "Range", "Service", "Selector", "Agent"];
  function y(a2, e2) {
    if (typeof a2 > "u" || a2 === null)
      throw new Error("Null or undefined is not a valid entity.");
    if (Array.isArray(a2))
      throw new Error("Array is not a valid entity");
    if (typeof a2 != "object") {
      if (e2)
        return e2;
      throw new Error(`${typeof a2} is not a valid entity`);
    }
    if (typeof a2.type == "string") {
      let t = p.indexOf(a2.type);
      if (t !== -1)
        return p[t];
    }
    if (a2.profile)
      return "Service";
    throw new Error("Resource type is not known");
  }
  var l = class a {
    constructor(e2, t = {}) {
      f(this, "traversals");
      f(this, "options");
      f(this, "_traverseManifest", o(this.traverseManifestItems.bind(this), this.traverseNavPlace.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this), this.traverseManifestStructures.bind(this), this.traverseInlineAnnotationPages.bind(this)));
      f(this, "_traverseCanvas", o(this.traverseCanvasItems.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this), this.traverseInlineAnnotationPages.bind(this)));
      f(this, "_traverseAnnotationPage", o(this.traverseAnnotationPageItems.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this)));
      f(this, "_traverseRange", o(this.traverseRangeRanges.bind(this), this.traverseLinking.bind(this), this.traverseDescriptive.bind(this), this.traverseLinkedCanvases.bind(this)));
      this.traversals = { collection: [], manifest: [], canvas: [], annotationCollection: [], annotationPage: [], annotation: [], contentResource: [], choice: [], range: [], service: [], agent: [], specificResource: [], geoJson: [], ...e2 }, this.options = { allowUndefinedReturn: false, ...t };
    }
    static all(e2) {
      return new a({ collection: [e2], manifest: [e2], canvas: [e2], annotationCollection: [e2], annotationPage: [e2], annotation: [e2], contentResource: [e2], choice: [e2], range: [e2], service: [e2], geoJson: [e2], specificResource: [e2], agent: [e2] });
    }
    traverseDescriptive(e2) {
      return e2.thumbnail && (e2.thumbnail = i(e2.thumbnail).map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.provider && (e2.provider = e2.provider.map((t) => this.traverseAgent(t, e2))), e2;
    }
    traverseLinking(e2) {
      return e2.seeAlso && (e2.seeAlso = e2.seeAlso.map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.service && (e2.service = i(e2.service).map((t) => this.traverseService(t))), e2.services && (e2.services = i(e2.services).map((t) => this.traverseService(t, e2))), e2.logo && (e2.logo = e2.logo.map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.homepage && (e2.homepage = i(e2.homepage).map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.partOf && (e2.partOf = e2.partOf.map((t) => typeof t == "string" || !t.type ? this.traverseType(t, { parent: e2 }, this.traversals.contentResource) : t.type === "Canvas" ? this.traverseType(t, { parent: e2 }, this.traversals.canvas) : t.type === "AnnotationCollection" ? this.traverseType(t, { parent: e2 }, this.traversals.annotationCollection) : t.type === "Collection" ? this.traverseType(t, { parent: e2 }, this.traversals.collection) : this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.start && (v(e2.start) ? e2.start = this.traverseSpecificResource(e2.start, "Canvas", e2) : e2.start = this.traverseType(e2.start, { parent: e2 }, this.traversals.canvas)), e2.rendering && (e2.rendering = e2.rendering.map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2.supplementary && (e2.supplementary = e2.supplementary.map((t) => this.traverseType(t, { parent: e2 }, this.traversals.contentResource))), e2;
    }
    traverseCollectionItems(e2) {
      return e2.items && e2.items.map((t) => t.type === "Collection" ? this.traverseCollection(t) : this.traverseManifest(t)), e2;
    }
    traverseCollection(e2, t) {
      return this.traverseType(this.traverseDescriptive(this.traverseNavPlace(this.traverseInlineAnnotationPages(this.traverseLinking(this.traverseLinkedCanvases(this.traverseCollectionItems(e2)))))), { parent: t }, this.traversals.collection);
    }
    traverseGeoJson(e2, t) {
      return this.traverseType(e2, { parent: t }, this.traversals.geoJson);
    }
    traverseNavPlace(e2) {
      return e2.navPlace && (e2.navPlace = this.traverseGeoJson(e2.navPlace, e2)), e2;
    }
    traverseManifestItems(e2) {
      return e2.items && (e2.items = e2.items.map((t) => this.traverseCanvas(t))), e2;
    }
    traverseManifestStructures(e2) {
      return e2.structures && (e2.structures = e2.structures.map((t) => this.traverseRange(t))), e2;
    }
    traverseManifest(e2, t) {
      return this.traverseType(this._traverseManifest(e2), { parent: t }, this.traversals.manifest);
    }
    traverseCanvasItems(e2) {
      return e2.items = (e2.items || []).map((t) => this.traverseAnnotationPage(t, e2)), e2;
    }
    traverseInlineAnnotationPages(e2) {
      return typeof e2 == "string" || !e2 || e2.annotations && (e2.annotations = e2.annotations.map((t) => this.traverseAnnotationPage(t, e2))), e2;
    }
    traverseCanvas(e2, t) {
      return this.traverseType(this._traverseCanvas(e2), { parent: t }, this.traversals.canvas);
    }
    traverseAnnotationPageItems(e2) {
      return e2.items && (e2.items = e2.items.map((t) => this.traverseAnnotation(t, e2))), e2;
    }
    traverseAnnotationPage(e2, t) {
      return this.traverseType(this._traverseAnnotationPage(e2), { parent: t }, this.traversals.annotationPage);
    }
    traverseAnnotationBody(e2) {
      return Array.isArray(e2.body) ? e2.body = e2.body.map((t) => this.traverseContentResource(t, e2)) : e2.body && (e2.body = this.traverseContentResource(e2.body, e2)), e2;
    }
    traverseLinkedCanvases(e2) {
      return e2.placeholderCanvas && (e2.placeholderCanvas = this.traverseCanvas(e2.placeholderCanvas)), e2.accompanyingCanvas && (e2.accompanyingCanvas = this.traverseCanvas(e2.accompanyingCanvas)), e2;
    }
    traverseAnnotation(e2, t) {
      return this.traverseType(this.traverseLinking(this.traverseAnnotationBody(this.traverseDescriptive(e2))), { parent: t }, this.traversals.annotation);
    }
    traverseContentResourceLinking(e2) {
      return typeof e2 == "string" || !e2 || e2 && e2.service && (e2.service = i(e2.service || []).map((t) => this.traverseService(t, e2))), e2;
    }
    traverseContentResource(e2, t) {
      return e2.type === "Choice" && (e2.items = e2.items.map((n) => this.traverseContentResource(n, e2))), v(e2) ? this.traverseSpecificResource(e2, "ContentResource") : this.traverseType(this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(e2)), { parent: t }, this.traversals.contentResource);
    }
    traverseSpecificResource(e2, t, n) {
      let s = e2.source;
      return typeof e2.source == "string" && (s = { id: e2.source, type: t || "unknown" }), this.traverseType({ ...e2, source: t === "Canvas" || s.type === "Canvas" ? this.traverseType(s, { parent: n }, this.traversals.canvas) : t === "ContentResource" ? this.traverseContentResource(s, { parent: n }) : this.traverseUnknown(s, { parent: n, typeHint: t }) }, { parent: n }, this.traversals.specificResource);
    }
    traverseRangeRanges(e2) {
      return e2.items && (e2.items = e2.items.map((t) => typeof t == "string" ? this.traverseCanvas({ id: t, type: "Canvas" }, e2) : v(t) ? this.traverseSpecificResource(t, "Canvas", e2) : t.type === "Manifest" ? this.traverseManifest(t, e2) : this.traverseRange(t, e2))), e2;
    }
    traverseRange(e2, t) {
      return this.traverseType(this._traverseRange(e2), { parent: t }, this.traversals.range);
    }
    traverseAgent(e2, t) {
      return this.traverseType(this.traverseDescriptive(this.traverseLinking(e2)), { parent: t }, this.traversals.agent);
    }
    traverseType(e2, t, n) {
      return n.reduce((s, c) => {
        let h = c(s, t);
        return typeof h > "u" && !this.options.allowUndefinedReturn ? s : h;
      }, e2);
    }
    traverseService(e2, t) {
      let n = Object.assign({}, e2);
      return n && n.service && (n.service = i(n.service).map((s) => this.traverseService(s))), this.traverseType(n, { parent: t }, this.traversals.service);
    }
    traverseUnknown(e2, { parent: t, typeHint: n } = {}) {
      let s = y(e2, n);
      switch (s) {
        case "Collection":
          return this.traverseCollection(e2, t);
        case "Manifest":
          return this.traverseManifest(e2, t);
        case "Canvas":
          return this.traverseCanvas(e2, t);
        case "AnnotationPage":
          return this.traverseAnnotationPage(e2, t);
        case "Annotation":
          return this.traverseAnnotation(e2, t);
        case "ContentResource":
          return this.traverseContentResource(e2, t);
        case "Range":
          return this.traverseRange(e2, t);
        case "Service":
          return this.traverseService(e2, t);
        case "Agent":
          return this.traverseAgent(e2, t);
        default:
          throw new Error(`Unknown or unsupported resource type of ${s}`);
      }
    }
  };

  // src/i18n.ts
  function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false, skipLanguages = []) {
    if (skipLanguages.length) {
      languages = languages.filter((l2) => skipLanguages.indexOf(l2) === -1);
    }
    if (!languages || languages.length === 0) {
      return void 0;
    }
    if (languages.length === 1) {
      return languages[0];
    }
    if (!i18nLanguage) {
      if (languages.indexOf("none") !== -1) {
        return "none";
      }
      return languages[0];
    }
    if (languages.indexOf(i18nLanguage) !== -1) {
      return i18nLanguage;
    }
    const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
    if (root && languages.indexOf(root) !== -1) {
      return root;
    }
    for (const lang of i18nLanguages) {
      if (languages.indexOf(lang) !== -1) {
        return lang;
      }
    }
    if (!strictFallback && i18nLanguage) {
      const inverseRoot = languages.map((l2) => l2.indexOf("-") !== -1 ? l2.slice(0, l2.indexOf("-")) : null);
      const inverseIdx = inverseRoot.indexOf(i18nLanguage);
      if (inverseIdx !== -1) {
        return languages[inverseIdx];
      }
      for (const lang of i18nLanguages) {
        const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
        const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
        if (inverseIdx2 !== -1) {
          return languages[inverseIdx2];
        }
      }
    }
    if (languages.indexOf("none") !== -1) {
      return "none";
    }
    if (languages.indexOf("@none") !== -1) {
      return "@none";
    }
    return languages[0];
  }
  function buildLocaleString(inputText, i18nLanguage, options = {}) {
    const {
      strictFallback = false,
      defaultText = "",
      separator = "\n",
      fallbackLanguages = [],
      closest,
      skipLanguages
    } = options;
    const languages = Object.keys(inputText || {});
    const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback, skipLanguages);
    if (!inputText) {
      return defaultText;
    }
    if (typeof inputText === "string") {
      return inputText;
    }
    const candidateText = language ? inputText[language] : void 0;
    if (candidateText && language) {
      if (typeof candidateText === "string") {
        return candidateText;
      }
      if (candidateText.length === 1 && candidateText[0] === "") {
        const skip = options.skipLanguages || [];
        return buildLocaleString(inputText, i18nLanguage, {
          ...options,
          skipLanguages: [...skip, language]
        });
      }
      return candidateText.join(separator);
    }
    return "";
  }
  function getValue(inputText, options = {}) {
    return buildLocaleString(
      inputText,
      options.language || (typeof navigator !== "undefined" ? navigator.language : "en"),
      options
    );
  }
  function getLanguagesFromLanguageMap(languageMap) {
    if (!languageMap)
      return [];
    if (typeof languageMap === "string")
      return [];
    if (Array.isArray(languageMap))
      return [];
    return Object.keys(languageMap).filter((l2) => l2 !== "none");
  }
  function getAvailableLanguagesFromResource(item) {
    const foundLanguages = /* @__PURE__ */ new Set();
    const findLanguages = l.all((resource) => {
      if ("label" in resource) {
        const languages = getLanguagesFromLanguageMap(resource.label);
        languages.forEach((l2) => foundLanguages.add(l2));
      }
      if ("summary" in resource) {
        const languages = getLanguagesFromLanguageMap(resource.summary);
        languages.forEach((l2) => foundLanguages.add(l2));
      }
      if ("language" in resource) {
        if (typeof resource.language === "string") {
          foundLanguages.add(resource.language);
        }
      }
      if ("requiredStatement" in resource) {
        if (resource.requiredStatement && !Array.isArray(resource.requiredStatement)) {
          if ("label" in resource.requiredStatement) {
            const languages = getLanguagesFromLanguageMap(resource.requiredStatement.label);
            languages.forEach((l2) => foundLanguages.add(l2));
          }
          if ("value" in resource.requiredStatement) {
            const languages = getLanguagesFromLanguageMap(resource.requiredStatement.value);
            languages.forEach((l2) => foundLanguages.add(l2));
          }
        }
      }
      if ("metadata" in resource) {
        if (Array.isArray(resource.metadata)) {
          resource.metadata.forEach((m) => {
            if ("label" in m) {
              const languages = getLanguagesFromLanguageMap(m.label);
              languages.forEach((l2) => foundLanguages.add(l2));
            }
            if ("value" in m) {
              const languages = getLanguagesFromLanguageMap(m.value);
              languages.forEach((l2) => foundLanguages.add(l2));
            }
          });
        }
      }
    });
    findLanguages.traverseUnknown(item);
    return Array.from(foundLanguages);
  }
  var iiifString = createStringHelper();
  function createStringHelper(options = {}) {
    return (template, ...params) => {
      let result = "";
      for (let i2 = 0; i2 < template.length; i2++) {
        result += template[i2];
        if (i2 < params.length) {
          const param = params[i2];
          if (param === null || param === void 0) {
            continue;
          } else if (typeof param === "string") {
            result += param;
          } else {
            result += getValue(param, options);
          }
        }
      }
      return result;
    };
  }
  return __toCommonJS(i18n_exports);
})();
