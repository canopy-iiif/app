import { ServiceNormalized, CollectionNormalized, ManifestNormalized, CanvasNormalized, AnnotationPageNormalized, AnnotationCollectionNormalized, AnnotationNormalized, RangeNormalized, ResourceProviderNormalized } from '@iiif/presentation-3-normalized';
import { AnnotationCollection, ContentResource, Selector, Reference, SpecificResource, AnnotationPage, Manifest, Collection, Canvas, Annotation, ChoiceTarget, ChoiceBody, Range, Service, ResourceProvider, DescriptiveProperties, LinkingProperties, StructuralProperties, InternationalString } from '@iiif/presentation-3';
import * as geojson from 'geojson';
import * as Presentation2 from '@iiif/presentation-2';

declare const WILDCARD: {};
declare const HAS_PART = "iiif-parser:hasPart";
declare const PART_OF = "iiif-parser:partOf";
declare const IS_EXTERNAL = "iiif-parser:isExternal";
declare const UNSET = "__$UNSET$__";
declare const UNWRAP = "__$UNWRAP$__";
declare const EMPTY: never[];
declare function isWildcard(object: any): boolean;
declare function frameResource(resource: any, framing: any): any;
declare function resolveIfExists<T extends NormalizedEntity>(state: CompatibleStore, urlOrResource: any, parent?: any): readonly [T | undefined, T | undefined];

type Field = any[];
type CompatibleStore<T extends string = string> = {
    requests: {
        [url: string]: {
            resourceUri?: string;
        } & any;
    };
    entities: {
        [type in T]: {
            [id: string]: NormalizedEntity;
        };
    };
    mapping: {
        [id: string]: T;
    };
};
type _ServiceNormalized = ServiceNormalized & {
    id: string;
    type: string;
};
type NormalizedEntity = CollectionNormalized | ManifestNormalized | CanvasNormalized | AnnotationPageNormalized | AnnotationCollectionNormalized | AnnotationCollection | AnnotationNormalized | ContentResource | RangeNormalized | _ServiceNormalized | Selector | ResourceProviderNormalized | {
    id?: string;
    '@id'?: string;
    type?: string;
    '@type'?: string;
    [key: string]: any;
};
type SerializerContext = {
    isTopLevel?: boolean;
    parent?: any;
    fullResource?: any;
};
type Serializer<Type extends NormalizedEntity> = (entity: Type, state: any, context: SerializerContext) => Generator<Reference | Reference[], typeof UNSET | Field[], any>;
type SerializeConfig = {
    Collection?: Serializer<CollectionNormalized>;
    Manifest?: Serializer<ManifestNormalized>;
    Canvas?: Serializer<CanvasNormalized>;
    AnnotationPage?: Serializer<AnnotationPageNormalized>;
    AnnotationCollection?: Serializer<AnnotationCollectionNormalized>;
    Annotation?: Serializer<AnnotationNormalized>;
    ContentResource?: Serializer<ContentResource>;
    Range?: Serializer<RangeNormalized>;
    Service?: Serializer<_ServiceNormalized>;
    Selector?: Serializer<Selector>;
    Agent?: Serializer<ResourceProviderNormalized>;
};
declare function serializedFieldsToObject<T>(fields: Field[] | [string]): T;
declare function serialize<Return>(state: CompatibleStore, subject: Reference, config: SerializeConfig): Return;

declare const emptyAnnotation: AnnotationNormalized;
declare const emptyAnnotationPage: AnnotationPageNormalized;
declare const emptyCanvas: CanvasNormalized;
declare const emptyCollection: CollectionNormalized;
declare const emptyManifest: ManifestNormalized;
declare const emptyRange: RangeNormalized;
declare const emptyAgent: ResourceProviderNormalized;
declare const emptyService: _ServiceNormalized;

declare const defaultEntities: {
    Collection: {};
    Manifest: {};
    Canvas: {};
    AnnotationPage: {};
    AnnotationCollection: {};
    Annotation: {};
    ContentResource: {};
    Range: {};
    Service: {};
    Selector: {};
    Agent: {};
};
declare function getDefaultEntities(): {
    Collection: {};
    Manifest: {};
    Canvas: {};
    AnnotationPage: {};
    AnnotationCollection: {};
    Annotation: {};
    ContentResource: {};
    Range: {};
    Service: {};
    Selector: {};
    Agent: {};
};
declare function merge(existing: any, incoming: any, context?: {
    parent?: any;
    isTopLevel?: boolean;
}): any;
declare function mergeEntities(existing: NormalizedEntity, incoming: any, context?: {
    parent?: any;
    isTopLevel?: boolean;
}): NormalizedEntity;
declare function traverseSpecificResource(specificResource: SpecificResource): SpecificResource;
declare function addFlagForExternalResource<T extends AnnotationPage | Manifest | Collection>(resource: T): T;
declare function normalize(unknownEntity: unknown): {
    entities: {
        Collection: {};
        Manifest: {};
        Canvas: {};
        AnnotationPage: {};
        AnnotationCollection: {};
        Annotation: {};
        ContentResource: {};
        Range: {};
        Service: {};
        Selector: {};
        Agent: {};
    };
    resource: {
        type: string;
        id: string;
    };
    mapping: {};
};

declare const types: string[];
type TraversalContext = {
    parent?: any;
};
type Traversal<T> = (jsonLd: T, context: TraversalContext) => Partial<T> | any;
type TraversalMap = {
    collection?: Array<Traversal<Collection>>;
    manifest?: Array<Traversal<Manifest>>;
    canvas?: Array<Traversal<Canvas>>;
    annotationCollection?: Array<Traversal<AnnotationCollection>>;
    annotationPage?: Array<Traversal<AnnotationPage>>;
    annotation?: Array<Traversal<Annotation>>;
    contentResource?: Array<Traversal<ContentResource>>;
    choice?: Array<Traversal<ChoiceTarget | ChoiceBody>>;
    range?: Array<Traversal<Range>>;
    service?: Array<Traversal<Service>>;
    agent?: Array<Traversal<ResourceProvider>>;
    specificResource?: Array<Traversal<SpecificResource>>;
    geoJson?: Array<Traversal<geojson.GeoJSON>>;
};
type TraverseOptions = {
    allowUndefinedReturn: boolean;
};
declare function identifyResource(resource: any, typeHint?: string): string;
declare class Traverse {
    private traversals;
    private options;
    constructor(traversals: TraversalMap, options?: Partial<TraverseOptions>);
    static all(traversal: (resource: any) => any): Traverse;
    traverseDescriptive<T extends Partial<DescriptiveProperties>>(resource: T): T;
    traverseLinking<T extends Partial<LinkingProperties>>(resource: T): T;
    traverseCollectionItems<T extends StructuralProperties<any>>(collection: T): T;
    traverseCollection(collection: Collection, parent?: any): Collection;
    traverseGeoJson(geoJson: geojson.GeoJSON, parent?: any): geojson.GeoJSON;
    traverseNavPlace(resource: any): any;
    traverseManifestItems(manifest: Manifest): Manifest;
    traverseManifestStructures(manifest: Manifest): Manifest;
    _traverseManifest: (manifest: Manifest) => Manifest;
    traverseManifest(manifest: Manifest, parent?: any): Manifest;
    traverseCanvasItems(canvas: Canvas): Canvas;
    traverseInlineAnnotationPages<T extends Manifest | Canvas | Range | string>(resource: T): T;
    _traverseCanvas: (canvas: Canvas) => Canvas;
    traverseCanvas(canvas: Canvas, parent?: any): Canvas;
    traverseAnnotationPageItems(annotationPage: AnnotationPage): AnnotationPage;
    _traverseAnnotationPage: (page: AnnotationPage) => AnnotationPage;
    traverseAnnotationPage(annotationPageJson: AnnotationPage, parent?: any): AnnotationPage;
    traverseAnnotationBody(annotation: Annotation): Annotation;
    traverseLinkedCanvases<T extends {
        placeholderCanvas?: any;
        accompanyingCanvas?: any;
    }>(json: T): T;
    traverseAnnotation(annotationJson: Annotation, parent?: any): Annotation;
    traverseContentResourceLinking(contentResourceJson: ContentResource): ContentResource;
    traverseContentResource(contentResourceJson: ContentResource, parent?: any): ContentResource;
    traverseSpecificResource(specificResource: SpecificResource, typeHint?: string, parent?: any): SpecificResource;
    traverseRangeRanges(range: Range): Range;
    _traverseRange: (range: Range) => Range;
    traverseRange(range: Range, parent?: any): Range;
    traverseAgent(agent: ResourceProvider, parent?: any): ResourceProvider;
    traverseType<T>(object: T, context: TraversalContext, traversals: Array<Traversal<T>>): T;
    traverseService(service: Service, parent?: any): Service;
    traverseUnknown(resource: any, { parent, typeHint }?: {
        typeHint?: string;
        parent?: any;
    }): Collection | Manifest | Canvas | AnnotationPage | Annotation | ContentResource | Range | Service | ResourceProvider;
}

declare function languageString2to3(value: InternationalString | null | undefined): Presentation2.LanguageProperty | Presentation2.LanguageProperty[] | undefined;
declare const serializeConfigPresentation2: SerializeConfig;

declare const serializeConfigPresentation3: SerializeConfig;

declare function toRef<T extends string = any>(reference: any, _typeHint?: T): Reference<T> | undefined;

declare function compressSpecificResource(target: undefined | SpecificResource, { allowSourceString, allowString, allowedStringType }?: {
    allowString?: boolean;
    allowSourceString?: boolean;
    allowedStringType?: string;
}): any;

declare function isSpecificResource(resource: unknown): resource is SpecificResource;

export { type CompatibleStore, EMPTY, type Field, HAS_PART, IS_EXTERNAL, type NormalizedEntity, PART_OF, type SerializeConfig, type Serializer, type Traversal, type TraversalContext, type TraversalMap, Traverse, type TraverseOptions, UNSET, UNWRAP, WILDCARD, type _ServiceNormalized, addFlagForExternalResource, compressSpecificResource, defaultEntities, emptyAgent, emptyAnnotation, emptyAnnotationPage, emptyCanvas, emptyCollection, emptyManifest, emptyRange, emptyService, frameResource, getDefaultEntities, identifyResource, isSpecificResource, isWildcard, languageString2to3, merge, mergeEntities, normalize, resolveIfExists, serialize, serializeConfigPresentation2, serializeConfigPresentation3, serializedFieldsToObject, toRef, traverseSpecificResource, types };
